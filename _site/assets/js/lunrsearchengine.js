
var documents = [{
    "id": 0,
    "url": "http://localhost:4000/404.html",
    "title": "404",
    "body": "404 Page does not exist!Please use the search bar at the top or visit our homepage! "
    }, {
    "id": 1,
    "url": "http://localhost:4000/categories",
    "title": "Categories",
    "body": ""
    }, {
    "id": 2,
    "url": "http://localhost:4000/",
    "title": "Home",
    "body": "      Featured:                                                                                                                                                                                                           Python String Formatting 방법                              :               python은 다양한 문자열 포맷팅 방법을 지원합니다. 본 포스팅에서는 각 방법의 사용법과 장단점 등에 대하여 설명하도록 하겠습니다. 참고로, python의 버전에 따라 지원되는 포맷팅 방법이 달라지기도 하니. . . :                                                                                                                                                                         Chloe Jungah Kim                                    16 Jul 2024                                                                                                                                                                                                                                                                                  Python Tutorial - 5분만에 훑어보기                              :               파이썬(Python)은 간결함과 직관성 덕분에 프로그래밍 입문자 뿐만 아니라 숙련된 개발자들 사이에서도 널리 사용되고 있는 프로그래밍 언어입니다. 이번 포스팅에서는 파이썬의 기초를 간략하게 다루어 짧은 시간 안에. . . :                                                                                                                                                                         Chloe Jungah Kim                                    15 Jul 2024                                                                                                                                                                                                                                                                                  Jekyll Blog(Github Pages) 검색 엔진에 노출시키기 (Google Search Console)                              :               블로그를 만들었다면 다른 사람들이 내 블로그를 검색해서 유입되길 기대할 겁니다. 하지만 Github Pages와 Jekyll로 만든 블로그의 경우 검색 엔진에 자동으로 노출되지 않기 때문에 직접 사이트맵을. . . :                                                                                                                                                                         Chloe Jungah Kim                                    03 Jul 2024                                                                                                                                                                                                                                                                                  Jekyll Blog(Github Pages)에 Google Anayltics 연결하기                              :               Github Pages와 Jekyll로 생성한 블로그의 경우, 트래픽 분석 등을 따로 제공하지 않기 때문에 누가 어떤 방식으로 내 블로그에 유입되었는지 알기 힘들다는 한계점이 있습니다. 이를 보완하기. . . :                                                                                                                                                                         Chloe Jungah Kim                                    29 Jun 2024                                                                                                                                                                                                                                                                                  Github pages와 Jekyll 설치하기 - Windows ver.                               :               jekyll은 github pages를 지원하는 정적 웹사이트 생성기입니다. 저장되어 있는 html, markdown 파일을 그대로 가져와서 선택한 레이아웃에 따라 html 코드로 변환해 정적 웹사이트를 생성해줍니다. jekyll은 매우. . . :                                                                                                                                                                         Chloe Jungah Kim                                    26 Jun 2024                                                                                                                                                                                                                                                                                                                                                                                                                          All Stories:                                                                                                     Python String Formatting 방법              :       python은 다양한 문자열 포맷팅 방법을 지원합니다. 본 포스팅에서는 각 방법의 사용법과 장단점 등에 대하여 설명하도록 하겠습니다. 참고로, python의 버전에 따라 지원되는 포맷팅 방법이 달라지기도 하니 사용하는 python의 버전을 확인하고 사용하시기. . . :                                                                               Chloe Jungah Kim                16 Jul 2024                                                                                                                    Python Tutorial - 5분만에 훑어보기              :       파이썬(Python)은 간결함과 직관성 덕분에 프로그래밍 입문자 뿐만 아니라 숙련된 개발자들 사이에서도 널리 사용되고 있는 프로그래밍 언어입니다. 이번 포스팅에서는 파이썬의 기초를 간략하게 다루어 짧은 시간 안에 훑어볼 수 있도록 작성하겠습니다. 파이썬의. . . :                                                                               Chloe Jungah Kim                15 Jul 2024                                                                                                                    Jekyll Blog(Github Pages) 검색 엔진에 노출시키기 (Google Search Console)              :       블로그를 만들었다면 다른 사람들이 내 블로그를 검색해서 유입되길 기대할 겁니다. 하지만 Github Pages와 Jekyll로 만든 블로그의 경우 검색 엔진에 자동으로 노출되지 않기 때문에 직접 사이트맵을 등록하여 데이터가 수집되도록 해야 합니다. . . . :                                                                               Chloe Jungah Kim                03 Jul 2024                                                                                                                    Jekyll Blog(Github Pages)에 Google Anayltics 연결하기              :       Github Pages와 Jekyll로 생성한 블로그의 경우, 트래픽 분석 등을 따로 제공하지 않기 때문에 누가 어떤 방식으로 내 블로그에 유입되었는지 알기 힘들다는 한계점이 있습니다. 이를 보완하기 위하여 Google Analytics를 통해 누가,. . . :                                                                               Chloe Jungah Kim                29 Jun 2024                                                                                                                    Github pages와 Jekyll 설치하기 - Windows ver.               :       jekyll은 github pages를 지원하는 정적 웹사이트 생성기입니다. 저장되어 있는 html, markdown 파일을 그대로 가져와서 선택한 레이아웃에 따라 html 코드로 변환해 정적 웹사이트를 생성해줍니다. jekyll은 매우 가벼우며, liquid 언어를 지원하여 동적. . . :                                                                               Chloe Jungah Kim                26 Jun 2024                                                                                                                    [Leetcode] 167. Two Sum II - Input Array is Sorted              :       주어진 정수 배열에서 두 값의 합이 찾고자 하는 값(target)일 경우, 두 인덱스를 반환하는 문제 주어진 정수 배열은 이미 증가하는 방향으로 정렬되어 있다. 인덱스는 non zero-based로 리턴해야 한다. (1부터 시작) 정확히. . . :                                                                               Chloe Jungah Kim                23 Oct 2019                               &laquo; Prev       1        2        3        4        5        6        7        8        9        10      Next &raquo; "
    }, {
    "id": 3,
    "url": "http://localhost:4000/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 4,
    "url": "http://localhost:4000/page2/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 5,
    "url": "http://localhost:4000/page3/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 6,
    "url": "http://localhost:4000/page4/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 7,
    "url": "http://localhost:4000/page5/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 8,
    "url": "http://localhost:4000/page6/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 9,
    "url": "http://localhost:4000/page7/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 10,
    "url": "http://localhost:4000/page8/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 11,
    "url": "http://localhost:4000/page9/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 12,
    "url": "http://localhost:4000/page10/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 13,
    "url": "http://localhost:4000/python-string-formatting/",
    "title": "Python String Formatting 방법",
    "body": "2024/07/16 - python은 다양한 문자열 포맷팅 방법을 지원합니다. 본 포스팅에서는 각 방법의 사용법과 장단점 등에 대하여 설명하도록 하겠습니다. 참고로, python의 버전에 따라 지원되는 포맷팅 방법이 달라지기도 하니 사용하는 python의 버전을 확인하고 사용하시기 바랍니다. % operator% operator는 C 스타일로 문자열을 포맷팅하는 방법입니다. python3 이전에 사용되던 방법으로, python 버전에 상관이 없으며, C 문법에 익숙하다면 간단하게 사용할 수 있습니다. % operator를 사용하는 경우, 포맷팅하고자 하는 자료형의 데이터 타입이 동일해야 하는데, 때문에 자료형 별로 어떠한 문자열 포맷 코드를 사용해야 하는지를 알고 있어야 합니다. 사용 예시는 다음과 같습니다. 12&gt;&gt;&gt;  Hello %s  %  World 'Hello World'많이 사용되는 포맷 코드는 다음과 같습니다. 참고로 % 문자 자체를 출력하고 싶은 경우에는 %%를 사용합니다.       포맷 코드   설명         %s   문자열       %d   정수       %f   실수       %o   8진수       %x, %X   16진수 (lowercase, uppercase)       %c   단일 문자   포맷 코드와 연결된 데이터의 타입이 다를 경우에는 에러가 발생하게 됩니다. 예를 들어, %d 포맷 코드를 사용하였는데 문자열을 넣어주는 경우 TypeError가 발생합니다. 하지만 특이하게 %s 포맷 코드의 경우에는 어떠한 타입의 값이건 넣을 수 있습니다. 1234&gt;&gt;&gt;  I am %s years old  % 31'I am 31 years old'&gt;&gt;&gt;  Pi number is %s  % 3. 14'Pi number is 3. 14'위와 같이 정수 타입인 %d나 실수 타입인 %f를 쓰지 않아도 %s를 사용하면 자동으로 넘어오는 값들을 문자열로 바꾸어 대입해주게 됩니다. 여러 개의 값 사용하기: 문자열 안에 여러 개의 포맷 코드를 사용하는 경우에는 % 뒤에 오는 값들을 콤마로 구분하여 소괄호로 감싸야 합니다. 소괄호로 묶지 않으면 에러가 발생하게 됩니다. 값들은 순서대로 연결되며, 포맷 코드의 개수와 변수의 개수가 동일하여야 합니다. 1234&gt;&gt;&gt;  %d + %d = %d  % (1, 2, 3)'1 + 2 = 3'&gt;&gt;&gt;  Today is %d %s  % (6, 'June')'Today is 6 June'값들이 소괄호로 묶여 있지 않다거나(이 경우 값이 하나만 넘어온 것으로 간주됩니다), 값이 적거나 많은 경우에는 다음과 같이 에러가 발생합니다. 123456&gt;&gt;&gt;  %d + %d = %d  % 1, 2, 3TypeError: not enough arguments for format string&gt;&gt;&gt;  %d + %d = %d  % (1, 2)TypeError: not enough arguments for format string&gt;&gt;&gt;  %d + %d = %d  % (1, 2, 3, 4, 5)TypeError: not all arguments converted during string formatting장단점: 낮은 버전의 python에서도 호환이 된다는 장점이 있으나, % operator의 경우, 사용하고자 하는 데이터의 타입이 정확히 일치해야 한다는 단점이 있습니다. 또한, 포맷팅할 문자열이 길어지는 경우 가독성이 매우 떨어집니다. 때문에 사용을 권장하지는 않습니다. str. format()python3에서 도입된 방법으로, % operator보다 더 유연하고 읽기 쉬운 포맷팅을 제공합니다. 사용 예시는 다음과 같습니다. 1234&gt;&gt;&gt; name =  Bob &gt;&gt;&gt; age = 25&gt;&gt;&gt;  Hi, my name is {}. I'm {} years old.  . format(name, age) Hi, my name is Bob. I'm 25 years old.  인덱스 및 키워드를 사용한 포맷팅: 다음과 같이 인덱스를 사용하여 순서를 지정해 줄 수도 있습니다. 123&gt;&gt;&gt; greeting =  Hi, my name is {0}. I'm {1} years old.  &gt;&gt;&gt; greeting. format('Bob', 25) Hi, my name is Bob. I'm 25 years old.  혹은 다음과 같이 키워드를 사용하여 포맷팅을 할 수도 있습니다. 이 경우에는 매개변수의 순서가 상관이 없어집니다. 123&gt;&gt;&gt; greeting =  Hi, my name is {name}. I'm {age} years old.  &gt;&gt;&gt; greeting. format(name='Bob', age=25) Hi, my name is Bob. I'm 25 years old.  장단점: str. format() 메소드는 % operator보다는 가독성이 좋아졌지만, 여러 매개변수와 긴 문자열을 처리할 때는 역시나 가독성이 떨어진다는 단점이 있습니다. 때문에 python3. 6 이상이라면 아래에서 설명할 f-string 사용이 권장됩니다. 하지만 낮은 버전의 python3와의 하위 호환이 필요한 경우, str. format() 메소드를 사용하는 것이 좋습니다. f-string (문자열 리터럴)f-string은 python3. 6부터 도입된 가장 현대적인 포맷팅 방법으로, 표현식의 삽입이 가능하다는 장점이 있습니다. 가독성이 매우 뛰어나며, 속도도 빠르기 때문에 하위 버전 호환이 필요한 경우가 아니라면 f-string 사용이 권장됩니다. f-string을 사용하려면 문자열 앞에 f 혹은 F를 붙이고, 중괄호({}) 안에 매개변수를 입력해주면 됩니다. 사용 예시는 다음과 같습니다. 1234&gt;&gt;&gt; name =  Bob &gt;&gt;&gt; age = 25&gt;&gt;&gt; greeting = f Hi, my name is {name}. I'm {age} years old.   Hi, my name is Bob. I'm 25 years old.  다양한 f-string 사용 방법: f-string을 사용하면 다음과 같이 표현식을 사용하여 문자열을 포맷팅 할 수도 있습니다. 1234&gt;&gt;&gt; a = 5&gt;&gt;&gt; b = 10&gt;&gt;&gt; f {a} plus {b} is {a + b} '5 plus 10 is 15'f-string은 여러 줄에 걸쳐서 사용할 수도 있습니다. 다중 라인 포맷팅을 위해 삼중 따옴표(''' 혹은    )를 사용합니다. 12345678&gt;&gt;&gt; name =  Alice &gt;&gt;&gt; age = 30&gt;&gt;&gt; address =  Seoul &gt;&gt;&gt; f   Name = {name}Age = {age}Address = {address}   장단점: f-string은 간결하고 강력한 문자열 포맷팅 방법입니다. 변수, 표현식, 함수 호출 등 다양한 요소를 삽입하여 손쉽게 문자열 포맷팅을 할 수 있습니다. f-string을 사용하면 코드의 가독성이 높아질 뿐만 아니라, 문자열 처리 속도 또한 향상됩니다. 하지만 파이썬 3. 6 이상에서만 사용할 수 있기 때문에 하위 버전과의 호환이 필요한 경우 사용이 제한된다는 단점이 있습니다. 또, 외부 입력값을 f-string에 직접 사용할 때는 악의적인 코드가 실행될 수 있기 때문에 주의가 필요합니다. 문자열 포맷팅 옵션정렬: 간단한 옵션 사용을 통해 문자열을 왼쪽, 오른쪽, 가운데 정렬하여 표시되도록 할 수 있습니다. 왼쪽 정렬은 {:&lt;}, 오른쪽 정렬은 {:&gt;}, 가운데 정렬은 {:^}를 사용합니다. 뒤에 따라오는 숫자는 몇 칸을 사용할 것인지를 의미하며, 문자열의 길이가 해당 숫자보다 긴 경우에는 정렬이 적용되지 않습니다. 사용 예시는 다음과 같습니다. 1234567&gt;&gt;&gt; text =  align &gt;&gt;&gt; f {text:&lt;10} 'align   '&gt;&gt;&gt; f {text:&gt;10} '   align'&gt;&gt;&gt; f {text:^10} ' align  '참고로, 정렬은 남는 공간이 공백으로 채워지는 것으로, 공백이 아닌 다른 문자로 채우고 싶다면 &lt;, &gt;, ^ 기호 앞에 원하는 특정 문자를 입력하면 됩니다. 123&gt;&gt;&gt; text =  align &gt;&gt;&gt; f {text:. ^10} '. . align. . . '숫자 포맷팅: 숫자에 대해서도 마찬가지로 간단한 옵션 사용을 통해 소수점 이하 자리수를 지정하거나({:. nf}), 천 단위 구분 기호를 추가하는 등({:,. nf})의 동작을 할 수 있습니다. 사용 예시는 다음과 같습니다. 12345&gt;&gt;&gt; number = 1234. 56789&gt;&gt;&gt; f {number:. 2f} '1234. 57'&gt;&gt;&gt; f {number:,. 2f} '1,234. 57'여기까지 파이썬에서 제공하는 문자열 포맷팅 방법에 대하여 알아보았습니다. 문자열 포맷팅 방법은 기본적으로 f-string의 사용을 권장하지만, 상황에 맞게 최적의 포맷팅 방법을 선택하여 사용하는 것이 필요합니다. 때문에 각 방식의 특징을 이해할 필요가 있습니다. 적절한 방법을 사용하는 것이 코드의 가독성을 높이고, 데이터를 더 효과적으로 표현할 수 있을 것입니다. "
    }, {
    "id": 14,
    "url": "http://localhost:4000/python-tutorial/",
    "title": "Python Tutorial - 5분만에 훑어보기",
    "body": "2024/07/15 - 파이썬(Python)은 간결함과 직관성 덕분에 프로그래밍 입문자 뿐만 아니라 숙련된 개발자들 사이에서도 널리 사용되고 있는 프로그래밍 언어입니다. 이번 포스팅에서는 파이썬의 기초를 간략하게 다루어 짧은 시간 안에 훑어볼 수 있도록 작성하겠습니다. 파이썬의 기본 문법과 데이터 타입, 변수, 제어문 등을 빠르게 살펴보실 수 있습니다. 파이썬 설치하기파이썬을 시작하려면 우선 공식 웹사이트에서 최신 버전을 다운로드하고 설치하셔야 합니다. 설치는 installer를 사용하여 간단하게 진행되며, 설치가 완료되면 명령 프롬프트나 터미널 등에서 python --version 명령어를 통해 설치된 파이썬의 버전을 확인하실 수 있습니다. 12$ python --versionPython 3. 12. 4만약 command not found: python 명령어가 표시된다면, python3 --version 명령어를 사용하면 됩니다. 파이썬 기본 문법파이썬은 간결한 문법을 자랑합니다. 다른 언어와 달리 중괄호({})를 사용하지 않고, 대신 들여쓰기를 사용하여 코드 블록을 구분합니다. 들여쓰기가 잘못 되면 잘못된 코드가 실행될 수 있지만, 가독성이 높아지는 효과가 있습니다. 주석: 코드를 작성함에 있어 코드를 설명하는 주석은 코드의 가독성을 높이는 데 중요한 역할을 하기 때문에 필수적인 요소입니다. 파이썬에서는 한 줄과 여러 줄 주석을 다른 방법으로 작성할 수 있습니다. 123456# 한 줄 주석은 샵(#)으로 시작합니다.    이 부분은 여러 줄 주석입니다. 여러 줄에 걸쳐 작성할 수 있습니다.    문자열: 파이썬에서 문자열은 큰따옴표( )나 작은따옴표(')로 감싸서 선언합니다. 만약 문자열 안에 큰따옴표가 있다면, 작은따옴표로 감싸 문자열을 생성하면 큰따옴표까지 문자열에 포함시킬 수 있습니다. 반대도 마찬가지로, 상황에 맞게 큰따옴표와 작은따옴표를 사용하면 됩니다. 1234&gt;&gt;&gt; print( Hello, world! )Hello, world!&gt;&gt;&gt; print(' Hi, My name is Chloe.  ') Hi, My name is Chloe.  변수와 데이터 타입변수란 값을 저장하는 공간으로, 파이썬에서는 값이 할당되면 자동으로 데이터 타입이 지정됩니다. 기본 데이터 타입: 기본 데이터 타입으로는, 정수(Integer, int), 실수(Floating point, float), 문자열(String, str), 불린(Boolean, bool)이 있습니다. 참고로, 불린 값은 대문자(True, False)로 시작해야 한다는 것에 주의해야 합니다. 12345678910111213&gt;&gt;&gt; a = 10&gt;&gt;&gt; b = 3. 14&gt;&gt;&gt; c =  Python &gt;&gt;&gt; d = True&gt;&gt;&gt; print(type(a))&lt;class 'int'&gt;&gt;&gt;&gt; print(type(b))&lt;class 'float'&gt;&gt;&gt;&gt; print(type(c))&lt;class 'str'&gt;&gt;&gt;&gt; print(type(d))&lt;class 'bool'&gt;리스트와 튜플: 리스트와 튜플은 여러 개의 값을 저장할 수 있는 데이터 타입입니다. 리스트는 대괄호([])를 사용하며, 값의 변경이 가능합니다. 반면에 튜플은 소괄호(())를 사용하며, 값의 변경이 허용되지 않는다는 차이점이 있습니다. 12345678910# listfruits = [ apple ,  banana ,  cherry ]print(fruits[0])fruits[1] =  blueberry print(fruits)# tuplecolors = ( red ,  green ,  blue )print(colors[1])colors[1] =  yellow  # 에러 발생 (값 변경 불가)딕셔너리: 딕셔너리는 키-값(key-value) 쌍으로 이루어진 데이터 타입입니다. 중괄호({})를 사용하여 정의하며, 키를 통해 값에 접근할 수 있습니다. 123456789student = {   name :  John ,   age : 21,   major :  Computer Science }print(student[ name ])student[ age ] = 22print(student)연산자파이썬은 다양한 연산자를 지원합니다. 기본적인 산술 연산자와 비교 연산자, 논리 연산자 등을 통해 연산을 수행할 수 있습니다. 산술 연산자: 1234567891011121314&gt;&gt;&gt; x = 10&gt;&gt;&gt; y = 3&gt;&gt;&gt; print(x + y)13&gt;&gt;&gt; print(x - y)7&gt;&gt;&gt; print(x * y)30&gt;&gt;&gt; print(x / y)3. 33333. . . &gt;&gt;&gt; print(x % y)1&gt;&gt;&gt; print(x ** y)1000비교 연산자: 1234567891011121314&gt;&gt;&gt; x = 10&gt;&gt;&gt; y = 3&gt;&gt;&gt; print(x == y)False&gt;&gt;&gt; print(x != y)True&gt;&gt;&gt; print(x &gt; y)True&gt;&gt;&gt; print(x &lt; y)False&gt;&gt;&gt; print(x &gt;= y)True&gt;&gt;&gt; print(x &lt;= y)False논리 연산자: 12345678&gt;&gt;&gt; a = True&gt;&gt;&gt; b = False&gt;&gt;&gt; print(a anad b)False&gt;&gt;&gt; print(a or b)True&gt;&gt;&gt; print(not a)False제어문제어문을 통해 코드의 분기를 만들고, 동일한 작업을 반복시킬 수 있습니다. 파이썬에서는 다른 언어들과 마찬가지로 조건문과 반복문을 제공합니다. 조건문: 파이썬의 조건문은 if, elif, else 키워드를 사용하여 조건에 따라 실행할 코드를 결정할 수 있습니다. 1234567age = 18if age &gt;= 20 :  print( Adult )elif age &gt;= 13 :  print( Teenager )else :  print( Child )반복문: 파이썬의 반복문은 for 혹은 while 키워드를 사용하여 특정 코드를 반복 실행하도록 할 수 있습니다. 아래 두 코드는 동일한 결과를 출력합니다. 123456789# for 문for i in range(5) :  print(i)# while 문count = 0while count &lt; 5 :  print(count)  count += 1함수함수는 코드의 재사용성을 높이고, 코드를 구조화하는 데 유용합니다. 파이썬에서는 def 키워드를 사용하여 함수를 정의할 수 있습니다. 12345def add(a, b) :  return a + bresult = add(3, 5)print(result)파이썬은 배우기 쉽고 강력한 기능을 제공하는 프로그래밍 언어로, 다양한 분야에서 활용되고 있습니다. 이번 포스팅에서는 파이썬의 기본 문법, 변수와 데이터 타입, 연산자, 제어문, 함수 등에 대하여 소개하였습니다. 이후 포스팅에서 파이썬에 대하여 보다 자세하게 설명하도록 하겠습니다. "
    }, {
    "id": 15,
    "url": "http://localhost:4000/jekyll-search/",
    "title": "Jekyll Blog(Github Pages) 검색 엔진에 노출시키기 (Google Search Console)",
    "body": "2024/07/03 - 블로그를 만들었다면 다른 사람들이 내 블로그를 검색해서 유입되길 기대할 겁니다. 하지만 Github Pages와 Jekyll로 만든 블로그의 경우 검색 엔진에 자동으로 노출되지 않기 때문에 직접 사이트맵을 등록하여 데이터가 수집되도록 해야 합니다. Google Search Console, Naver Search Advisor 등을 사용하여 각 검색 엔진마다 등록해 줄 수 있습니다. 이번 포스팅에서는 구글 검색 엔진에 등록하는 방법에 대해서 소개하도록 하겠습니다. Google Search Console구글에서는 구글 서치 콘솔(Google Search Console)을 통해 사이트맵을 등록하고, 검색을 통해 노출된 양과 유입된 내용을 확인할 수 있습니다. 참고로 구글 서치봇이 정보를 수집하는 데에 길게는 한 달까지도 소요될 수 있으며, 수집이 완료되었다고 해서 검색 상단에 노출되는 것이 보장되지는 않습니다. 시작하기: 우선 구글 서치 콘솔(Google Search Console) 사이트에 접속합니다. 여기서 URL 접두어 항목에 github pages blog url을 입력하고 계속을 클릭합니다. 만약 도메인을 따로 구매한 경우라면, 왼쪽에 위치한 도메인 항목에 입력하면 됩니다.  소유권 확인하기: 다음으로 소유권 확인 과정이 필요합니다. 여기서 선택할 수 있는 방법들이 몇 가지 있는데, 사용 중인 테마에 따라서 특정 방법을 사용해야 한다던가 하는 제약이 있을 수는 있습니다. 참고로, 이전 포스팅을 통해 Google Analytics를 설정한 상태라면 보다 편리하게 소유권을 확인할 수도 있습니다.  HTML 파일 업로드: 첫 번째로 권장되는 방법은 HTML 파일을 직접 업로드하는 것입니다. 올려져 있는 . html 파일을 다운 받아 가장 상위 폴더에 해당 파일을 위치시키면 됩니다. 특정 URL에 파일을 업로드할 수 없는 경우에는 사용할 수 없지만, github pages로 만든 블로그에는 적용이 가능합니다.  HTML 태그 추가: 두 번째 방법은 HTML 메타 태그를 추가하는 것입니다. jekyll에서는 header 부분을 세팅할 수 있기 때문에 적용이 가능합니다. 다만, header를 수정할 수 없는 경우에는 사용할 수 없다는 단점이 있습니다.  Google 애널리틱스 계정 사용: 또 다른 방법으로, Google Analytics 연결하기를 마친 경우라면, 별다른 코드의 수정이나 파일 업로드 없이 소유권 확인이 가능합니다. 보다 간편한 방법이기도 하고, Google Analytics를 사용하는 경우라면 해당 방법을 추천드립니다.  설정을 마친 후, 확인 버튼을 클릭하면, 정상적으로 소유권 확인이 되었다면 다음과 같은 화면이 표시됩니다.  sitemap 제출하기: 이제 sitemap을 제출하여 서치봇이 블로그의 글들을 크롤링할 수 있도록 해 줍니다. sitemap을 만드는 방법에 대해서는 다음 포스팅에서 따로 정리하도록 하고, 여기서는 이미 생성되어 있는 sitemap을 제출하는 과정에 대해서만 설명하겠습니다. 참고로, https://chloeeekim. github. io/sitemap. xml과 같이 블로그 주소 뒤에 sitemap. xml을 붙여 sitemap 파일이 존재하는지 확인할 수 있습니다. 특정 테마들의 경우 이미 sitemap이 생성되어 있을 것입니다. 왼쪽 메뉴 탭에서 색인 &gt; Sitemaps 메뉴로 이동합니다. 그런 다음, URL에 sitemap. xml을 입력하고 제출합니다.  시간이 지나면 자동으로 구글 서치봇이 sitemap에 있는 페이지들을 크롤링하여 색인을 생성하게 됩니다. 이 시간은 경우에 따라 시간이 오래 걸릴 수 있기 때문에 빠른 색인 생성을 위해 추가적인 작업을 해 주면 좋습니다. URL 검사를 통한 색인 생성 요청: 왼쪽 메뉴 탭에서 URL 검사를 클릭하거나, 상단에 위치한 서치 바에서 원하는 url을 입력하여 검사를 시도합니다. https://chloeeekim. github. io/jekyll-search/와 같이 특정 포스팅을 검사해줍시다. 다음과 같이 표시되면 해당 페이지는 아직 색인이 생성되지 않은 상태인 것을 알 수 있습니다.  여기서 색인 생성 요청을 통해 해당 페이지의 색인 생성을 요청할 수 있습니다. 클릭하면 색인을 생성할 수 있는지를 테스트하면서 약 1~2분의 시간이 지난 후 색인 생성이 요청됩니다.  구글의 경우 색인 생성이 완료되기까지 그렇게 오랜 시간이 소요되지는 않았습니다. 제 경험상 24시간 이내로 색인 생성이 완료되었습니다. 하지만 상황에 따라 시간이 더 많이 걸리거나 적게 걸릴 수 있다는 점 참고 부탁드립니다. 색인이 생성된 url을 검사하면 다음과 같이 표시되어 상세한 정보를 확인할 수 있습니다.  이렇게 구글 서치 콘솔을 이용하여 구글에 블로그 포스팅이 검색되도록 해보았습니다. 검색 엔진에 노출시키는 과정은 시간이 오래 걸리기 때문에 최대한 빠르게 등록해주시는 게 좋습니다. 참고로 저의 경우에는 sitemap을 통해 색인 생성이 완료되는 데까지 1주일 이내의 시간이 소요되었습니다. "
    }, {
    "id": 16,
    "url": "http://localhost:4000/jekyll-google-analytics/",
    "title": "Jekyll Blog(Github Pages)에 Google Anayltics 연결하기",
    "body": "2024/06/29 - Github Pages와 Jekyll로 생성한 블로그의 경우, 트래픽 분석 등을 따로 제공하지 않기 때문에 누가 어떤 방식으로 내 블로그에 유입되었는지 알기 힘들다는 한계점이 있습니다. 이를 보완하기 위하여 Google Analytics를 통해 누가, 얼마나, 어떤 방식으로, 어느 지역에서 유입되는지를 확인할 수 있습니다. 참고로, 2024년 현재 구글 애널리틱스(Google Analytics, GA)는 GA4 버전만 생성 가능합니다. 이전 버전인 유니버셜 애널리틱스(Universal Analytics, UA)는 추후 지원이 되지 않을 수 있습니다. GA 계정 만들기우선 GA를 적용하기 위해 GA 계정부터 생성해야 합니다. Google Analytics에 접속하여 계정부터 설정해줍니다. 첫 번째로 계정 ID를 등록합니다. 여러 개의 ID를 생성할 수도 있습니다.  두 번째로 GA를 통해 관리할 url을 속성에 넣어줍니다. 저는 제 github. io 주소를 입력하였습니다. 또, 시간대와 통화 등을 대한민국으로 설정을 바꿔주면 되는데, 추후에 변경할 수도 있으니 넘어가셔도 좋습니다.  이후에 비즈니스 세부정보, 목표 등을 적당히 설정해주고, 데이터 수집과 관련한 사항에 동의해줍니다. 마지막으로 데이터 소스 플랫폼을 웹으로 선택해줍니다.  데이터 스트림 설정에서는 관리할 사이트의 url을 입력하고, 우측 상단의 만들고 계속하기를 클릭합니다.  이제 측정 ID가 부여됩니다. 이 ID가 G-XXXXXXXX 형식인 것이 GA4 버전입니다. UA 버전의 경우 UA-XXXXXXXX-X와 같은 형식으로 나타납니다.  여기서 태그 사용을 선택하고 다음으로 넘어가면, 아래와 같은 화면이 표시됩니다. 아직 태그를 설정해주지 않았기 때문에 데이터 수집이 활성화되어 있지 않은 상태입니다. 이제 블로그에 GA를 연결할 준비가 완료되었습니다. 참고로 아래 내용은 설정 &gt; 데이터 수집 및 수정 &gt; 데이터 스트림에서도 확인할 수 있습니다.  Jekyll 블로그에 GA 연결하기블로그의 설정 등에 따라 방법이 여러 가지로 나뉠 수 있습니다. 저처럼 특정 테마를 사용하여 블로그를 세팅한 경우에는 블로그에서 지원하는 버전이 UA일 수 있습니다. 사용하고 있는 테마의 document나 _config. yml 파일을 살펴봅니다. 예시가 GA4 버전인 경우: 여기서 G-XXXXXXXX 형식의 태그가 예시로 되어 있다면 별다른 변경 없이 발급받은 측정 ID를 _config. yml에 다음과 같이 추가해주기만 하면 됩니다. 1google_analytics:  G-XXXXXXXX 예시가 UA 버전인 경우: 하지만 UA-XXXXXXXX-X와 같은 형식의 태그가 예시로 되어 있다면, 유니버셜 애널리틱스를 기준으로 테마가 만들어져 있는 상태입니다. 따라서 GA4 태그를 사용하기 위해서는 수정이 불가피합니다. 우선 설정 &gt; 데이터 수집 및 수정 &gt; 데이터 스트림 &gt; 태그 안내 보기로 들어갑니다. 상단의 탭에서 직접 설치를 클릭하면 다음과 같이 gtag 코드가 나옵니다.  123456789&lt;!-- Google tag (gtag. js) --&gt;&lt;script async src= https://www. googletagmanager. com/gtag/js?id=G-XXXXXXXXXX &gt;&lt;/script&gt;&lt;script&gt; window. dataLayer = window. dataLayer || []; function gtag(){dataLayer. push(arguments);} gtag('js', new Date()); gtag('config', 'G-XXXXXXXXXX');&lt;/script&gt;설명에도 나와있듯, 해당 코드를 &lt;head&gt; 요소 안에 붙여 넣으면 됩니다. 여기서도 테마마다 설정하는 방법이 달라집니다. _includes 폴더에 analytics. html이 있는 경우에는 해당 파일을 수정하면 되는데, 없는 경우에는 &lt;head&gt; 요소를 붙이는 파일을 찾아야 합니다. 저는 _layouts 폴더에 있는 default. html 파일을 수정하였습니다. GA 연결 확인하기수정된 코드를 github에 올리고, 빌드가 완료될 때까지 몇 분 정도 기다려줍니다. 빠르게 확인할 수 있는 방법으로 개발자 도구 &gt; Console에 gtag를 입력해 볼 수 있습니다. 제대로 연결되지 않았다면 Uncaught ReferenceError가 발생하고, 제대로 연결된 경우 다음과 같이 gtag를 확인할 수 있습니다.  Google Analytics에서는 보고서 &gt; 실시간 탭에서 사용자가 확인되면 GA 연결은 성공적으로 끝납니다.  "
    }, {
    "id": 17,
    "url": "http://localhost:4000/jekyll-setup-windows/",
    "title": "Github pages와 Jekyll 설치하기 - Windows ver.",
    "body": "2024/06/26 - jekyll은 github pages를 지원하는 정적 웹사이트 생성기입니다. 저장되어 있는 html, markdown 파일을 그대로 가져와서 선택한 레이아웃에 따라 html 코드로 변환해 정적 웹사이트를 생성해줍니다. jekyll은 매우 가벼우며, liquid 언어를 지원하여 동적 컨텐츠 로드가 가능하다는 장점이 있습니다. 또한 markdown 언어를 사용하기 때문에 문법이 쉽고, 작성이 간편하다는 것도 장점입니다. 사실 windows는 jekyll이 공식적으로 지원되는 플랫폼은 아닙니다. 하지만 실행이 불가능한 것은 아니기 때문에 약간의 수정을 통해 실행시킬 수 있습니다. Github Pages 생성하기github 계정이 있다는 전제하에, 새 repository를 생성하는 것으로 시작합니다. github pages를 사용하기 위해서는 특정한 repository의 이름을 설정해야 하는데, githubId. github. io와 같은 형식으로 설정해줘야 합니다. github id가 아닌 다른 repository 이름을 설정하는 경우, 추가적인 세팅이 필요해지기 때문에 되도록이면 id를 사용합니다.  저의 경우에는 이미 chloeeekim. github. io repository가 있다고 표시됩니다. repository의 세팅은 변경할 내용 없이 생성해도 괜찮습니다. repository가 만들어지면 github pages도 생성이 완료된 것입니다. github pages가 잘 동작하는지 알고 싶다면, repository에 index. html이라는 이름으로 원하는 내용을 입력하고 commit 해줍니다. 약간의 시간이 지나고 나서 githubId. github. io에 접속하면, 입력한 내용이 표시되는 것을 확인할 수 있습니다. 이제 github pages를 사용할 준비는 끝났습니다. Ruby 및 Jekyll 설치하기jekyll을 사용하기 위해서는 먼저 ruby를 설치해야 합니다. ruby를 설치하는 방법은 다양하지만, windows에서는 ruby installer를 이용하면 간단하게 설치할 수 있습니다. ruby installer download 페이지에 가서 ruby installer를 다운받아 주면 됩니다.  사이트 좌측 상단을 보면 WITH DEVKIT 항목이 있는데, 꼭 Ruby+Devkit 버전을 다운받아야 합니다. 설치는 간단하게 진행되며, optional한 부분은 건드릴 필요 없이 기본 옵션으로 설치하면 됩니다. ruby installer는 windows를 기반으로 ruby 언어와 실행 환경 등을 포함하고 있습니다. 참고로 ruby installer 2. 4 버전 이전의 경우에는 devkit을 따로 설치해야 합니다. ruby installer 설치가 완료되었다면, ruby command prompt를 실행해줍니다.  12% ruby --versionruby 3. 1. 2p20 (2022-04-12 revision 4491bb740a) [x64-mingw-ucrt]ruby --version 명령어로 루비 정보가 표시된다면 정상적으로 설치가 완료된 것입니다. 그런 다음, jekyll과 bundler를 설치해 줍니다. 1gem install jekyll bundler설치가 완료되면, 다음 명령어로 jekyll이 잘 설치되었는지도 확인할 수 있습니다. 12% jekyll -vjekyll 4. 3. 3Jekyll Theme 적용기존에 존재하는 테마를 사용하지 않을 수도 있지만, jekyll의 또 다른 장점 중 하나가 무료로 제공되는 다양한 테마가 굉장히 많다는 것입니다. 다음 사이트들에서 어마어마한 테마들을 구경하고 선택할 수 있습니다.  https://jekyllthemes. org https://jekyllthemes. io/free http://themes. jekyllrc. org위 사이트에서 마음에 드는 테마를 찾아 사용하거나 혹은 github에서 jekyll-theme 등으로 검색하여 찾을 수도 있습니다. 우선 테마를 사용하여 설정을 마친 다음에는 원하는 대로 커스터마이징을 할 수 있기도 하고, 언제든 테마를 바꿀 수도 있으니 마음 편하게 테마를 고르시면 됩니다. 저는 mediumish라는 테마를 선택하였습니다. 꼭 같은 테마가 아니어도 상관 없으니, 원하시는 테마를 선택합니다. 테마를 골랐다면, 해당 테마의 github 페이지로 이동하여 code를 다운받아 줍니다. clone을 해도 상관없고, . zip 파일로 받아도 됩니다. 다운받은 파일들을 위에서 생성한 github pages repository에 옮겨줍니다. ruby command prompt에서 내 repository가 가져와진 경로로 이동하여 아래 명령어들을 순서대로 실행해줍니다. 12bundle installbundle update문제 없이 설치가 끝났다면, 로컬 서버를 실행할 시간입니다. 로컬 서버 실행아래 명령어 중 하나로 jekyll server를 로컬에서 실행할 수 있습니다. 12bundler exec jekyll servejekyll serve실행시키면 Server address: http://127. 0. 0. 1:4000/와 같이 로컬 서버 주소가 표시됩니다. 참고로 --serve 옵션을 통해 변경사항을 자동으로 감지하도록 할 수도 있습니다. 이후에는 로컬 서버에 접속하여 실제로 실행시켜 볼 수 있습니다. 각종 에러에 대처하기jekyll을 설치하고 실행할 수 있다고는 하지만, windows는 공식적으로 지원되는 플랫폼이 아니기 때문에 에러가 발생하는 경우가 있습니다. 아래에서 몇 가지 에러에 대처하는 방법을 설명하겠습니다. Liquid Exception: Incompatible character encoding: UTF-8 인코딩을 사용하는 경우 발생할 수 있는 에러입니다. 예를 들어, windows 계정명이 한글인 경우가 있을 수 있습니다. C:\User\계정명처럼 한글이 포함된 경로 때문에 에러가 발생할 수 있습니다. 이 경우 다음 명령어를 통해 UTF-8 인코딩 옵션을 켜주면 해결이 가능합니다. 1chcp 65001cannot load such file -- webrick (LoadError): webrick을 찾을 수 없어서 발생하는 에러입니다. 따라서 webrick을 추가해주면 해결이 가능합니다. 1bundle add webrickAn error occurred while installing wdm (0. 1. 1), and Bundler cannot continue. : wdm 설치에 실패하여 발생하는 에러입니다. windows에서 --watch 옵션을 사용하기 위해서는 wdm을 설치해야 하는데, 만약 --watch 옵션을 사용하지 않을 것이라면 Gemfile에서 아래 코드를 주석 처리하여 줍니다. 1gem  wdm ,  ~&gt; 0. 1. 1 , :platforms =&gt; [:mingw, :x64_mingw, :mswin]--watch 옵션을 사용하고 싶은 경우에는 현재 ruby의 버전을 특정 버전으로 낮추는 방법 밖에는 없습니다. 우선 설치되어 있는 ruby를 완전히 삭제하고, C:\ 드라이브에 있는 Ruby 관련 폴더도 삭제해줍니다. 이후 ruby 3. 1. 2-1 버전을 다운받아 설치한 후, bundle install부터 다시 실행시켜 주면 해결이 가능합니다. "
    }, {
    "id": 18,
    "url": "http://localhost:4000/two-sum-ii-input-array-is-sorted/",
    "title": "[Leetcode] 167. Two Sum II - Input Array is Sorted",
    "body": "2019/10/23 - 주어진 정수 배열에서 두 값의 합이 찾고자 하는 값(target)일 경우, 두 인덱스를 반환하는 문제  주어진 정수 배열은 이미 증가하는 방향으로 정렬되어 있다.  인덱스는 non zero-based로 리턴해야 한다. (1부터 시작) 정확히 하나의 솔루션이 존재한다.  동일한 값은 두 번 사용할 수 없다. Example 1:  Input : numbers = [2,7,11,15], target = 9 Output : [1,2]Example 2:  Input : numbers = [2,3,4], target = 6 Output : [1,3]Example 3:  Input : numbers = [-1,0], target = -1 Output : [1,2]Note: dict 사용 (key : 확인한 정수값 / value : 인덱스) 12345678class Solution:  def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:    temp = {}    for i, num in enumerate(numbers) :      if target - num in temp :        return [temp[target - num] + 1, i + 1]      else :        temp[num] = i"
    }, {
    "id": 19,
    "url": "http://localhost:4000/excel-sheet-column-title/",
    "title": "[Leetcode] 168. Excel Sheet Column Title",
    "body": "2019/10/23 - 양의 정수가 하나 주어졌을 때, 이를 엑셀 시트에서 보이는 것과 같은 column title로 변경하는 문제  A -&gt; 1, B -&gt; 2, … , Z -&gt; 26, AA -&gt; 27, AB -&gt; 28 … 과 같은 순서로 진행된다. Example 1:  Input : columnNumber = 1 Output : “A”Example 2:  Input : columnNumber = 28 Output : “AB”Example 3:  Input : columnNumber = 701 Output : “ZY”Note:  26진법을 계산하듯이 역으로 계산 (26으로 나눈 나머지가 해당 자리의 값) ord(ch) : 문자를 아스키 코드로 변환 chr(num) : 아스키 코드를 문자로 변환 a //= b : a를 b로 나눈 몫을 a에 대입한다. (a /= b와 다름)123456789class Solution:  def convertToTitle(self, n: int) -&gt; str:    res =       while n :      n -= 1      mod = n % 26      res = chr(mod + ord('A')) + res      n //= 26    return res"
    }, {
    "id": 20,
    "url": "http://localhost:4000/excel-sheet-column-number/",
    "title": "[Leetcode] 171. Excel Sheet Column Number",
    "body": "2019/10/23 - 엑셀 시트에 나타나는 것과 동일한 column title이 주어졌을 때, 이를 숫자로 변경하는 문제  A -&gt; 1, B -&gt; 2, … , Z -&gt; 26, AA -&gt; 27, AB -&gt; 28 … 과 같은 순서로 진행된다. Example 1:  Input : columnTitle = “A” Output : 1Example 2:  Input : columnTitle = “AB” Output : 28Example 3:  Input : columnTitle = “ZY” Output : 701Note:  26진법을 계산하듯이 계산 ord(ch) : 문자를 아스키 코드로 변환 chr(num) : 아스키 코드를 문자로 변환1234567class Solution:  def titleToNumber(self, s: str) -&gt; int:    res = 0    for ch in s :      res *= 26      res += (ord(ch) - ord('A') + 1)    return res"
    }, {
    "id": 21,
    "url": "http://localhost:4000/binary-tree-preorder-traversal/",
    "title": "[Leetcode] 144. Binary Tree Preorder Traversal",
    "body": "2019/10/22 - binary tree가 하나 주어졌을 때, 해당 트리의 preorder traversal의 결과를 구하는 문제 Example 1:  Input : root = [1,null,2,3] Output : [1,2,3]Example 2:  Input : root = [] Output : []Example 3:  Input : root = [1] Output : [1]Note:  preorder() 함수를 만들어 Recursive하게 해결 (참고) inorder traversal (참고) postorder traversal123456789101112131415161718# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def preorderTraversal(self, root: TreeNode) -&gt; List[int]:    res = []    def preorder(self, node: TreeNode) -&gt; None:      if not node :        return            res. append(node. val)      preorder(self, node. left)      preorder(self, node. right)    preorder(self, root)    return res"
    }, {
    "id": 22,
    "url": "http://localhost:4000/binary-tree-postorder-traversal/",
    "title": "[Leetcode] 145. Binary Tree Postorder Traversal",
    "body": "2019/10/22 - binary tree가 하나 주어졌을 때, 해당 트리의 postorder traversal의 결과를 구하는 문제 Example 1:  Input : root = [1,null,2,3] Output : [3,2,1]Example 2:  Input : root = [] Output : []Example 3:  Input : root = [1] Output : [1]Note:  postorder() 함수를 만들어 Recursive하게 해결 (참고) inorder traversal (참고) preorder traversal123456789101112131415161718# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def postorderTraversal(self, root: TreeNode) -&gt; List[int]:    res = []    def postorder(self, node: TreeNode) -&gt; None:      if not node :        return           postorder(self, node. left)      postorder(self, node. right)      res. append(node. val)    postorder(self, root)    return res"
    }, {
    "id": 23,
    "url": "http://localhost:4000/binary-tree-inorder-traversal/",
    "title": "[Leetcode] 94. Binary Tree Inorder Traversal",
    "body": "2019/10/22 - binary tree가 하나 주어졌을 때, 해당 트리의 inorder traversal의 결과를 구하는 문제 Example 1:  Input : root = [1,null,2,3] Output : [1,3,2]Example 2:  Input : root = [] Output : []Example 3:  Input : root = [1] Output : [1]Note:  inorder() 함수를 만들어 Recursive하게 해결 (참고) preorder traversal (참고) postorder traversal123456789101112131415161718# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def inorderTraversal(self, root: TreeNode) -&gt; List[int]:    res = []    def inorder(self, node: TreeNode) -&gt; None:      if not node :        return      inorder(self, node. left)      res. append(node. val)      inorder(self, node. right)    inorder(self, root)    return res"
    }, {
    "id": 24,
    "url": "http://localhost:4000/same-tree/",
    "title": "[Leetcode] 100. Same Tree",
    "body": "2019/10/21 - binary tree가 두 개 주어졌을 때, 두 트리가 동일한 트리인지 확인하는 문제  동일한 트리의 조건 : 구조가 동일하고, 각 노드의 값이 동일하다. Example 1:  Input : p = [1,2,3], q = [1,2,3] Output : trueExample 2:  Input : p = [1,2], q = [1,null,2] Output : falseExample 3:  Input : p = [1,2,1], q = [1,1,2] Output : falseNote: isSameNode() 함수를 만들어서 각 노드를 비교  노드가 둘 다 None인 경우 : true(동일) 노드 중 하나만 None인 경우 : false (다름) 노드가 둘 다 None이 아니고, 값이 같은 경우 : left와 right를 비교 노드가 둘 다 None이 아니고, 값이 다른 경우 : false (다름)1234567891011121314151617181920# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool:    def isSameNode(self, p: TreeNode, q: TreeNode) -&gt; bool:      if not p and not q :        return True      elif (not p and q) or (p and not q) :        return False      else :        if p. val == q. val :          return isSameNode(self, p. left, q. left) and isSameNode(self, p. right, q. right)        else :          return False    return isSameNode(self, p, q)"
    }, {
    "id": 25,
    "url": "http://localhost:4000/minimum-path-sum/",
    "title": "[Leetcode] 64. Minimum Path Sum",
    "body": "2019/10/21 - m x n의 양수로 채워진 Grid가 주어졌을 때, 좌상단에서 우하단으로 이동하는 path의 합의 최솟값을 구하는 문제  한 번에 한 칸씩 오른쪽 혹은 아래로만 이동할 수 있다. Example 1:  Input : grid = [[1,3,1],[1,5,1],[4,2,1]] Output : 7 1 -&gt; 3 -&gt; 1 -&gt; 1 -&gt; 1Example 2:  Input : grid = [[1,2,3],[4,5,6]] Output : 12Note: 특정 칸으로 이동하는 방법의 최솟값은 위쪽 혹은 왼쪽 칸의 값 중에서 작은 값에서 이동하는 것 12345678910111213class Solution:  def minPathSum(self, grid: List[List[int]]) -&gt; int:    for i in range(len(grid)) :      for j in range(len(grid[0])) :        if i == 0 and j == 0 :          continue        if i == 0 :          grid[i][j] += grid[i][j-1]        elif j == 0 :          grid[i][j] += grid[i-1][j]        else :          grid[i][j] += min(grid[i][j-1], grid[i-1][j])    return grid[-1][-1]"
    }, {
    "id": 26,
    "url": "http://localhost:4000/maximum-subarray/",
    "title": "[Leetcode] 53. Maximum Subarray",
    "body": "2019/10/21 - 정수로 이루어진 수열에서 합이 최대가 되는 연속 부분 수열을 찾는 문제 Example 1:  Input : nums = [-2,1,-3,4,-1,2,1,-5,4] Output : 6 [4,-1,2,1] = 6Example 2:  Input : nums = [1] Output : 1Example 3:  Input : nums = [5,4,-1,7,8] Output : 23 [5,4,-1,7,8] = 23Note:  res는 전체 subarray의 합 중에서 가장 큰 값 temp는 현재의 subarray의 합 nums[i]를 더했는데 nums[i]보다 작은 경우 최대합의 부분수열이 될 수 없다. 123456789class Solution:  def maxSubArray(self, nums: List[int]) -&gt; int:    res, temp = nums[0], nums[0]    for i in range(1, len(nums)) :      temp += nums[i]      if temp &lt; nums[i] :        temp = nums[i]      res = max(res, temp)    return res"
    }, {
    "id": 27,
    "url": "http://localhost:4000/triangle/",
    "title": "[Leetcode] 120. Triangle",
    "body": "2019/10/20 - 삼각형 형태의 2차원 배열(리스트)이 주어졌을 때, top에서 bottom까지 가는 path의 최소합을 찾는 문제 Example 1:  Input : triangle = [[2],[3,4],[6,5,7],[4,1,8,3]] Output : 11 2 + 3 + 5 + 1 = 11Example 2:  Input : triangle = [[-10]] Output : -10Note:  top to bottom이지만 bottom에서 top으로 올라가는 방식으로 문제를 해결하는 것이 간단하다.  이동할 수 있는 아래의 두 칸 중에서 작은 값을 선택하여 더하는 방식으로 해결123456class Solution:  def minimumTotal(self, triangle: List[List[int]]) -&gt; int:    for i in range(len(triangle) - 2, -1, -1) :      for j in range(len(triangle[i])) :        triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])    return triangle[0][0]"
    }, {
    "id": 28,
    "url": "http://localhost:4000/path-sum/",
    "title": "[Leetcode] 112. Path Sum",
    "body": "2019/10/20 - binary tree와 정수 targetSum이 주어졌을 때, root-to-leaf path의 합이 sum과 동일한 path가 존재하는지를 찾는 문제  leaf 노드는 child가 존재하지 않는다. (left, right 모두 None)Example 1:  Input : root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output : trueExample 2:  Input : root = [1,2,3], targetSum = 5 Output : falseExample 3:  Input : root = [], targetSum = 0 Output : falseNote:  위에서부터 내려오면서 left와 right child의 val에 현재 노드의 val을 더한다.  특정 노드에서 left, right가 모두 None인 경우(leaf 노드인 경우) 값을 targetSum과 비교한다.  모든 노드를 다 확인했음에도 sum과 동일한 값이 없는 경우 false를 리턴한다.  (참고) 중간 노드의 값이 targetSum보다 커지면 아래 노드는 확인하지 않도록 구현하려 했으나, 음수 값이 포함되는 테스트 케이스가 존재하여 해당 조건은 삭제123456789101112131415161718192021222324# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool:    if not root :      return False    queue = [root]    while queue :      node = queue. pop(0)      if node. left is None and node. right is None :        if node. val == sum :          return True      if node. left is not None :        node. left. val += node. val        queue. append(node. left)      if node. right is not None :        node. right. val += node. val        queue. append(node. right)    return False"
    }, {
    "id": 29,
    "url": "http://localhost:4000/flatten-binary-tree-to-linked-list/",
    "title": "[Leetcode] 114. Flatten Binary Tree to Linked List",
    "body": "2019/10/20 - binary tree가 주어졌을 때, 이를 flatten하는 문제  우측으로 편향되도록 바꾼다.  순서는 depth-first in-place로 해결할 것Example 1:  Input : root = [1,2,5,3,4,null,6] Output : [1,null,2,null,3,null,4,null,5,null,6]Example 2:  Input : root = [] Output : []Example 3:  Input : root = [0] Output : [0]Note:  stack을 사용하여 depth-first로 노드 방문 (참고) [None, None] 같은 형태의 테스트 케이스가 존재123456789101112131415161718192021222324252627282930# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def flatten(self, root: TreeNode) -&gt; None:           Do not return anything, modify root in-place instead.            if not root :      return    stack = [root. right, root. left]    root. left = root. right = None    point = root    while stack :      node = stack. pop()      if not node :        continue      if node. right is not None :        stack. append(node. right)        node. right = None      if node. left is not None :        stack. append(node. left)        node. left = None      point. right = node      point = point. right    return"
    }, {
    "id": 30,
    "url": "http://localhost:4000/single-number-ii/",
    "title": "[Leetcode] 137. Single Number II",
    "body": "2019/10/19 - 비어 있지 않은, 숫자로 이루어진 리스트가 주어졌을 때, 해당 리스트 안에 한 번만 등장하는 원소를 찾는 문제  단 하나의 원소를 제외하고는 모두 세 번씩 등장한다. Example 1:  Input : nums = [2,2,3,2] Output : 3Example 2:  Input : nums = [0,1,0,1,0,1,99] Output : 99Note:  set : 원소의 유일성을 보장하는 자료형 원소가 모두 세 번씩 등장한다고 가정했을 때의 총합은 3 * sum(set(nums))이고, 하나의 원소만 한 번 등장하므로 뺀 값을 2로 나누어 구할 수 있다. 123class Solution:  def singleNumber(self, nums: List[int]) -&gt; int:    return int((3 * sum(set(nums)) - sum(nums)) / 2)"
    }, {
    "id": 31,
    "url": "http://localhost:4000/single-number/",
    "title": "[Leetcode] 136. Single Number",
    "body": "2019/10/18 - 비어 있지 않은, 숫자로 이루어진 리스트가 주어졌을 때, 해당 리스트 안에 한 번만 등장하는 원소를 찾는 문제  단 하나의 원소를 제외하고는 모두 두 번씩 등장한다. Example 1:  Input : nums = [2,2,1] Output : 1Example 2:  Input : nums = [4,1,2,1,2] Output : 4Example 3:  Input : nums = [1] Output : 1Note:  set : 원소의 유일성을 보장하는 자료형 원소가 모두 두 번씩 등장한다고 가정했을 때의 총합은 2 * sum(set(nums))이고, 하나의 원소만 한 번 등장하므로 차를 구하여 원소를 구할 수 있다. 123class Solution:  def singleNumber(self, nums: List[int]) -&gt; int:    return 2 * sum(set(nums)) - sum(nums)"
    }, {
    "id": 32,
    "url": "http://localhost:4000/valid-palindrome/",
    "title": "[Leetcode] 125. Valid Palindrome",
    "body": "2019/10/17 - 주어진 문자열이 Palindrome인지 확인하는 문제  Palindrome : 회문. 거꾸로 읽었을 때도 제대로 읽었을 때와 동일한 경우 문자열 내에서 alphanumeric character를 제외한 나머지 경우는 무시한다. Example 1:  Input : s = “A man, a plan, a canal: Panama” Output : trueExample 2:  Input : s = “race a car” Output : falseExample 3:  Input : s = “ “ Output : trueNote:  re. sub를 사용하여 alphanumeric이 아닌 모든 경우는 ‘‘로 치환 대소문자를 구분하지 않으므로, 전부 lowercase로 변경 reverse 문자열 구하는 법 : [::-1]1234567class Solution:  def isPalindrome(self, s: str) -&gt; bool:    s = re. sub('\W', '', s). lower()    if s[::-1] == s :      return True    else :      return False"
    }, {
    "id": 33,
    "url": "http://localhost:4000/pascals-triangle-ii/",
    "title": "[Leetcode] 119. Pascal's Triangle II",
    "body": "2019/10/16 - 양의 정수인 rowIndex가 주어졌을 때, 파스칼의 삼각형(Pascal’s Triangle)에서 rowIndex번째를 구하는 문제  파스칼의 삼각형 : 각 숫자는 위의 두 숫자의 합으로 이루어진다. Example 1:  Input : rowIndex = 3 Output : [1,3,3,1]Example 2:  Input : rowIndex = 0 Output : [1]Example 3:  Input : rowIndex = 1 Output : [1,1]Note:  메모리 O(n)만큼 사용 해당 인덱스의 값은 이전 사이클의 해당 인덱스의 값 + 앞 인덱스의 값 앞에서부터 순서대로 계산하려면 여분의 공간이 필요하므로, 뒤에서부터 계산하는 방식 선택1234567class Solution:  def getRow(self, rowIndex: int) -&gt; List[int]:    row = [1] + [0 for _ in range(rowIndex)]    for i in range(rowIndex+1) :            for j in range(i-1, -1, -1) :        row[j+1] += row[j]    return row"
    }, {
    "id": 34,
    "url": "http://localhost:4000/pascals-triangle/",
    "title": "[Leetcode] 118. Pascal's Triangle",
    "body": "2019/10/15 - 양의 정수인 numRows가 주어졌을 때, 파스칼의 삼각형(Pascal’s Triangle)을 만드는 문제  파스칼의 삼각형 : 각 숫자는 위의 두 숫자의 합으로 이루어진다. Example 1:  Input : numRows = 5 Output : [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]Example 2:  Input : numRows = 1 Output : [[1]]Note:  한 줄씩 각 row를 계산한 뒤, 결과 리스트에 append하는 방식으로 구현123456789class Solution:  def generate(self, numRows: int) -&gt; List[List[int]]:    res = []    for i in range(numRows) :      row = [1 for _ in range(i+1)]      for j in range(1, i) :        row[j] = res[i-1][j-1] + res[i-1][j]      res. append(row)    return res"
    }, {
    "id": 35,
    "url": "http://localhost:4000/unique-paths-ii/",
    "title": "[Leetcode] 63. Unique Paths II",
    "body": "2019/10/14 - m x n 사이즈의 그리드가 주어졌을 때, 해당 그리드의 왼쪽 위에서 오른쪽 아래까지 도달하는 방법의 수를 구하는 문제  한 번에 한 칸만 아래 혹은 오른쪽으로 이동할 수 있다.  m과 n은 최대 100 이하의 정수이다.  장애물이 있는 칸은 1로, 비어있는 칸은 0으로 주어진다. Example 1:  Input : obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] Output : 2Example 2:  Input : obstacleGrid = [[0,1],[0,0]] Output : 1Note:  dp를 사용하여 해결 특정 칸에 도달하기 위한 방법의 수 : 위쪽 칸에 도달하기 위한 방법의 수 + 왼쪽 칸에 도달하기 위한 방법의 수 list를 특정 값(value)로 초기화 : lst = [value for i in range(size)] 가장 위쪽과 왼쪽의 칸들은 중간에 장애물이 있는 경우 도달할 수 있는 방법이 없다. 1234567891011121314151617181920class Solution:  def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:    n, m = len(obstacleGrid), len(obstacleGrid[0])    cal = [[0 for i in range(m)] for i in range(n)]    for i in range(n) :      if obstacleGrid[i][0] == 1 :        break      cal[i][0] = 1    for j in range(m) :      if obstacleGrid[0][j] == 1 :        break      cal[0][j] = 1    for i in range(1, n) :      for j in range(1, m) :        if obstacleGrid[i][j] == 1 :          cal[i][j] = 0          continue        else :          cal[i][j] = cal[i-1][j] + cal[i][j-1]    return cal[-1][-1]"
    }, {
    "id": 36,
    "url": "http://localhost:4000/remove-duplicates-from-sorted-array-ii/",
    "title": "[Leetcode] 80. Remove Duplicates from Sorted Array II",
    "body": "2019/10/14 - 정수로 이루어진 정렬된 리스트가 주어졌을 때, 하나의 숫자는 최대 2번만 등장하도록 겹치는 숫자들을 제외한 리스트를 만드는 문제  in-place : 다른 리스트를 할당하지 말고 주어진 리스트 내에서 해결할 것 각 원소는 최대 두 번씩만 나타나야 한다.  새롭게 만들어진 리스트의 길이를 리턴 리턴한 길이의 뒷부분에는 리스트에 어떤 값이 있건 상관하지 않는다. Example 1:  Input : nums = [1,1,1,2,2,3] Output : 5, nums = [1,1,2,2,3, …]Example 2:  Input : nums = [0,0,1,1,1,1,2,3,3] Output : 7, nums = [0,0,1,1,2,3,3, …]Note:  나타나는 원소가 이전과 동일한 경우 count를 하여 2번을 초과하여 나타나는 경우에 삭제하는 방법 리스트 내에서 순서를 바꾸는 방법도 가능123456789101112131415161718class Solution:  def removeDuplicates(self, nums: List[int]) -&gt; int:    if not nums :      return 0    now = nums[0]    count, i = 1, 1    while i &lt; len(nums) :      if nums[i] == now :        if count &lt; 2 :          count += 1          i += 1        else :          del nums[i]      else :        now = nums[i]        count = 1        i += 1    return len(nums)"
    }, {
    "id": 37,
    "url": "http://localhost:4000/partition-list/",
    "title": "[Leetcode] 83. Partition List",
    "body": "2019/10/14 - Linked List와 숫자 x가 주어졌을 때, x보다 작은 노드가 x보다 크거나 같은 노드보다 앞에 위치하는 Linked List로 바꾸는 문제  기존 노드의 상대적인 순서는 유지되어야 한다. Example 1:  Input : head = [1,4,3,2,5,2], x = 3 Output : [1,2,2,4,3,5]Example 2:  Input : head = [2,1], x = 2 Output : [1,2]Note:  x보다 작은 리스트(less)와 큰 리스트(greater)로 구분한 뒤, 큰 리스트를 작은 리스트의 뒤에 붙이는 방법으로 구현123456789101112131415161718192021# Definition for singly-linked list. # class ListNode:#   def __init__(self, x):#     self. val = x#     self. next = Noneclass Solution:  def partition(self, head: ListNode, x: int) -&gt; ListNode:    less, greater = ListNode(-1), ListNode(-1)    less_now, greater_now = less, greater    node = head    while node :      if node. val &lt; x :        less_now. next = ListNode(node. val)        less_now = less_now. next      else :        greater_now. next = ListNode(node. val)        greater_now = greater_now. next      node = node. next    less_now. next = greater. next    return less. next"
    }, {
    "id": 38,
    "url": "http://localhost:4000/unique-paths/",
    "title": "[Leetcode] 62. Unique Paths",
    "body": "2019/10/13 - 두 정수 m, n이 주어졌을 때, m x n 사이즈 그리드의 왼쪽 위에서 오른쪽 아래까지 도달하는 방법의 수를 구하는 문제  한 번에 한 칸만 아래 혹은 오른쪽으로 이동할 수 있다.  m과 n은 최대 100 이하의 정수이다. Example 1:  Input : m = 3, n = 7 Output : 28Example 2:  Input : m = 3, n = 2 Output : 3Note:  dp를 사용하여 해결 특정 칸에 도달하기 위한 방법의 수 : 위쪽 칸에 도달하기 위한 방법의 수 + 왼쪽 칸에 도달하기 위한 방법의 수 list를 특정 값(value)로 초기화 : lst = [value for i in range(size)]12345678910class Solution:  def uniquePaths(self, m: int, n: int) -&gt; int:    cal = [[0 for i in range(m)] for i in range(n)]    for i in range(n) :      for j in range(m) :        if i == 0 or j == 0 :          cal[i][j] = 1        else :          cal[i][j] = cal[i-1][j] + cal[i][j-1]    return cal[-1][-1]"
    }, {
    "id": 39,
    "url": "http://localhost:4000/search-a-2d-matrix/",
    "title": "[Leetcode] 74. Search a 2D Matrix",
    "body": "2019/10/12 - m x n 사이즈의 2차원 리스트가 주어졌을 때, targeet이 존재하는지 찾는 문제  각 row에 있는 숫자들은 증가하는 순서로 정렬되어 있다.  각 row의 첫 번째 숫자는 이전 row의 마지막 숫자보다 크다. Example 1:  Input : matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 Output : trueExample 2:  Input : matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 Output : falseNote:  해당 row가 target을 포함하는 범위인지 확인한 후, 해당 row에 target이 존재하는지 확인123456789101112131415161718# Definition for singly-linked list. # class ListNode:#   def __init__(self, x):#     self. val = x#     self. next = Noneclass Solution:  def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:    for row in matrix :      if not row :        return False      if row[0] &lt;= target and row[-1] &gt;= target :        c = row. count(target)        if c == 0 :          return False        else :          return True    return False"
    }, {
    "id": 40,
    "url": "http://localhost:4000/remove-duplicates-from-sorted-list/",
    "title": "[Leetcode] 83. Remove Duplicates from Sorted List",
    "body": "2019/10/11 - 정렬된 숫자로 이루어진 Linked List가 하나 주어졌을 때, 모든 숫자가 단 한 번만 등장하도록 중복을 제거한 리스트를 만드는 문제 Example 1:  Input : head = [1, 1, 2] Output : [1, 2]Example 2:  Input : head = [1, 1, 2, 3, 3] Output : [1, 2, 3]Note: 이전과 숫자가 동일한 노드라면, 앞 노드와 뒷 노드를 연결하여 해당 노드를 리스트에서 삭제 123456789101112131415161718192021# Definition for singly-linked list. # class ListNode:#   def __init__(self, x):#     self. val = x#     self. next = Noneclass Solution:  def deleteDuplicates(self, head: ListNode) -&gt; ListNode:    if not head :      return head    before, now = head, head    appear = head. val        while before. next :      now = before. next      if now. val == appear :        before. next = now. next        now = None      else :        appear = now. val        before = now    return head"
    }, {
    "id": 41,
    "url": "http://localhost:4000/jump-game/",
    "title": "[Leetcode] 55. Jump Game",
    "body": "2019/10/11 - 양의 정수로 이루어진 리스트가 주어졌을 때, 최대 각 칸의 값만큼 점프할 수 있다고 가정하면, 마지막 인덱스에 도달할 수 있는지 확인하는 문제  e. g. , 값이 3이라면 1칸, 2칸, 3칸 다음으로 이동할 수 있다. Example 1:  Input : nums = [2, 3, 1, 1, 4] Output : true 인덱스 0에서 1칸 이동 -&gt; 인덱스 1에서 3칸 이동Example 2:  Input : nums = [3, 2, 1, 0, 4] Output : false 어떤 경우에도 무조건 인덱스 3에 도달할 수밖에 없고, 인덱스 3의 값이 0이므로 마지막 인덱스에 도달할 수 없다. Note: 단순하게 생각하여, 최대로 이동할 수 있는 길이가 리스트의 전체 길이보다 긴지 확인 12345678910class Solution:  def canJump(self, nums: List[int]) -&gt; bool:    length = len(nums)    far, i = 0, 0    while i &lt;= far :      far = max(far, i + nums[i])      if far &gt;= length - 1 :        return True      i += 1    return False"
    }, {
    "id": 42,
    "url": "http://localhost:4000/climbing-stairs/",
    "title": "[Leetcode] 70. Climbing Stairs",
    "body": "2019/10/10 - 정수 n이 주어졌을 때, n번째 계단까지 도달하는 방법의 개수를 구하는 문제  한 번에 1계단 혹은 2계단씩만 올라갈 수 있다.  n은 양의 정수로 주어진다. Example 1:  Input : n = 2 Output : 2 [1, 1], [2] 두 가지 방법이 존재한다. Example 2:  Input : n = 3 Output : 3 [1, 1, 1], [1, 2], [2, 1] 세 가지 방법이 존재한다. Note:  1계단 아래 혹은 2계단 아래에 도달하면 해당 계단에 도달할 수 있으므로, dp를 사용하여 해결123456class Solution:  def climbStairs(self, n: int) -&gt; int:    steps = [0, 1, 2]    for i in range(3, n + 1) :      steps. append(steps[i-2] + steps[i-1])    return steps[n]"
    }, {
    "id": 43,
    "url": "http://localhost:4000/plus-one/",
    "title": "[Leetcode] 66. Plus One",
    "body": "2019/10/09 - 비어 있지 않은, 숫자로 이루어진 리스트가 하나 주어졌을 때, 리스트의 값이 나타내는 정수에 1을 더한 값을 리스트로 리턴하는 문제  숫자는 음수가 아니며, 0으로 시작하지 않는다.  리스트 내의 각각의 원소들은 single digit을 나타낸다.  most significant digit가 리스트의 가장 앞에 저장된다. Example 1:  Input : digits = [1, 2, 3] Output : [1, 2, 4]Example 2:  Input : digits = [4, 3, 2, 1] Output : [4, 3, 2, 2]Example 3:  Input : digits = [9] Output : [1, 0]Note:  reversed : 리스트의 순서를 거꾸로 뒤집는다.  insert(0, value)를 이용하여 리스트의 가장 앞에 계산한 값이 포함되도록 한다.  자릿수가 바뀌는 경우(e. g. , 99 -&gt; 100)를 대비하여 마지막에 up이 남아있는지 확인한다. 1234567891011121314class Solution:  def plusOne(self, digits: List[int]) -&gt; List[int]:    res = []    up = 1    for i in reversed(digits) :      if i + up &gt;= 10 :        res. insert(0, 0)        up = 1      else :        res. insert(0, i + up)        up = 0    if up == 1 :      res. insert(0, 1)    return res"
    }, {
    "id": 44,
    "url": "http://localhost:4000/length-of-last-word/",
    "title": "[Leetcode] 58. Length of Last Word",
    "body": "2019/10/08 - 하나의 문자열이 주어졌을 때, 마지막 단어의 길이를 구하는 문제  주어진 문자열은 upper/lower-case 알파벳과 공백으로 이루어진다.  단어란 공백을 포함하지 않는 charater의 sequence이다.  마지막 단어가 없는 경우, 0을 리턴한다. Example 1:  Input : s = “Hello World” Output : 5Example 2:  Input : s = “  fly me  to  the moon “ Output : 4Example 3:  Input : s = “luffy is still joyboy” Output : 6Note:  strip : 양쪽 공백 지우기 / rstrip : 오른쪽 공백 지우기 / lstrip : 왼쪽 공백 지우기 마지막 단어를 찾기 위함이므로, 왼쪽에 위치한 공백은 고려하지 않는다.  공백을 기준으로 split 하여 마지막 단어의 길이를 구한다. 123456class Solution:  def lengthOfLastWord(self, s: str) -&gt; int:    words = s. rstrip(). split()    if not words :      return 0    return len(words[-1])"
    }, {
    "id": 45,
    "url": "http://localhost:4000/search-in-rotated-sorted-array/",
    "title": "[Leetcode] 33. Search in Rotated Sorted Array",
    "body": "2019/10/07 - 정렬된 리스트와 정수 하나가 주어졌을 때, 주어진 정수(target)의 인덱스를 찾는 문제  리스트는 증가하는 방향으로 정렬되어 있지만, rotate 되어 있다.  e. g. , [0, 1, 2, 4, 5, 6, 7]은 [4, 5, 6, 7, 0, 1, 2]가 될 수 있다.  리스트 내에 정수가 존재하지 않는 경우 -1을 리턴한다. Example 1:  Input : nums = [4, 5, 6, 7, 0, 1, 2], target = 0 Output : 4Example 2:  Input : nums = [4, 5, 6, 7, 0, 1, 2], target = 3 Output : -1Example 3:  Input : nums = [1], target = 0 Output : -1Solution 1Note: python 내장 함수 사용 12345class Solution:  def search(self, nums: List[int], target: int) -&gt; int:    if nums. count(target) == 0 :      return -1    return nums. index(target)Solution 2Note:  target과 동일한 값이 있는 경우, 해당 인덱스를 리턴한다.  리스트가 정렬되어 있기 때문에 이전 값이 target보다 작은데 다음 값이 target보다 큰 경우 target은 존재하지 않는다. 1234567891011class Solution:  def search(self, nums: List[int], target: int) -&gt; int:    issmall = False    for i in range(len(nums)) :      if nums[i] == target :        return i      elif nums[i] &lt; target :        issmall = True      elif nums[i] &gt; target and issmall :        return -1    return -1"
    }, {
    "id": 46,
    "url": "http://localhost:4000/count-and-say/",
    "title": "[Leetcode] 38. Count and Say",
    "body": "2019/10/07 - 특정한 규칙에 따라 sequence가 생성될 때, n번째 sequence를 구하는 문제  ‘1’은 “one 1”로 읽기 때문에 ‘11’이 된다.  ‘11’은 “two 1s”로 읽기 때문에 ‘21’이 된다.  ‘21’은 “one 2, one 1”으로 읽기 때문에 ‘1211’이 된다.  n은 1 이상 30 이하로 주어진다.  첫 5개의 sequence는 다음과 같다.      1   11   21   1211   111221   Example 1:  Input : n = 4 Output : “1211”Example 2:  Input : n = 1 Output : “1”Note: 동일한 숫자가 반복되는 경우를 count하여 temp 문자열에 추가 123456789101112131415class Solution:  def countAndSay(self, n: int) -&gt; str:    res = '1'    for i in range(1, n) :      count, temp, num = 0, '', res[0]            for j in res :        if j == num :          count += 1        else :          temp += str(count) + num          num = j          count = 1      temp += str(count) + num      res = temp    return res"
    }, {
    "id": 47,
    "url": "http://localhost:4000/search-insert-position/",
    "title": "[Leetcode] 35. Search Insert Position",
    "body": "2019/10/06 - 정렬된 리스트와 정수 하나가 주어졌을 때, 주어진 정수(target)가 삽입될 위치의 인덱스를 찾는 문제  target이 삽입되더라도 리스트는 정렬되어 있어야 한다. Example 1:  Input : nums = [1, 3, 5, 6], target = 5 Output : 2Example 2:  Input : nums = [1, 3, 5, 6], target = 2 Output : 1Example 3:  Input : nums = [1,3,5,6], target = 7 Output : 4Note:  target이 리스트의 마지막 값보다 큰 경우 : 리스트의 제일 마지막에 위치한다.  리스트를 돌면서 target보다 크거나 같은 값이 나오면 해당 인덱스를 리턴한다. 1234567class Solution:  def searchInsert(self, nums: List[int], target: int) -&gt; int:    if target &gt; nums[-1] :      return len(nums)    for i in range(len(nums)) :      if nums[i] &gt;= target :        return i"
    }, {
    "id": 48,
    "url": "http://localhost:4000/find-first-and-last-position-of-element-in-sorted-array/",
    "title": "[Leetcode] 34. Find First and Last Position of Element in Sorted Array",
    "body": "2019/10/06 - 하나의 정렬된 리스트와 정수가 주어졌을 때, 주어진 정수(target)가 등장하는 처음과 끝의 인덱스를 찾는 문제  리스트 내에 target이 없는 경우, [-1, -1]을 리턴한다. Example 1:  Input : nums = [5, 7, 7, 8, 8, 10], target = 8 Output : [3, 4]Example 2:  Input : nums = [5, 7, 7, 8, 8, 10], target = 6 Output : [-1, -1]Example 3:  Input : nums = [], target = 0 Output : [-1, -1]Note:  count를 통해 리스트 내에 target의 존재 여부를 확인하고, index를 통해 리스트 내에서 처음 등장하는 인덱스를 찾는다.  정렬되어 있으므로, 첫 인덱스 + count - 1까지 등장한다. 12345678class Solution:  def searchRange(self, nums: List[int], target: int) -&gt; List[int]:    c = nums. count(target)    if c == 0 :      return [-1, -1]    i = nums. index(target)    res = [i, i + c - 1]    return res"
    }, {
    "id": 49,
    "url": "http://localhost:4000/remove-duplicates-from-sorted-array/",
    "title": "[Leetcode] 26. Remove Duplicates from Sorted Array",
    "body": "2019/10/05 - 정수로 이루어진 정렬된 리스트가 주어졌을 때, 주어진 리스트에서 겹치는 숫자들을 제외한 리스트를 만드는 문제  in-place : 다른 리스트를 할당하지 말고 주어진 리스트 내에서 해결할 것 각 원소는 단 한 번씩만 나타나야 한다.  새롭게 만들어진 리스트의 길이를 리턴 리턴한 길이의 뒷부분에는 리스트에 어떤 값이 있건 상관하지 않는다. Example 1:  Input : nums = [1, 1, 2] Output : length = 2, nums = [1, 2, …]Example 2:  Input : nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] Output : length = 5, nums = [0, 1, 2, 3, 4, …]Solution 1Note:  리스트가 정렬되어 있으므로, 다음에 나타나는 원소가 이전과 동일하다면 삭제하는 방법으로 구현 리스트 내에서 순서를 바꾸는 방법도 가능123456789101112131415class Solution:  def removeDuplicates(self, nums: List[int]) -&gt; int:        if not nums :      return 0    length = len(nums)    now = nums[0]    i = 1    while (i &lt; length) :      if now == nums[i] :        del nums[i]        length -= 1      else :        now = nums[i]        i += 1    return i  Solution 2Note:  원소의 중복을 허용하지 않는 set을 이용 (참고) memory 사용량은 동일하다. 12345class Solution:  def removeDuplicates(self, nums: List[int]) -&gt; int:    nums[:] = list(set(nums))    nums. sort()    return len(nums)"
    }, {
    "id": 50,
    "url": "http://localhost:4000/implement-strstr/",
    "title": "[Leetcode] 28. Implement strStr()",
    "body": "2019/10/05 - 두 개의 문자열(haystack, needle)이 주어졌을 때, haystack 내에서 needle이 처음 등장하는 인덱스를 리턴하는 문제  needle이 haystack 내에 존재하지 않는다면 -1을 리턴한다. Example 1:  Input : haystack = “sadbutsad”, needle = “sad” Output : 0Example 2:  Input : haystack = “leetcode”, needle = “leeto” Output : -1Note:  find : 찾는 문자나 문자열이 없다면 -1을 리턴 index : 찾는 문자나 문자열이 없다면 오류 발생123class Solution:  def strStr(self, haystack: str, needle: str) -&gt; int:    return haystack. find(needle)"
    }, {
    "id": 51,
    "url": "http://localhost:4000/remove-element/",
    "title": "[Leetcode] 27. Remove Element",
    "body": "2019/10/04 - 정수로 이루어진 리스트와 정수가 하나 주어졌을 때, 주어진 리스트에서 주어진 정수를 제외한 리스트를 만드는 문제  in-place : 다른 리스트를 할당하지 말고 주어진 리스트 내에서 해결할 것 주어진 정수를 제외한 리스트의 길이를 리턴 새로운 리스트의 원소 순서는 변경될 수 있다.  리턴한 길이의 뒷부분에는 리스트에 어떤 값이 있건 상관하지 않는다. Example 1:  Input : nums = [3, 2, 2, 3], val = 3 Output : length = 2, nums = [2, 2, …]Example 2:  Input : nums = [0, 1, 2, 2, 3, 0, 4, 2], val = 2 Output : length = 5, nums = [0, 1, 3, 0, 4, …] nums의 첫 5개의 원소에 0, 0, 1, 3, 4가 포함되어 있으면 정답 처리Note:  val과 동일한 원소가 있으면 리스트에서 삭제하는 방법으로 구현 리스트 내에서 순서를 바꾸는 방법도 가능1234567891011class Solution:  def removeElement(self, nums: List[int], val: int) -&gt; int:    i = 0    length = len(nums)    while i &lt; length :      if nums[i] == val :        nums. remove(nums[i])        length -= 1        continue      i += 1    return len(nums)"
    }, {
    "id": 52,
    "url": "http://localhost:4000/merge-two-sorted-lists/",
    "title": "[Leetcode] 21. Merge Two Sorted Lists",
    "body": "2019/10/03 - 두 개의 정렬된 Linked List가 주어졌을 때, 이를 정렬된 하나의 Linked List로 만드는 문제  각 list의 노드 개수는 [0, 50]이다.  list1과 list2는 모두 non-decreasing 순으로 정렬되어 있다. Example 1:  Input : list1 = [1, 2, 4], list2 = [1, 3, 4] Output : [1, 1, 2, 3, 4, 4]Example 2:  Input : list1 = [], list2 = [] Output : []Example 3:  Input : list1 = [], list2 = [0] Output : [0]Note:  next가 None이 아닐 때까지 값을 하나씩 비교 하나의 리스트가 끝나면 다른 리스트의 남은 부분을 결과 리스트의 뒤에 붙인다. 123456789101112131415161718192021222324# Definition for singly-linked list. # class ListNode:#   def __init__(self, x):#     self. val = x#     self. next = Noneclass Solution:  def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:    res = ListNode(-1)    head = res    while l1 and l2 :      if l1. val &lt; l2. val :        head. next = ListNode(l1. val)        head = head. next        l1 = l1. next      else :        head. next = ListNode(l2. val)        head = head. next        l2 = l2. next    if l1 :      head. next = l1    if l2 :      head. next = l2    return res. next"
    }, {
    "id": 53,
    "url": "http://localhost:4000/valid-parentheses/",
    "title": "[Leetcode] 20. Valid Parentheses",
    "body": "2019/10/02 - 주어진 문자열의 괄호가 유효한지 확인하는 문제  문자열은 6가지 종류의 문자를 포함한다 : ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[’, ‘]’ 열리는 괄호는 반드시 같은 종류의 닫히는 괄호로 닫혀야 한다.  열린 괄호는 반드시 정확한 순서대로 닫혀야 한다. Example 1:  Input : s = “()” Output : trueExample 2:  Input : s = “()[]{}” Output : trueExample 3:  Input : s = “(]” Output : falseNote:  dict 사용 (key : 열리는 괄호 / value : 닫히는 괄호) 비어있는 sequence는 false 값을 가진다.  if (not) len(seq) 대신 if (not) seq 사용을 권장한다. 123456789101112class Solution:  def isValid(self, s: str) -&gt; bool:    p_map = {'(' : ')', '{' : '}', '[' : ']'}    stack = []    for i in s :      if i in ['(', '{', '['] :        stack. append(i)      elif stack and i == p_map[stack[-1]] :        stack. pop()      else :        return False    return not stack"
    }, {
    "id": 54,
    "url": "http://localhost:4000/3sum/",
    "title": "[Leetcode] 15. 3Sum",
    "body": "2019/06/25 - 주어진 정수 배열에서 세 개의 합이 0이 되는 모든 unique triplet을 찾는 문제  동일한 triplet이 포함되어서는 안 된다. (중복을 허용하지 않는다. ) 세 값의 합이 0이 되는 triplet이 존재하지 않을 경우, 빈 리스트([])를 리턴한다. Example 1:  Input : nums = [-1, 0, 1, 2, -1, -4] Output : [[-1, 0, 1], [-1, -1, 2]]Example 2:  Input : nums = [0, 1, 1] Output : []Example 3:  Input : nums = [0, 0, 0] Output : [0, 0, 0]Note: set을 사용하여 중복되는 값을 처리한다. 1234567891011121314151617181920212223class Solution:  def threeSum(self, nums: List[int]) -&gt; List[List[int]]:    if len(nums) &lt; 3 :      return []    nums. sort()    res = set()    l = len(nums)    for i in range(l) :            if nums[i] &gt; 0 :        break      target = -nums[i]      j, k = i + 1, l - 1      while j &lt; k :        temp = nums[j] + nums[k]        if temp &lt; target :          j += 1        elif temp &gt; target :           k -= 1        else :          res. add((nums[i], nums[j], nums[k]))          j += 1          k -= 1    return list(res)"
    }, {
    "id": 55,
    "url": "http://localhost:4000/longest-common-prefix/",
    "title": "[Leetcode] 14. Longest Common Prefix",
    "body": "2019/06/24 - 여러 문자열이 포함된 array(list)가 주어졌을 때, 가장 긴 common prefix(모든 문자열에서 등장하는 prefix)를 찾는 문제  common prefix가 없는 경우, 빈 문자열(““)을 리턴한다.  모든 입력은 소문자 알파벳으로만 주어진다. Example 1:  Input : [“flower”, “flow”, “flight”] Output : “fl”Example 2:  Input : [“dog”, “racecar”, “car”] Output : “”Note:  zip(*iterabble) : 동일한 개수로 이루어진 자료형을 묶어준다.      e. g. , list(zip([1, 2, 3], [4, 5, 6])) -&gt; [(1, 4), (2, 5), (3, 6)]    문자열 리스트를 정렬한 경우, 첫 번째 문자열과 마지막 문자열만 비교하면 가장 긴 common prefix를 구할 수 있다. 1234567891011121314class Solution:  def longestCommonPrefix(self, strs: List[str]) -&gt; str:    if len(strs) == 0 :      return       elif len(strs) == 1 :      return strs[0]    strs. sort()    res =       for x, y in zip(strs[0], strs[-1]) :      if x == y :        res += x      else :        break    return res"
    }, {
    "id": 56,
    "url": "http://localhost:4000/roman-to-integer/",
    "title": "[Leetcode] 13. Roman to Integer",
    "body": "2019/06/23 - 로마 숫자가 주어졌을 때, 정수로 변환하는 문제  각 문자(symbol)별 해당하는 값은 아래와 같다.      I : 1 / V : 5 / X : 10 / L : 50 / C : 100 / D : 500 / M : 1000    왼쪽에서 오른쪽으로 읽으며, 큰 숫자에서 작은 숫자의 순서로 작성된다.  작은 값에 해당하는 문자가 큰 값에 해당하는 문자의 왼쪽에 위치할 경우, 그 값만큼을 뺀다. (e. g. , IV : 4)Example 1:  Input : s = “III” Output : 3Example 2:  Input : s = “LVIII” Output : 58Example 3:  Input : s = “MCMXCIV” Output : 1994Note:  dict 사용 (key : 로마 숫자(문자) / value : 문자에 해당하는 값) 이전에 나타난 문자가 현재 문자보다 작은 값일 경우 : 현재 문자의 값 - 이전 문자의 값 동일한 문자가 반복되는 경우 : 해당 문자보다 크거나 작은 값을 지닌 문자가 나올 때까지 더한다.  이전에 나타난 문자가 현재 문자보다 큰 값일 경우 : 이전까지의 값을 전부 더한다. (큰 숫자에서 작은 숫자로 작성되므로)1234567891011121314151617181920class Solution:  def romanToInt(self, s: str) -&gt; int:    dict = {'I' : 1, 'V' : 5, 'X' : 10, 'L' : 50, 'C' : 100, 'D' : 500, 'M' : 1000}        res = 0    temp = 0    before = 1000    for i, ch in enumerate(s) :      if before &lt; dict[ch] :        temp = dict[ch] - temp        res += temp        temp = 0      elif before == dict[ch] :        temp += dict[ch]      else :        res += temp        temp = dict[ch]      before = dict[ch]    res += temp    return res"
    }, {
    "id": 57,
    "url": "http://localhost:4000/palindrome-number/",
    "title": "[Leetcode] 9. Palindrome Number",
    "body": "2019/06/22 - 하나의 정수가 주어졌을 때, 해당 정수가 palindrome인지 확인하는 문제  Palindrome이란 : 회문. 거꾸로 읽었을 때도 제대로 읽었을 때와 동일한 경우Example 1:  Input : x = 121 Output : trueExample 2:  Input : x = -121 Output : false 거꾸로 읽으면 121-가 되므로 palindrome이 아니다. Example 3:  Input : x = 10 Output : falseNote: reverse 문자열 구하는 방법 : [::-1] 1234567class Solution:  def isPalindrome(self, x: int) -&gt; bool:    x = str(x)    if x == x[::-1] :      return True    else :       return False"
    }, {
    "id": 58,
    "url": "http://localhost:4000/string-to-integer-atoi/",
    "title": "[Leetcode] 8. String to Integer (atoi)",
    "body": "2019/06/21 - 문자열이 주어졌을 때, 해당 문자열을 정수로 변환하는 문제  문자열은 whitespace character, 숫자 및 문자로 구성된다.  스페이스(‘ ‘)만이 whitespace character로 간주되며, 시작 부분을 포함하여 문자열 내에 많이 존재할 수 있다.  minus(‘-‘) 및 plus(‘+’) 기호로 숫자가 시작될 수 있다.  첫 non-whitespace character가 숫자 및 ‘+’, ‘-‘가 아닐 경우, 0을 리턴 32-bit signed integer(-2^31 ~ 2^31 - 1)를 기준으로 하여, 해당 범위를 넘는 경우 INT_MAX 혹은 INT_MIN을 리턴Example 1:  Input : s = “42” Output : 42Example 2:  Input : s = “ -042” Output : -42Example 3:  Input : s = “1337c0d3” Output : 1337Example 4:  Input : s = “0-1” Output : 0Example 5:  Input : s = “words and 987” Output : 0Solution 1Note:  strip() : 문자열 양쪽으로 한 칸 이상의 연속된 공백을 모두 지우는 함수 split() : 공백을 기준으로 문자열을 나누어 리스트로 반환123456789101112131415161718192021222324class Solution:  def myAtoi(self, str: str) -&gt; int:    idx = 0    s = str. strip(). split()    if len(s) == 0 :       return 0        s = s[0]    if s[0] == '+' or s[0] == '-' :      idx = 1    for ch in s[idx:] :      if ch. isdigit() :        idx += 1      else :        break        res = s[:idx]    res = int(res) if (res != '+' and res != '-' and res) else 0    if res &lt; -2 ** 31 :      return -2 ** 31    elif res &gt; 2 ** 31 - 1 :       return 2 ** 31 - 1    else :      return resSolution 2Note: str을 한 문자씩 확인하면서 숫자를 찾는 방식으로 구현 1234567891011121314151617181920212223class Solution:  def myAtoi(self, str: str) -&gt; int:    res, idx, isminus = 0, 0, False    intmax, intmin = 2 ** 31 - 1, -2 ** 31    if not str :      return 0    for i in range(len(str)) :      if str[i] != ' ' :        idx = i        break    if str[idx] == '-' or str[idx] == '+' :      isminus = True if str[idx] == '-' else False      idx += 1    for i in range(idx, len(str)) :      if str[i]. isdigit() :        res = res * 10 + int(str[i])      else :        break    if isminus :      res *= -1      return intmin if res &lt; intmin else res    else :      return intmax if res &gt; intmax else res"
    }, {
    "id": 59,
    "url": "http://localhost:4000/reverse-integer/",
    "title": "[Leetcode] 7. Reverse Integer",
    "body": "2019/06/20 - 주어진 32-bit 정수를 뒤집는 문제  32-bit signed integer 기준 (범위 : -2^31 ~ 2^31 - 1) 해당 범위를 넘는 경우, 0을 출력Example 1:  Input : x = 123 Output : 321Example 2:  Input : x = -123 Output : -321Example 3:  Input : x = 120 Output : 21Note: reverse 문자열 구하는 방법 : [::-1] 1234567891011class Solution:  def reverse(self, x: int) -&gt; int:    if x &gt; 0 :      res = int(str(x)[::-1])    else :      res = -1 * int(str(x * -1)[::-1])        if -2**31 &lt;= res &lt;= 2**31 - 1 :      return res    else :      return 0"
    }, {
    "id": 60,
    "url": "http://localhost:4000/longest-substring-without-repeating-characters/",
    "title": "[Leetcode] 2. Longest Substring Without Repeating Characters",
    "body": "2019/06/13 - 주어진 문자열에서 문자가 반복되지 않는 최대 길이의 substring의 길이를 구하는 문제  subsequence가 아닌 substring이어야 한다. (e. g. , pwwkew에서 pwke는 subsequence)Example 1:  Input : s = “abcabcbb” Output : 3 “abc” -&gt; 3Example 2:  Input : s = “bbbbb” Output : 1 “b” -&gt; 1Example 3:  Input : s = “pwwkew” Output : 3 “wke” -&gt; 3 (not “pwke”)Note: dict 사용 (key : 출현한 문자 / value : 해당 문자의 index)sliding window 방식반복된 문자가 나타났을 경우, 지금의 substring에의 포함 여부 확인 후 업데이트 1234567891011121314class Solution:  def lengthOfLongestSubstring(self, s: str) -&gt; int:    seen = {}    res = temp = start = 0        for i, ch in enumerate(s) :      if ch in seen and seen[ch] &gt;= start :        res = max(res, temp)        temp = i - seen[ch]        start = seen[ch] + 1      else :        temp += 1      seen[ch] = i    return max(res, temp)"
    }, {
    "id": 61,
    "url": "http://localhost:4000/add-two-numbers/",
    "title": "[Leetcode] 2. Add Two Numbers",
    "body": "2019/06/12 - 두 개의 Linked List가 주어졌을 때, 두 Linked List의 합을 구하는 문제  각 노드에는 정확히 1자리의 숫자가 포함되어 있다.  숫자는 역순으로 저장되어 있다. (e. g. , 342 : 2 -&gt; 4 -&gt; 3) 숫자 0이 아닌 경우, 0으로 시작하는 숫자는 없다. (e. g. , 043은 없다)Example 1:  Input : l1= [2, 4, 3], l2 = [5, 6, 4] Output : [7, 0, 8] 342 + 465 = 807Example 2:  Input : l1 = [0], l2 = [0] Output : [0]Example 3:  Input : l1 = [9, 9, 9, 9, 9, 9, 9], l2 = [9, 9, 9, 9] Output : [8, 9, 9, 9, 0, 0, 0, 1]Note: divmod : python 내장함수 (a/b, a%b 값을 리턴) 123456789101112131415161718192021222324# Definition for singly-linked list. # class ListNode:#   def __init__(self, x):#     self. val = x#     self. next = Noneclass Solution:  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:    up = 0    res = ListNode(-1)    tail = res        while l1 or l2 or up :      val1 = (l1. val if l1 else 0)      val2 = (l2. val if l2 else 0)      up, num = divmod(val1 + val2 + up, 10)            tail. next = ListNode(num)      tail = tail. next            l1 = (l1. next if l1 else None)      l2 = (l2. next if l2 else None)        return res. next"
    }, {
    "id": 62,
    "url": "http://localhost:4000/two-sum/",
    "title": "[Leetcode] 1. Two Sum",
    "body": "2019/06/11 - 주어진 정수 배열에서 두 값의 합이 찾고자 하는 값(target)일 경우, 두 인덱스를 반환하는 문제  정확히 하나의 솔루션이 존재한다.  동일한 값은 두 번 사용할 수 없다. Example 1:  Input : nums = [2, 7, 11, 15], target = 9 Output : [0, 1] nums[0] + nums[1] = 2 + 7 = 9Example 2:  Input : nums = [3, 2, 4], target = 6 Output : [1, 2]Example 3:  Input : nums = [3, 3], target = 6 Output : [0, 1]Note: dict를 사용하여 해결 (key : 확인한 정수값, value : 해당 값의 인덱스) 1234567891011class Solution:  def twoSum(self, nums: List[int], target: int) -&gt; List[int]:    seen = {}    for i, num in enumerate(nums) :      temp = target - num      if temp in seen :        return [seen[temp], i]      else :        seen[num] = i    return []"
    }, {
    "id": 63,
    "url": "http://localhost:4000/cudaEvent/",
    "title": "[CUDA 7] GPU 실행시간 측정 - cudaEvent",
    "body": "2016/01/15 - GPU에서 실행 시간을 측정할 수 있는 방법은 StopWatchInterface를 사용하는 등 여러 가지가 있지만, NVIDIA에서 공식적으로 제공하는 Programming Guide에서 확인할 수 있는 내용인 cudaEvent를 소개하고자 합니다. 사용하는 방법은 다음과 같습니다. 123456789101112131415161718192021// cudaEvent createcudaEvent_t start, stop;cudaEventCreate(&amp;start);cudaEventCreate(&amp;stop);. . . cudaEventRecord(start, 0);// 실행 시간을 측정할 GPU 코드cudaEventRecord(stop, 0);cudaEventSynchronize(stop);float elapsedTime;cudaEventElapsedTime(&amp;elapsedTime, start, stop);. . . // cudaEvent destroycudaEventDestroy(start);cudaEventDestroy(stop);우선 두 개의 cudaEvent 변수를 생성해주어야 합니다. cudaEvent는 record하는 순간의 timestamp를 저장하는 형식이기 때문에 2개가 필요합니다. 이후 cudaEventRecord() 함수를 이용하여 시작하는 순간과 끝나는 순간의 timestamp를 저장하면 됩니다. 시간은 cudaEventElapsedTime() 함수를 이용하여 받아오는데, 기본적으로 float 형을 사용합니다. 마지막으로 cudaEventDestroy() 함수를 이용하여 cudaEvent를 destroy 해주면 마무리됩니다. "
    }, {
    "id": 64,
    "url": "http://localhost:4000/cpp-cuda-function/",
    "title": "[CUDA 5.5] cpp에서 CUDA 함수 사용하기",
    "body": "2015/04/07 - 이번 포스팅에서는 cpp에서 CUDA 함수를 사용하는 방법에 대하여 이야기해보겠습니다. 지금껏 . cu 파일만으로 프로젝트를 구성하게 되면 다음과 같은 구조로 나타납니다.  main 함수에서는 kernel 함수로 __global__ 함수를 호출하고, __global__ 함수는 sub 함수로 __device__ 함수를 호출하면서 프로그램이 진행됩니다. 즉, . cu 파일 내에서 main 함수가 있고, __global__ 함수와 __device__ 함수가 존재해 서로를 호출하는 데에 문제가 없었을 것입니다. 하지만 일반적인 프로그램의 경우 cpp(혹은 c)와 CUDA를 혼재해서 사용하게 되고, 그렇게 되면 . cu 파일에 있는 CUDA 함수들을 호출하는 데에 문제가 생깁니다. main 함수는 . cpp 파일에 있고, CUDA 함수는 . cu 파일에 있는 구조가 되기 때문에 그것을 정의해주지 않으면 인식하지 못하기 때문입니다. cpp에서 CUDA 함수를 사용하게 되는 과정을 간단히 구조화하면 다음과 같습니다.  main 함수는 . cpp 파일에 있고, 다른 cpp 함수들도 호출하면서 프로그램이 진행됩니다. 그러다 CUDA 함수를 사용할 경우가 생기면 . cu 파일 내에 정의된 __host__ function을 호출하는 방식으로 CUDA 함수를 사용합니다. __host__ 함수는 필요한 CUDA 함수를 진행하여 결과를 얻어 main 함수, 혹은 cpp 함수로 전달해주는 역할을 합니다. 여기서 중요한 점은 __host__ function과 main 함수는 다르다는 점입니다. main 함수는 __host__ 함수라고 할 수 있지만, 모든 __host__ 함수가 main 함수는 아닙니다. __host__ 함수에 extern  C 라고 표시가 되어 있는데, 이것이 바로 cpp에서 CUDA 함수를 호출할 수 있게 해 주는 문법입니다. 사용하는 방법은 다음과 같습니다. 우선 cpp 파일에 이러이러한 CUDA 함수를 사용할 것이라고 정의하여 줍니다. 일반적으로 header file에 정의하게 되지만, 프로젝트의 사이즈가 크지 않다면 CUDA 함수를 호출하는 부분이 있는 파일에 정의해주면 됩니다. 1extern  C  void cuda_function(int a, int b, . . . );일반적으로 함수를 정의할 때처럼 정의해주면 되지만, 중요한 점은 앞에 extern  C  를 붙여야 한다는 것입니다. 이렇게 정의한 함수를 . cu 파일에서 __host__ 함수로 작성하면 됩니다. 12345678910__global__ void global_function(int a, int b, . . . ) {  . . . }extern  C  void cuda_function(int a, int b, . . . ) {  . . .   global_function&lt;&lt;&lt;blockDim, threadDim&gt;&gt;(a, b, . . . );  checkCudaErrors(cudaThreadSynchronize());  . . . }위 코드는 . cu 파일에 작성되는 코드입니다. extern  C 를 붙인 __host__ 함수는 결국 cpp와 CUDA 함수들을 연결해주는 연결다리 역할을 한다고 볼 수 있습니다. 실제로 사용하는 예는 다음과 같습니다. 제 프로젝트에서 작성한 코드 일부입니다. 12345678910111213141516//kernel Functions//glInputOutput_kernel. cuextern  C  void setupTexture(int iv, int ih, Pixel *data, int bpp, int num);extern  C  void deleteTexture(int num);extern  C  void deleteAllTextures();extern  C  void displayMod(Pixel *data, Pixel *bgData, Pixel *curData, Pixel *diffData, int v, int h, enum showBoxMode mode);// diffImage. cuextern  C  double diffImage(Pixel *bgData, Pixel *curData, Pixel *diffData, unsigned int width, unsigned int height, unsigned int size);// bilateralFilter. cuextern  C  void initTexture(int width, int height, Pixel *image);extern  C  void freeTexture();extern  C  void updateGaussian(float delta, int radius);extern  C  double initBilateralFilterCUDA(float delta, int radius, int width, int height, Pixel *pixels);extern  C  double bilateralFilter(Pixel *pixels, int width, int height, float e_d, int radius, int iterations);123456789__global__ void imageSubtractionGlobal(Pixel *bgData, Pixel *curData, Pixel *diffData, int x) {  int i = blockDim. x * blockIdx. x + threadIdx. x;  diffData[i] = MIN(MAX((bgData[i] - curData[i]), 0. f), 255. f);}extern  C  void diffImage(Pixel *bgData, Pixel *curData, Pixel *diffData, unsigned int width, unsigned int height, unsigned int size) {  imageSubtractionGlobal&lt;&lt;&lt;512, 512&gt;&gt;&gt;(bgData, curData, diffData, width);  checkCudaErrors(cudaThreadSynchronize());}"
    }, {
    "id": 65,
    "url": "http://localhost:4000/cuda-memory-optimization/",
    "title": "[CUDA 5.5] CUDA 메모리 성능 최적화",
    "body": "2015/04/04 - ※ 이 글은 2014년도에 작성된 글입니다. 사진이나 세부적인 내용은 지금과 다를 수 있습니다. CUDA 메모리는 CPU와 비교하면 무척이나 빠른 메모리 액세스 속도를 제공하지만, 최적화된 성능을 발휘하기 위해서는 여러 조건들을 충족시켜야 합니다. CUDA는 수백, 수천 개의 코어에서 DRAM이나 캐시에 있는 데이터를 동시에 읽고, 쓰기 때문에 데이터 병목 현상(bottleneck)이 발생하게 됩니다. 이러한 제약 조건들도 새로운 그래픽 카드가 출시되면서 점차 개선되고 있지만, CUDA 어플리케이션의 성능을 향상시키기 위해서는 이러한 병목 현상을 피하고 이상적인 병렬화를 구현할 필요가 있습니다. 글로벌 메모리 액세스 결합 (Coalescing)CUDA 프로그램에서 구현하는 솔루션과 데이터의 형식에 따라 다양한 글로벌 메모리 액세스 패턴이 나타나게 됩니다. NVIDIA 그래픽 카드의 메모리 전송은 한 번에 512bit를 읽어올 때 최대의 성능을 발휘한다고 알려져 있습니다. 글로벌 메모리를 읽어올 때 최대 bandwidth를 사용할 수 있는 조건이 있는데, 이것을 메모리 결합(Coalescing) 조건이라고 합니다. CUDA에서 결합 조건을 충족할 때와 하지 못했을 때 그래픽 카드의 종류에 따라 최대 10배의 성능 차이가 발생합니다. GeForce 200 시리즈 이후로 글로벌 메모리 액세스 결합 전송 조건이 많이 완화되고, 자동화됨에 따라 이전 시리즈의 그래픽 카드보다 쉽게 개선된 성능을 보입니다. 하지만 가끔 비결합 전송 상태로 동작하여 낮은 성능을 나타낼 때도 있기 때문에 프로그램을 실행하면서 성능을 확인하여 결합 전송이 자동으로 이루어지는지를 확인할 필요가 있습니다. 공유 메모리 뱅크 충돌 (Bank Conflict)공유 메모리는 GPU 프로세서 내부에 장착되어 있어 제대로 사용하면 빠른 속도로 데이터를 처리할 수 있는 CUDA의 큰 장점 중 하나입니다. 공유 메모리의 속도를 저하하는 요인으로는 공유 메모리를 구성하는 메모리 뱅크의 액세스 충돌(Bank Conflic)이 있습니다. 메모리 뱅크(Memory Bank)는 각 뱅크마다 한 번의 GPU 사이클에 한 번 액세스 할 수 있으며, 뱅크의 개수만큼의 스레드가 병렬로 모든 뱅크에 동시에 액세스 할 때 가장 큰 효율을 얻을 수 있습니다. 간단한 섬영르 위해 16KB 공유 메모리와 4개의 뱅크가 있고, 각각의 뱅크는 1KB의 메모리로 이루어져 있다고 가정합시다. 또, 뱅크 0번부터 4byte씩 메모리가 배치되어 16byte 블록이 하나의 열을 이루는 형식이라고 가정하겠습니다. 뱅크 충돌이 없는 공유 메모리 액세스: 위 그림은 뱅크 충돌이 없는 공유 메모리 액세스를 나타냅니다. 공유 메모리에는 글로벌 메모리와 같은 시작 address나 결합 전송 조건은 없지만, 한 스레드 당 하나의 뱅크에 액세스 할 수 있다는 제약이 있습니다. 그림에서는 4개의 스레드가 각각 하나의 뱅크에 액세스하여 뱅크 충돌이 없는 이상적인 패턴을 나타내고 있습니다. 공유 메모리는 글로벌 메모리와 같은 액세스 시작 위치 또는 오름차순 정렬 조건이 없기 때문에 랜덤 액세스에 대해서도 같은 뱅크 액세스만 없으면 효괒거으로 동작하게 됩니다.  즉, 위 그림과 같이 스레드가 어지럽게 공유 메모리에 액세스하더라도 같은 뱅크끼리 겹치는 스레드가 없다면 공유 메모리는 효과적으로 동작합니다. 2-way 뱅크 충돌: 만일 모든 스레드가 한 번에 공유 메모리를 읽거나 쓸 때, 2개의 스레드가 하나의 뱅크에 액세스하려고 하면 뱅크 충돌이 발생하게 됩니다. 2번의 뱅크 충돌이 발생하는 것을 2-way 뱅크 충돌이라고 하는데, 2-way 뱅크 충돌이 발생하면 GPU가 2번의 사이클에 나누어 공유 메모리를 차례로 가져오게 되고, 결국 효율이 절반으로 떨어지게 됩니다.  위 그림은 모든 스레드가 2개씩 하나의 뱅크에 액세스하고 있는 2-way 뱅크 충돌을 나타냅니다. 비슷한 예로 4-way 뱅크 충돌 또한 존재하는데, 4-way 뱅크 충돌이 일어나게 되면 효율은 1/4로 떨어지게 됩니다. CUDA에서 항상 모든 스레드가 2개씩 하나의 뱅크에 액세스해야만이 2-way 뱅크 충돌이 되는 것은 아닙니다. 모든 스레드 중에서 2개의 스레드만 같은 뱅크에 액세스하더라도 결국 GPU는 2번의 사이클에 나누어 공유 메모리에 접근해야 하기 때문에 효율이 절반으로 떨어지는 것은 똑같습니다.  위 그림처럼 모든 스레드가 정렬되어 공유 메모리에 액세스하고 있지만, 스레드 0과 스레드 1이 뱅크 1에 동시에 액세스하고 있는 경우 또한 2-way 뱅크 충돌입니다. 이렇게 프로그램이 구현되어 있으면 아무리 다른 스레드들이 정렬되어 있다고 하여도 전체 효율은 절반으로 떨어집니다. 이것은 워프 단위로 실행하고 워프의 절반 단위로 메모리에 액세스하는 CUDA thread의 특징 때문입니다. 16-way 뱅크 충돌: 16-way 뱅크 충돌은 1차원으로 구성된 스레드-블록(thread-block) 구조에서는 잘 발생하지 않습니다. 하지만 2차원 스레드-블록 구조로 작업을 분할할 때 스레드 인덱스 처리가 제대로 되지 않으면 발생할 수 있습니다. 16-way 뱅크 충돌이 일어나면 2-way 뱅크 충돌이나 4-way 뱅크 충돌과 마찬가지로 각 스레드가 하나의 뱅크에 차례로 액세스하기 때문에 효율이 1/16으로 떨어지게 됩니다. 16-way 뱅크 충돌이 주로 2차원 스레드-블록 구조에서 발생하는 이유는 1차원의 경우 일반적으로 행 방향으로 인덱스를 진행하여 액세스하지만, 2차원에서는 열 방향으로도 인덱스를 진행하는 경우가 생기기 때문입니다.  위 그림과 같이 행 방향으로만 인덱스를 진행할 경우 뱅크 충돌이 발생하지 않고 정상적으로 동작하게 됩니다. 하지만 열 방향으로 인덱스를 진행하면 아래와 같이 뱅크 충돌이 발생할 수 있습니다.  위 그림은 공유 메모리의 뱅크 0에 16개의 스레드가 모두 액세스하여 16-way 뱅크 충돌이 발생하게 되는 상황을 나타냅니다. 이와 같은 뱅크 충돌을 피하기 위해서는 알고리즘을 수정하기 보다는 메모리 할당 공간을 수정하는 것이 좋은 방법입니다.  위 그림은 공유 메모리에 16x17의 배열이 물리적으로 할당된 형태를 나타냅니다. 이와 같은 방법을 메모리 패딩(Memory Padding)이라고 합니다. 위와 같이 공유 메모리를 16x17로 하면 행 방향과 열 방향의 메모리가 동일한 뱅크에 할당되지 않습니다. 약간의 공간을 더 소비함으로써 16-way 뱅크 충돌을 피하고, 뱅크 충돌이 발생했을 때보다 16배의 액세스 속도를 얻을 수 있습니다. 고정 메모리 (Pinned Memory)페이지 락 메모리(Page Lock Memory) 또는 고정 메모리(Pinned Memory)라 불리는 시스템 메모리는 가상 메모리(Virtual Memory) 기술과 관련이 있습니다. 가상 메모리는 컴퓨터에 장착된 RAM의 용량에 한계가 있어 충분하지 않기 때문에 발생하는 메모리 부족 문제를 해결하기 위한 방법으로 개발된 것입니다. 가상 메모리는 컴퓨터와 운영체제에 의해 제어되며 RAM의 부족한 용량을 HDD의 도움을 받아 해결합니다. 운영체제 시스템에 RAM과 HDD의 공간을 이용하여 가상으로 큰 메모리 공간을 페이지 단위로 분할하여 제공하는 것입니다. CUDA 프로그램의 약점 중 하나는 GPU로 계산하기 전에 입력 데이터를 host에서 device로 복사하고, 또 계산된 결과를 device에서 host로 복사하는 과정이 추가되는 것입ㄴ디ㅏ. 이 시간은 기존의 프로그램과 비교했을 때 추가적인 부하로 작용하며, 병목 현상(bottleneck)이 발생할 가능성이 높습니다. 때문에 이 시간을 줄이고자 CUDA 프로그램을 구현할 때 여러 가지 방법을 사용하게 됩니다. 그 중 하나가 바로 가상 메모리 기술의 일부를 제한하고 물리적인 RAM 공간만을 사용하는 것입니다. 가상 메모리를 이용하면 메모리를 사용하기 위해 HDD와 RAM 공간의 페이지 치환이 일어나게 되는데, 이 시간을 줄이고 물리적인 RAM에서 device로 복사하는 것입니다. 이렇게 페이지 치환이 되지 않는 메모리를 페이지 락 메모리(Page Lock Memory) 또는 고정 메모리(Pinned Memory)라고 부르는데, 이는 RAM 공간에만 상주하는 메모리를 의미합니다. 고정 메모리를 사용하면 일반적인 힙(Heap) 메모리 할당 방법보다 약 10~50%의 전송 속도가 향상됩니다. 또 CUDA에서 스트림(Stream, 비동기 함수)를 사용하기 위해서는 고정 메모리를 이용해야만 합니다. 고정 메모리는 CUDA API 함수 호출을 통해 사용할 수 있습니다. 하지만 고정 메모리는 항상 물리적 RAM 공간에 상주하기 때문에 고정 메모리를 너무 많이 사용할 경우 컴퓨터의 가상 메모리가 원활하게 작동하기 어려워 메모리 성능과 전체 시스템의 성능 저하를 가져올 수 있다는 단점이 있습니다. 제로 복사 (Zero-copy)제로 복사(Zero-copy 혹은 MApped Memory) 기능은 단어 뜻 그대로 복사를 하지 않는다는 의미입니다. 대부분의 CUDA 프로그램은 GPU를 사용하기 위해 입력 데이터를 host에서 device로 복사하고, 그 데이터를 처리하여 출력 데이터를 device에서 host로 복사합니다. 이는 데이터 읽기와 계산, 쓰기의 과정이 차례로 실행되며 데이터 전송 시 사용되는 PCI 버스를 한 방향만 사용하게 합니다. 제로 복사는 GPU가 host에 할당된 고정 메모리 영역에 바로 액세스하여 데이터를 읽고 쓰는 작업을 말합니다. PCI 버스를 이용하여 데이터를 전송하는 것은 동일하기 때문에 전송 속도가 빨라지는 것은 아니지만, 메모리에서 읽어들인 데이터를 계산하고 결과값을 메모리에 쓰면 비동기로 양방향 PCI 전송이 진행되기 때문에 그만큼의 성능 향상을 얻을 수 있습니다. 이 방법은 통상적으로 1. 5배에서 2배 가량의 성능 향상 효과가 있다고 알려져 있습니다. 하지만 이런 성능 향상 효과를 얻으려고 맵드 메모리(Mapped Memory)를 사용할 때 글로벌 메모리의 결합 전송(Coalescing)과 동일한 조건을 커널에서 충족시켜야 한다는 제약이 있습니다. 만일 커널에서 작은 크기의 데이터를 많은 횟수로 맵드 메모리에 액세스하게 되면 통상적인 데이터 전송보다 오히려 성능이 떨어지는 효과가 나타납니다. 제로 복사 기능은 GeForce 200 시리즈 이후 계열 GPU부터 지원하며, host 측의 고정 메모리(Pinned System Memory)에 직접 읽고 쓰게 됩니다. CUDA API 함수를 이용하여 맵드 메모리를 할당하는 방법으로 제로 복사를 사용할 수 있습니다. host에 메모리를 할당하고, device 메모리 영역에서 host 측 메모리로 바로 사용할 포인터를 지정해주는 방법으로 사용합니다. 포터블 고정 메모리 (Portable Pinned Memory)고정된 메모리를 이용한 제로 복사는 싱글 스레드 영역에서 유효합니다. 하나의 GPU로 구성된 PC에서는 큰 불편함 없이 고정 메모리를 사용할 수 있지만, 복수의 GPU로 수정된 PC에서는 문제가 생길 수 있습니다. 동시에 2개 이상의 GPU를 구동시키려면 두 개 이상의 host thread를 생성하여 처리하게 되는데, 이 때 하나의 스레드에서 생성한 고정 메모리는 다른 스레드에서 사용할 수 없게 됩니다. 이러면 한정된 시스템 자원인 고정 메모리를 각각의 스레드에서 생성하여 자원을 낭비하는 결과를 낳게 됩니다. 이러한 자원 낭비를 피하고자 사용하는 방법이 바로 포터블 고정 메모리(Portable Pinned Memory)입니다. 포터블 고정 메모리를 사용하기 위해서는 CUDA API 함수에서 옵션을 바꾸어 주는 방법으로 사용할 수 있습니다. 이것으로 CUDA 메모리 성능 최적화 기법에 대한 소개가 끝났습니다. 메모리 성능은 CUDA 프로그램의 성능과 직결된 문제인만큼 다양한 관점에서 최적화 방법을 모색해야 할 것입니다. "
    }, {
    "id": 66,
    "url": "http://localhost:4000/cuda-c-extension-2/",
    "title": "[CUDA 5.0] CUDA C 확장 키워드 (CUDA C Extension) - 변수의 수식어",
    "body": "2015/04/03 - ※ 이 글은 2013년도에 작성된 글입니다. 사진이나 세부적인 내용은 지금과 다를 수 있습니다. 저번 포스팅에 이어 CUDA C extension에 관한 설명을 마무리 짓도록 하겠습니다. 변수의 수식어변수의 수식어들은 메모리 영역에 따라서 구분되어 집니다. 즉, 변수가 위치하는 메모리의 위치가 어디냐에 따라 __device__, __constant__, __shared__ 세 가지로 나뉘어집니다. 메모리에 대해서는 이후 포스팅에서 따로 자세히 설명하도록 하고, 이번 포스팅에서는 간단하게만 언급하도록 하겠습니다. __device__: 함수의 수식어인 __device__와는 다르므로 꼭 구분해 주셔야 합니다. __device__ 변수는 글로벌 메모리 영역에 할당되어 프로그램이 종료될 때까지 유효하게 됩니다. __device__ 변수에는 모든 thread가 접근할 수 있고, host에서는 API 함수를 통해 읽기와 쓰기가 가능합니다. 1234567891011121314151617181920212223#include  cuda_runtime. h #include  device_launch_parameters. h #include &lt;stdio. h&gt;__device__ int d_sum;__global__ void add(int a, int b) {  d_sum = a + b;}__host__ int main() {  int h_sum = 0;  cudaMemset(&amp;d_sum, 0, sizeof(int));  add&lt;&lt;&lt;1, 1&gt;&gt;&gt;(2, 7);  cudaMemcpyFromSymbol(&amp;h_sum, d_sum, sizeof(int), 0, cudaMemcpyDeviceToHost);  printf( 2 + 7 = %d\n , h_sum);  return 0;}__device__ 변수는 위와 같이 cudaMemcpyFromSymbol이라는 함수를 통해 host 메모리에 불러올 수 있습니다. 여기서 주의하실 점은 CUDA 5. 0부터 바뀐 점으로, 이전 버전들과는 symbol을 다른 방식으로 사용하여야 한다는 점입니다. 1  cudaMemcpyFromSymbol(&amp;h_sum,  d_sum , sizeof(int), 0, cudaMemcpyDeviceToHost);이전 방식으로 cudaMemcpyFromSymbol 함수를 호출하면 위와 같이 호출하여야 합니다. 즉, 이전 버전들에서는 symbol을 character string으로 사용하였다면, CUDA 5. 0부터는 symbol을 direct로 사용할 수 있도록 바뀌었습니다. 대신 이전 버전들과 같은 방법으로는 사용할 수 없습니다. 하지만 CUDA 5. 0에서도 symbol을 direct로 사용하였을 때, 빨간 밑줄이 그어지며 다음과 같은 error가 발생합니다만, 실제로 실행시켰을 때는 아무런 문제가 없습니다. 추후에 업데이트 되면서 사라질 문제가 될 것 같습니다.  __constant__: __constant__ 변수는 그 이름에서도 알 수 있듯이 상수 메모리, 즉 constant memory 영역에 할당되어 프로그램이 종료될 때까지 유효한 변수입니다. 모든 thread에서 접근이 가능하지만, __device__ 변수와는 다르게 __constant__ 변수는 읽기만 가능합니다. 대신 host에서 cudaMemcpyToSymbol 함수를 통해 값을 쓸 수 있도록 되어 있습니다. 1234567891011121314151617#include  cuda_runtime. h #include  device_launch_parameters. h #include &lt;stdio. h&gt;__constant__ int d_sum = 0;int main() {  int h_sum1 = 9;  int h_sum2 = 0;  cudaMemcpyToSymbol(d_sum, &amp;h_sum1, sizeof(int), 0, cudaMemcpyHostToDevice);  cudaMemcpyFromSymbol(&amp;h_sum2, d_sum, sizeof(int), 0, cudaMemcpyDeviceToHost);  printf( h_sum2 = %d\n , h_sum2);  return 0;}여기서도 주의하셔야 할 점은 CUDA 5. 0부터 cudaMemcpyToSymbol의 쓰임 역시 바뀌었다는 점입니다. 위에서 __device__ 변수를 설명하면서 언급하였던 cudaMemcpyFromSymbol 함수와 마찬가지로 symbol을 direct로 사용하도록 바뀌었습니다. 이전 버전들에서는 다음과 같이 사용하였지만, CUDA 5. 0부터는 아래 방식을 사용할 수 없습니다. 1  cudaMemcpyToSymbol( d_sum , &amp;h_sum1, sizeof(int), 0, cudaMemcpyHostToDevice);즉, 위와 같이 symbol을 character string으로 사용할 수 없습니다. __shared__: __shared__ 변수 역시 그 이름에서 알 수 잇듯 공유 메모리 영역에 할당됩니다. 다만 다른 변수들과는 달리 실행 중인 thread block 상에서만 유효하다는 것이 특징입니다. __device__ 변수나 __constant__ 변수가 프로그램이 종료될 때까지 유효한 것과는 다릅니다. 또, __shared__ 변수는 block 내의 thread는 접근하여 읽고 쓰는 것이 가능하도록 되어 있습니다. 12345678910111213141516171819202122232425#include  cuda_runtime. h #include  device_launch_parameters. h #include &lt;stdio. h&gt;__global__ void add(int a, int b, int *c) {  __shared__ int sum;  sum = a + b;  *c = sum;}int main() {  int c;  int *dev_c;  cudaMalloc((void**)&amp;dev_c, sizeof(int));  add&lt;&lt;&lt;1, 1&gt;&gt;&gt;(2, 7, dev_c);  cudaMemcpy(&amp;c, dev_c, sizeof(int), cudaMemcpyDeviceToHost);  printf( 2 + 7 = %d\n , c);  cudaFree(dev_c);  return 0;}위는 __shared__ 변수를 사용한 예시입니다. 예시에서는 단순하게 하나의 block에 하나의 thread만이 실행되는 코드이지만, 많은 thread가 실행되는 코드라면 __shared__ 변수를 유용하게 사용할 수 있을 것입니다. 이것으로 CUDA C Extension에 대한 설명을 끝내도록 하겠습니다. 메모리에 대한 상세한 설명이나 CUDA의 다른 부분에 대해서는 이후 포스팅에서 더욱 자세히 다뤄보겠습니다. "
    }, {
    "id": 67,
    "url": "http://localhost:4000/cuda-c-extension-1/",
    "title": "[CUDA 5.0] CUDA C 확장 키워드 (CUDA C Extension) - 함수의 수식어",
    "body": "2015/04/03 - ※ 이 글은 2013년도에 작성된 글입니다. 사진이나 세부적인 내용은 지금과 다를 수 있습니다. 이번 포스팅에서는 CUDA C Extension, 즉 CUDA에서 확장된 키워드들에 대하여 소개하고자 합니다. 예제 코드를 보면 __global__과 같은 키워드들을 쉽게 발견할 수 있을 것입니다. 이러한 키워드들이 어떤 의미이며 무슨 역할을 하는지 알아야 보다 효율적인 프로그래밍이 가능할 것입니다. 함수의 수식어함수의 수식어들은 어디서 호출할 수 있느냐와 어디서 실행되느냐에 따라 나뉩니다. __global__, __device__, __host__, __device__ __host__ 이렇게 총 4가지의 경우가 가능합니다. __global__: 디바이스에서 실행되는 함수를 뜻합니다. 여기서 device란 이전 포스팅에서도 언급 했듯이 GPU를 뜻합니다. __global__로 수식된 함수는 host에서 호출할 수는 있어도 device에서 호출할 수는 없습니다. 대신 device로 실행하는 커널 함수 지정에 사용할 수 있습니다. 다음은 __global__로 수식한 함수의 간단한 예입니다. 1234567891011121314151617181920212223#include  cuda_runtime. h #include  device_launch_parameters. h #include &lt;stdio . h&gt;;__global__ void add(int a, int b, int *c) {  *c = a + b;}int main() {  int c;  int *dev_c;  cudaMalloc((void**)&amp;dev_c, sizeof(int));  add&lt;&lt;&lt;1, 1&gt;&gt;&gt;(2, 7, dev_c);  cudaMemcpy(&amp;c, dev_c, sizeof(int), cudaMemcpyDeviceToHost);  printf( 2 + 7 = %d\n , c);  cudaFree(dev_c);  return 0;}위와 같이 return type은 항상 void 형이어야 하며, 다른 return type은 가질 수 없습니다. 이것은 조금만 생각해보면 쉽게 그 이유를 알 수 있습니다. 지금의 예에서는 하나의 커널 함수만이 실행되었지만, 실제로는 수천, 수만 개의 커널 함수가 한꺼번에 실행될 것입니다. 만약 __global__ 함수의 리턴 타입이 void가 아니라면 수천, 수만 개의 커널 함수에서 제각각 return 값을 host로 넘겨주게 될 것입니다. 그러한 문제를 막기 위해 아예 void 형이 아닌 다른 return type을 가질 수 없도록 한 것입니다. 또, 함수의 호출 시에 &lt;&lt;&lt; block의 개수, thread의 개수 &gt;&gt;&gt;의 형식으로 block과 thread의 개수를 지정해 줄 수 있습니다. __global__ 함수는 device에서 실행되는 함수이지만 device에서는 호출할 수 없습니다. 즉, 재귀호출이 불가능합니다. 이것 또한 이 함수가 수만 개가 한꺼번에 실행되는 커널 함수라는 것을 생각해보면 그 이유를 쉽게 알 수 있습니다. 또한 함수 내에 static 변수를 가질 수 없으며, 가변형 인수를 가질 수 없는 등의 제약 사항이 존재합니다. 가변형 인수를 가질 수 없다는 것은 다음과 같은 식으로 함수를 호출하는 코드는 불가능하다는 것을 뜻합니다. 1  add&lt;&lt;&lt;1, 1&gt;&gt;&gt;(int a, int b, dev_c);또한 __global__ __host__와 같은 용법으로 쓰일 수 없고, 공유 메모리를 이용하며 256 바이트까지의 인수를 사용할 수 있습니다. __device__: 위의 __global__과 마찬가지로 device에서 실행되는 함수를 뜻합니다. 하지만 __global__과는 다르게 host에서 호출이 불가능하고, device에서만 호출이 가능합니다. 즉, __global__ 함수가 실행되었을 때 device 내에서 실행되는 서브 함수로 사용됩니다. device에서 실행되고 device에서 호출되기 때문에 재귀 호출이 가능하지 않느냐고 생각할 수도 있지만 마찬가지로 재귀호출은 할 수 없습니다. 1234567__device__ int subAdd(int a, int b) {  return a + b;}__global__ void add(int a, int b, int *c) {  *c = subAdd(a, b);}__global__에서 예시로 들었던 add 함수의 코드를 조금만 바꾼 __device__ 함수의 예시입니다. 실행시켜 보면 똑같은 결과값이 나오는 것을 알 수 있습니다. __global__ 함수는 device 내에서 실행되는 함수이기 때문에 __device__ 함수를 호출할 수 있습니다. 하지만 host에서는 호출할 수 없기 때문에 다음과 같은 호출은 불가능합니다. 12345678910111213141516#include  cuda_runtime. h #include  device_launch_parameters. h #include &lt;stdio. h&gt;__device__ int subAdd(int a, int b) {  return a + b;}int main() {  int c;  c = subAdd(2, 7);  print( 2 + 7 = %d\n , c);  return 0;}위 코드를 실행시키면 다음과 같은 에러가 발생합니다. 1error : calling a __device__ function( subAdd ) from a __host__ function( main ) is not allowed즉, __host__ 함수인 main 함수에서 __device__ 함수인 subAdd 함수를 호출할 수 없다는 것입니다. 추가적으로, __device__ 함수 역시 __global__ 함수와 마찬가지로 static 변수를 함수 내에 가질 수 없고, 가변형 인수를 가질 수 없습니다. __host__: __host__ 함수는 위에서 언급했던 __global__이나 __device__ 함수와는 실행되는 위치부터가 다릅니다. host에서 실행되며, host에서만 호출할 수 있고, device에서는 호출할 수 없습니다. main 함수가 그 대표적인 예입니다. main 함수를 통해서 알 수 있드시, __global__, __device__, __host__ 등의 키워드가 지정되지 않은 경우에는 __host__를 지정한 것과 동일한 효과를 지닙니다. 123456789101112131415161718192021222324252627#include  cuda_runtime. h #include  device_launch_parameters. h #include &lt;stdio. h&gt;;__device__ int subAdd(int a, int b) {  return a + b;}__global__ void add(int a, int b, int *c) {  *c = subAdd(a, b);}__host__ int main() {  int c;  int *dev_c;  cudaMalloc((void**)&amp;dev_c, sizeof(int));  add&lt;&lt;&lt;1, 1&gt;&gt;&gt;(2, 7, dev_c);  cudaMemcpy(&amp;c, dev_c, sizeof(int), cudaMemcpyDeviceToHost);  printf( 2 + 7 = %d\n , c);  cudaFree(dev_c);  return 0;}위의 코드처럼 main 함수를 __host__로 지정해주어도 아무런 문제 없이 잘 실행이 됩니다. 이는 main 함수가 __host__ 함수이기 때문이며, 어떤 함수인지 지정해주지 않았을 때는 default로 __host__로 지정되기 때문입니다. __host__ 수식어는 __global__ 수식어와 동시에 사용할 수는 없지만, __device__ 수식어와는 함께 사용할 수 있습니다. 바로 __device__ __host__와 같은 방법으로 사용하는 것인데요. 이에 대해서는 아래에서 따로 설명하도록 하겠습니다. __device__ __host__: __host__ 수식어와 __device__ 수식어를 동시에 사용한 경우입니다. 이 경우 host와 device 양쪽에서 모두 사용할 수 있는 함수로 작성할 수 있습니다. 1234567891011121314151617#include  cuda_runtime. h #include  device_launch_parameters. h #include &lt;stdio. h&gt;;__device__ __host__ int subAdd(int a, int b) {  return a + b;}int main() {  int c;  c = subAdd(2, 7);  printf( 2 + 7 = %d\n , c);  return 0;}위 코드를 실행시키면 역시나 아무런 문제 없이 잘 동작합니다. 이는 subAdd 함수가 host와 device 모두에서 사용할 수 있는 함수이기 때문입니다. 이러한 수식어를 사용하는 것이 무척이나 편리한 경우가 가끔 생기는데, host와 device 모두에서 호출하는 간단한 계산 같은 것을 __device__ __host__ 함수로 지정하여 사용하는 경우가 있습니다. 같은 내용의 함수를 device 용, host 용으로 두 개나 만들지 않고, 하나의 함수로 해결하는 것입니다. 그 때문에 device와 host 모두에서 사용가능한 함수가 필요했고, 이 함수는 host와 device 각각 호출이 가능하며, 호출된 곳(host라면 host, device라면 device)에서 실행될 필요가 있었습니다. 따라서 __global__ 키워드는 제외되고, __device__ __host__와 같은 형식으로 device와 host 모두에서 사용 가능하도록 만들어진 것입니다. 포스팅의 내용이 길어서 CUDA C 확장 키워드에 대해서 다음 포스팅에서 이어서 설명하도록 하겠습니다. 다음 포스팅에서는 변수의 수식어에 대해 이야기하도록 하겠습니다. "
    }, {
    "id": 68,
    "url": "http://localhost:4000/cuda-syntax-device/",
    "title": "[CUDA 5.0] CUDA syntax를 이용하여 device 정보 불러오기",
    "body": "2015/04/02 - ※ 이 글은 2013년도에 작성된 글입니다. 사진이나 세부적인 내용은 지금과 다를 수 있습니다. 본격적인 CUDA 코딩에 앞서 CUDA syntax를 이용하여 device의 정보를 불러오는 방법에 대해 소개하려고 합니다. 여기서 말하는 device란 CUDA acceleration(CUDA 가속)을 지원하는 GPU를 뜻합니다. 아래의 코드는 CUDA syntax를 이용하여 device의 정보를 불러와 출력하는 내용입니다. 123456789101112131415161718192021222324252627#include  cuda_runtime. h #include  device_launch_parameters. h #include &lt;stdio. h&gt;int main() {  int i;  cudaDeviceProp prop;  int count;  cudaGetDeviceCount(&amp;count);  for (i = 0 ; i &lt; count ; i++) {    cudaGetDeviceProperties(&amp;prop, i);    printf( -- %d번째 디바이스 --\n , i+1);    printf(  (1) 장치 이름 : %s\n , prop. name);    printf(  (2) Clock Rate : %d\n , prop. clockRate);    printf(  (3) 전역 메모리 용량 : %ld\n , prop. totalGlobalMem);    printf(  (4) 상수 메모리 용량 : %ld\n , prop. totalConstMem);    printf(  (5) Register per block : %d\n , prop. regsPerBlock);    printf(  (6) Max Grid Size : %d\n , prop. maxGridSize);    printf(  (7) Max Thread Dimension : %d\n , prop. maxThreadsDim);    printf(  (8) Max Thread per block : %d\n , prop. maxThreadsPerBlock);  }  return 0;}CUDA는 cudaDeviceProp이라는 구조체 형식에 device들의 정보를 저장하게 됩니다. 이를 이용하면 device의 다양한 정보를 불러올 수 있습니다. 아래는 위 코드를 실행시킨 결과입니다.  출력된 결과를 살펴보면, GeForce GT 750M이라는 하나의 device를 사용 중이며, clock rate나 메모리 용량이 얼마인지 알 수 있습니다. cudaDeviceProp은 이외에도 다양한 정보를 제공합니다. 이러한 데이터를 잘 활용하면 효과적인 CUDA 코딩을 할 수 있을 것입니다. 그러면 위 코드를 자세히 살펴봅시다. 1  cudaDeviceProp prop;Device property의 출력을 위해 구조체를 생성한 것입니다. 위에서 잠깐 언급했듯이 CUDA는 device의 정보를 구조체 형식에 저장합니다. cudaDeviceProp 구조체는 driver_types. h 파일에 선언되어 있으며, 이러한 header file들은 CUDA project를 생성하면 외부 종속성 폴더에 추가되도록 되어 있습니다. 아래는 cudaDeviceProp 구조체의 선언 부분입니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * CUDA device properties */struct __device_builtin__ cudaDeviceProp{  char  name[256];         /**&lt; ASCII string identifying device */  size_t totalGlobalMem;       /**&lt; Global memory available on device in bytes */  size_t sharedMemPerBlock;     /**&lt; Shared memory available per block in bytes */  int  regsPerBlock;        /**&lt; 32-bit registers available per block */  int  warpSize;          /**&lt; Warp size in threads */  size_t memPitch;          /**&lt; Maximum pitch in bytes allowed by memory copies */  int  maxThreadsPerBlock;     /**&lt; Maximum number of threads per block */  int  maxThreadsDim[3];      /**&lt; Maximum size of each dimension of a block */  int  maxGridSize[3];       /**&lt; Maximum size of each dimension of a grid */  int  clockRate;         /**&lt; Clock frequency in kilohertz */  size_t totalConstMem;       /**&lt; Constant memory available on device in bytes */  int  major;           /**&lt; Major compute capability */  int  minor;           /**&lt; Minor compute capability */  size_t textureAlignment;      /**&lt; Alignment requirement for textures */  size_t texturePitchAlignment;   /**&lt; Pitch alignment requirement for texture references bound to pitched memory */  int  deviceOverlap;       /**&lt; Device can concurrently copy memory and execute a kernel. Deprecated. Use instead asyncEngineCount. */  int  multiProcessorCount;    /**&lt; Number of multiprocessors on device */  int  kernelExecTimeoutEnabled;  /**&lt; Specified whether there is a run time limit on kernels */  int  integrated;         /**&lt; Device is integrated as opposed to discrete */  int  canMapHostMemory;      /**&lt; Device can map host memory with cudaHostAlloc/cudaHostGetDevicePointer */  int  computeMode;        /**&lt; Compute mode (See ::cudaComputeMode) */  int  maxTexture1D;        /**&lt; Maximum 1D texture size */  int  maxTexture1DMipmap;     /**&lt; Maximum 1D mipmapped texture size */  int  maxTexture1DLinear;     /**&lt; Maximum size for 1D textures bound to linear memory */  int  maxTexture2D[2];      /**&lt; Maximum 2D texture dimensions */  int  maxTexture2DMipmap[2];   /**&lt; Maximum 2D mipmapped texture dimensions */  int  maxTexture2DLinear[3];   /**&lt; Maximum dimensions (width, height, pitch) for 2D textures bound to pitched memory */  int  maxTexture2DGather[2];   /**&lt; Maximum 2D texture dimensions if texture gather operations have to be performed */  int  maxTexture3D[3];      /**&lt; Maximum 3D texture dimensions */  int  maxTextureCubemap;     /**&lt; Maximum Cubemap texture dimensions */  int  maxTexture1DLayered[2];   /**&lt; Maximum 1D layered texture dimensions */  int  maxTexture2DLayered[3];   /**&lt; Maximum 2D layered texture dimensions */  int  maxTextureCubemapLayered[2];/**&lt; Maximum Cubemap layered texture dimensions */  int  maxSurface1D;        /**&lt; Maximum 1D surface size */  int  maxSurface2D[2];      /**&lt; Maximum 2D surface dimensions */  int  maxSurface3D[3];      /**&lt; Maximum 3D surface dimensions */  int  maxSurface1DLayered[2];   /**&lt; Maximum 1D layered surface dimensions */  int  maxSurface2DLayered[3];   /**&lt; Maximum 2D layered surface dimensions */  int  maxSurfaceCubemap;     /**&lt; Maximum Cubemap surface dimensions */  int  maxSurfaceCubemapLayered[2];/**&lt; Maximum Cubemap layered surface dimensions */  size_t surfaceAlignment;      /**&lt; Alignment requirements for surfaces */  int  concurrentKernels;     /**&lt; Device can possibly execute multiple kernels concurrently */  int  ECCEnabled;         /**&lt; Device has ECC support enabled */  int  pciBusID;          /**&lt; PCI bus ID of the device */  int  pciDeviceID;        /**&lt; PCI device ID of the device */  int  pciDomainID;        /**&lt; PCI domain ID of the device */  int  tccDriver;         /**&lt; 1 if device is a Tesla device using TCC driver, 0 otherwise */  int  asyncEngineCount;      /**&lt; Number of asynchronous engines */  int  unifiedAddressing;     /**&lt; Device shares a unified address space with the host */  int  memoryClockRate;      /**&lt; Peak memory clock frequency in kilohertz */  int  memoryBusWidth;       /**&lt; Global memory bus width in bits */  int  l2CacheSize;        /**&lt; Size of L2 cache in bytes */  int  maxThreadsPerMultiProcessor;/**&lt; Maximum resident threads per multiprocessor */};위와 같이 선언되어 있는데, 각각 어떤 것을 의미하는지는 각 항목마다 설명이 주석처리 되어 있으므로 자세한 설명은 하지 않겠습니다. 앞서 출력해 보았던 내용 이외에도 엄청나게 많은 정보들을 저장하고 있지만, 가장 많이 쓰이게 될 몇 가지 정보들만 출력해 보았습니다. 12  int count;  cudaGetDeviceCount(&amp;count);device 장치의 개수를 획득하는 함수입니다. int 형 변수인 count를 만들고, 그것의 주소값을 argument로 넘겨주게 됩니다. cudaGetDeviceCount 함수는 cuda_runtime_api. h에 다음과 같이 정의되어 있습니다. 1extern __host__ __cudart_builtin__ cudaError_t CUDARTAPI cudaGetDeviceCount(int *count);parameter로 count의 포인터를 넘겨 받기 때문에 호출 시 argument의 사용에 주의해 주셔야 합니다. 함수의 이름에서 알 수 있다시피 count 변수에는 device의 개수 값이 들어갑니다. CUDA 뿐만이 아니라 다른 언어나 tool을 공부할 때에도 마찬가지로, 어떤 함수를 사용할 때 그것이 어떻게 정의되어 있는지 내부를 공부하는 것은 무척이나 많은 도움이 됩니다. 특히나 CUDA는 C 기반으로 짜여져 있는데다 주석도 잘 달려 있어 공부하기 편리합니다. 이렇게 CUDA syntax를 이용하여 device의 정보를 출력하는 방법에 대해 알아보았습니다. 이후 포스팅에서 CUDA 병렬 프로그래밍에 대해 더 자세히 알아보도록 하겠습니다. "
    }, {
    "id": 69,
    "url": "http://localhost:4000/cuda-syntax-highlighting/",
    "title": "[CUDA 5.0] CUDA Syntax Highlighting 설정하기",
    "body": "2015/04/01 - ※ 이 글은 2013년도에 작성된 글입니다. 사진이나 세부적인 내용은 지금과 다를 수 있습니다. VS에서 CUDA 코드를 작성하면 CUDA Syntax Highlighting은 물론이고 기본적인 C/C++ 문법마저도 Syntax Highlighting이 되지 않아 코드를 작성하기 무척이나 번거롭고 힘들었을 것입니다. 따라서, 이번 포스팅에서는 CUDA Syntax Highlighting 방법에 대해 소개하려 합니다. 이전 버전들과는 방법이 다르기 때문에, 다른 버전을 사용 중이라면 적용되지 않을 수도 있다는 점을 염두에 두시길 바랍니다. 우선 VS를 켜고, 상단 메뉴 바에서 도구 -&gt; 옵션으로 들어갑니다. 창이 하나 나타나는데, 여기서 프로젝트 및 솔루션 -&gt; VC++ 프로젝트 설정으로 들어가면 아래의 창 같은 화면이 뜹니다. 이 중 포함할 확장명에 . cu; cuh;를 추가합니다. 확장자명끼리의 구분은 ;로 구분하게 됩니다. . cu 파일은 CUDA source file이고, . cuh 파일은 CUDA header file입니다.  확장명에 추가했으면 이제 . cu와 . cuh를 C++ 편집 환경으로 설정해 줄 차례입니다. 옵션 창에서 텍스트 편집기 -&gt; 파일 확장명으로 들어가면, 아래와 같은 창이 나타납니다. 여기에 확장명 . cu, 편집기 Microsoft Visual C++을 선택하고 적용하면 됩니다. . cuh도 마찬가지 방법으로 적용해 줍니다.  이제 C:\ProgramData\NVIDIA Corporation\CUDA Samples\v5. 0\doc\syntax_highlighting\visual_studio_8 폴더로 들어가보면 usertype. dat 파일이 있을 것입니다. 이 파일을 C:\Program Files\Microsoft Visual Studio 10. 0\Common7\IDE 폴더에 복사해 넣으면 됩니다. 주소는 32bit 기준이므로, 64bit라면 Program Files (x86) 폴더에서 찾아 복사해 넣도록 합니다.  이것으로 CUDA Syntax Highlighting 준비가 모두 끝났습니다. VS를 다시 시작하거나 아니면 프로젝트를 다시 열면 문법에 맞는 색깔로 설정된 C/C++ 코드를 볼 수 있을 것입니다. 참고로, CUDA Syntax Highlighting을 위해서는 아래의 두 줄을 추가로 입력해 주어야지만 정상적으로 표현이 됩니다. 12#include  cuda_runtime. h #include  device_launch_parameters. h 이 두 줄은 모두 CUDA Project를 생성하면 만들어지는 kernel. cu에 포함되어 있습니다.  위는 정상적으로 CUDA Syntax Highlighting이 적용된 코드입니다. __global__이나 threadIdx와 같은 CUDA 문법들에도 highlighting이 적용된 것을 확인할 수 있습니다. 참고로 위 화면에서는 다른 테마가 적용되어 있으므로, 실제로 highlighting을 적용했을 때 다르게 보일 수 있습니다. "
    }, {
    "id": 70,
    "url": "http://localhost:4000/cuda-samples/",
    "title": "[CUDA 5.0] CUDA 예제 실행하기",
    "body": "2015/03/31 - ※ 이 글은 2013년도에 작성된 글입니다. 사진이나 세부적인 내용은 지금과 다를 수 있습니다. CUDA 5. 0을 설치하고, 리부팅을 하고 나면 NVIDIA CUDA Samples Browser v5. 0 아이콘이 생겼을 것입니다. 이름만으로도 어떤 프로그램인지 감이 오시나요? CUDA 5. 0부터는 Installer에 samples 또한 포함이 되어 있다고 저번 포스팅에서 언급하였습니다. 이 프로그램이 바로 설치와 같이 다운 받은 예제 파일들을 찾아보고, 실행해 볼 수 있는 프로그램입니다. 한 번 실행해 봅시다.  실행하면 보이는 바와 같이 다양한 샘플들을 찾아볼 수 있고, 실행시켜 볼 수도 있습니다. 이 샘플들을 실행시켰을 때, 아무 무리 없이 잘 돌아가면 설치가 제대로 되었다는 뜻입니다. 만약 실행이 되지 않는다면, 컴퓨터에 설치되어 있는 GPU가 CUDA 가속을 지원하는지를 확인하고, 또 NVIDIA 그래픽 드라이버가 최신 버전인지를 확인해 주세요. 이 중 CUDA N-Body Simulation을 실행시켜 봅시다. N-Body가 무엇인지 몰라도 어떤 프로그램인지는 그래픽으로 시뮬레이션해주기 때문에 알아보기 쉽습니다. 실행하는 방법은 오른쪽 편에 작은 글씨로 된 Run을 누르면 됩니다. 실행하면 다음과 같은 창 하나가 뜹니다. 이 창에서는 프로그램에 대한 간단한 설명 등과 함께 맨 아래쪽에 보면 어떤 device를 사용하고 있는지에 대한 정보도 같이 볼 수 있습니다. simulation을 위해 하나의 device를 사용하였고, 그 device는 GeForce 310M이라는 정보가 뜹니다. 이 정보는 각자 사용하는 GPU에 따라 다르게 나타날 것입니다.  그리고 하나 더 뜨는 창에서는 다음과 같이 N-Body Simulation이 이루어집니다. 현재 시뮬레이션 되고 있는 상태에 대해서는 화면 위쪽에 나타나게 되고, 화면 전체에 N-Body Simulation이 약간의 끊김이 있기는 하지만 빠르고 매끄럽게 진행되는 것을 확인할 수 있습니다. 심지어 310M이라는 낮은 사양의 GPU에서도 말이죠.  NVIDA CUDA Samples Browser에서는 이러한 N-Body Simulation 이외에도 다양한 예제들을 실행시켜 볼 수 있습니다. 그리고 이러한 예제들의 코드 역시 같이 다운받아져 있는데, 이 코드들은 C:\ProgramData\NVIDIA Corporation\CUDA Samples\v5. 0 폴더에 잘 정리되어 있습니다. ProgramData 폴더는 숨겨져 있는 폴더이므로 C 드라이브에 들어갔는데 폴더가 없다고 당황하지 않으셔도 됩니다. 위 주소로 들어가보면 다음과 같이 잘 정리된 CUDA 예제들의 코드를 확인하고, 직접 실행시켜 볼 수 있습니다.  아까 위에서 실행시켜 보았던 N-Body Simulation은 5_Simulation 폴더에 nbody라는 이름으로 들어가 있습니다. VS에서 실행시켜 보면 앞서 실행시켰던 것과 같은 결과가 나오는 것을 확인할 수 있습니다. 예제 파일들은 간단한 것부터 복잡하고 어려운 계산이나 그래픽을 요하는 것까지 다양하게 제공되므로, 예제 파일을 분석하며 공부하는 것도 많은 도움이 될 것입니다. CUDA를 공부하면 C/C++로 이미 만들어져 있는 프로그램을 포팅하는 것을 주로 하게 되고, 어떻게 최적화를 하느냐에 따라 같은 내용을 실행시키더라도 성능이 확연하게 달라질 수 있습니다. 따라서 이미 잘 짜여져 있는 성능 좋은 코드를 많이 보는 것이 공부에 도움이 될 것입니다. CUDA Project는 C/C++ Project를 그대로 이용해도 상관 없으나, VS에서는 CUDA를 설치하면 다음과 같이 CUDA 5. 0 Runtime Project를 바로 생성할 수 있도록 해 줍니다.  CUDA 5. 0 Rumtime Project를 생성하면 따로 무언가를 설정할 필요 없이 바로 컴파일이나 빌드를 할 수 있도록 되어 있습니다. 생성하면 kernel. cu라는 소스 파일 하나가 공통적으로 들어가 있는데요. 여기에는 1차원 array를 더하는 내용의 코드가 포함되어 있습니다. 무척 간단한 코드로 실행시켜 보면 다음과 같은 결과가 출력됩니다.  이것으로 CUDA 예제를 가능한 모든 방법을 동원하여 실행하여 보았습니다. CUDA는 아직 한글로 번역된 책이 많이 없기 때문에 이미 만들어져 있는 예제들을 보면서 실행시켜 보고, 스스로 분석하고, 다른 코드를 CUDA로 포팅해보는 연습을 하다 보면 실력이 많이 느는 것을 확인할 수 있을 것입니다. 자, 이렇게 CUDA 5. 0을 사용하여 코딩할 준비가 모두 끝났습니다. 다음 포스팅에서는 위 화면에 보이는 바와 같이 CUDA Syntax Highlighting 하는 방법에 대해서 이야기하도록 하겠습니다. "
    }, {
    "id": 71,
    "url": "http://localhost:4000/cuda-install/",
    "title": "[CUDA 5.0] CUDA 설치하기",
    "body": "2015/03/30 - ※ 이 글은 2013년도에 작성된 글입니다. 사진이나 세부적인 내용은 지금과 다를 수 있습니다. CUDA 5. 0은 이전 버전들과는 달리 설치가 매우 간편해진 것이 특징입니다. NVIDIA 사이트에서 CUDA ZONE을 들어가면 영어로 된 developer zone이 나오는데, 여기서 CUDA Download를 클릭해 들어가면 다음과 같은 페이지가 뜹니다. 참고로, NVIDIA Korea 사이트에서는 한글 번역을 지원해주지만 developer zone은 한글 번역을 지원해주지 않습니다. 또, 한국 사이트에서는 낮은 버전의 CUDA를 다운받게 되므로 꼭 원래 사이트에 들어가서 다운 받아 주세요.  여기서 Desktop/Notebook의 OS 등에 맞는 파일을 클릭하여 다운 받을 수 있습니다. CUDA 5. 0부터는 CUDA Toolkit과 SDK code samples, developer driver를 모두 한꺼번에 다운 받아 설치할 수 있어 무척이나 간편하게 설치할 수 있게 되어 있습니다. 다운 받은 installer를 실행하면 설치가 끝납니다. 설치가 끝나면 컴퓨터를 리부팅해야 CUDA를 사용할 수 있습니다. 자신의 GPU가 CUDA 가속을 지원하는 지에 대해서는 CUDA ZONE에서 CUDA GPUs를 들어가면 확인할 수 있습니다. Tesla, Quadro, NVS, GeForce 순으로 나와 있습니다. 현재는 대부분의 GPU들이 CUDA 가속을 지원합니다.  한 가지 더. CUDA를 사용하기 위해서는 그래픽 드라이버가 최신 버전이어야 합니다. NVIDIA 사이트에서 다운 받을 수 있으니 최신 버전인지를 확인하고 업데이트 하도록 합시다. 혹시 이후에 실행을 시켰는데 되지 않는다면 그래픽 드라이버가 최신 버전이 아니기 때문일 수도 있습니다. 자, 이렇게 CUDA 5. 0을 설치하여 사용할 준비가 끝났습니다. CUDA 5. 0에서는 다양한 예제 파일들을 같이 다운 받았기 때문에 그것들을 실행시켜 볼 수 있습니다. 예제 파일의 실행에 대해서는 다음 포스팅 때 이야기하도록 하겠습니다. "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-danger btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});