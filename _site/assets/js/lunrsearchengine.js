
var documents = [{
    "id": 0,
    "url": "http://localhost:4000/404.html",
    "title": "404",
    "body": "404 Page does not exist!Please use the search bar at the top or visit our homepage! "
    }, {
    "id": 1,
    "url": "http://localhost:4000/categories",
    "title": "Categories",
    "body": ""
    }, {
    "id": 2,
    "url": "http://localhost:4000/",
    "title": "Home",
    "body": "      Featured:                                                                                                                                                                                                                     Python의 super 키워드와 다중 상속                              :               파이썬의 객체 지향 프로그래밍(OOP)에서 상속은 코드의 재사용성을 높이는 중요한 개념입니다. 이때 부모 클래스의 메서드를 자식 클래스에서 호출해야 하는 경우가 자주 발생합니다. 이러한 상황에서 super 키워드는. . . :                                                                                                                                                                         Chloe Jungah Kim                                    25 Jul 2024                                                                                                                                                                                                                                                                                            Python에서 class 다루기                              :               클래스(class)는 객체 지향 프로그래밍(Object-Oriented Programming, OOP)을 구현하는 데 핵심적인 역할을 하고 있습니다. 클래스는 객체 지향 프로그래밍에서 객체를 생성하기 위한 blueprint입니다. 클래스는 속성(attributes)과 메서드(methods)를 정의하며, 이를. . . :                                                                                                                                                                         Chloe Jungah Kim                                    24 Jul 2024                                                                                                                                                                                                                                                                                            Python의 자료형 살펴보기                              :               파이썬은 많은 개발자들에게 사랑 받는 프로그래밍 언어입니다. 파이썬을 잘 사용하기 위해서는 자료형(data type)을 이해하는 것이 무엇보다 중요합니다. 이번 포스팅에서는 파이썬의 자료형에 대해 자세히 알아보도록 하겠습니다. . . . :                                                                                                                                                                         Chloe Jungah Kim                                    23 Jul 2024                                                                                                                                                                                                                                                                                            Python의 배열(Array) - 효율적인 데이터 처리하기                              :               파이썬은 다양한 자료형(data type)을 제공합니다. 그 중에서도 배열(Array)은 확장 자료형으로 효율적인 데이터 처리를 위해 반드시 알아야 할 중요한 개념입니다. 이번 포스팅에서는 파이썬의 배열에 대해 자세히. . . :                                                                                                                                                                         Chloe Jungah Kim                                    23 Jul 2024                                                                                              All Stories:                                                                                                     Python의 super 키워드와 다중 상속              :       파이썬의 객체 지향 프로그래밍(OOP)에서 상속은 코드의 재사용성을 높이는 중요한 개념입니다. 이때 부모 클래스의 메서드를 자식 클래스에서 호출해야 하는 경우가 자주 발생합니다. 이러한 상황에서 super 키워드는 매우 유용하게 사용됩니다. super 키워드는. . . :                                                                               Chloe Jungah Kim                25 Jul 2024                                                                                                                    Python에서 class 다루기              :       클래스(class)는 객체 지향 프로그래밍(Object-Oriented Programming, OOP)을 구현하는 데 핵심적인 역할을 하고 있습니다. 클래스는 객체 지향 프로그래밍에서 객체를 생성하기 위한 blueprint입니다. 클래스는 속성(attributes)과 메서드(methods)를 정의하며, 이를 통해 객체의 상태와 동작을 기술합니다. . . . :                                                                               Chloe Jungah Kim                24 Jul 2024                                                                                                                    Python의 자료형 살펴보기              :       파이썬은 많은 개발자들에게 사랑 받는 프로그래밍 언어입니다. 파이썬을 잘 사용하기 위해서는 자료형(data type)을 이해하는 것이 무엇보다 중요합니다. 이번 포스팅에서는 파이썬의 자료형에 대해 자세히 알아보도록 하겠습니다. :                                                                               Chloe Jungah Kim                23 Jul 2024                                                                                                                    Python의 배열(Array) - 효율적인 데이터 처리하기              :       파이썬은 다양한 자료형(data type)을 제공합니다. 그 중에서도 배열(Array)은 확장 자료형으로 효율적인 데이터 처리를 위해 반드시 알아야 할 중요한 개념입니다. 이번 포스팅에서는 파이썬의 배열에 대해 자세히 알아보겠습니다. :                                                                               Chloe Jungah Kim                23 Jul 2024                                                                                                                    Python Lambda Function에 대하여              :       파이썬에서는 람다 함수(lambda function)를 사용하여 익명 함수(Anonymous Function)를 간단하게 정의할 수 있습니다. 람다 함수는 이름이 없는 함수로, 주로 짧은 코드 블럭에서 일회성으로 사용됩니다. 이번 포스팅에서는 파이썬 람다 함수의 개념과 사용법,. . . :                                                                               Chloe Jungah Kim                22 Jul 2024                                                                                                                    Python에서의 고차 함수 (feat. map, filter, reduce)              :       프로그래밍 언어에서 고차 함수(Higher-order function)는 함수를 인자로 받거나, 함수를 반환하는 함수를 의미합니다. 이러한 함수들은 함수형 프로그래밍의 핵심 요소로, 코드의 재사용성과 가독성을 높이는 데 큰 역할을 합니다. 특히 파이썬에서는 고차 함수를. . . :                                                                               Chloe Jungah Kim                21 Jul 2024                               &laquo; Prev       1        2        3        4        5        6        7        8        9        10        11        12        13        14        15      Next &raquo; "
    }, {
    "id": 3,
    "url": "http://localhost:4000/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 4,
    "url": "http://localhost:4000/page2/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:         {% assign count = 0 %}  {% for post in site. posts %}    {% if post. featured == true %}      {% assign count = count | plus: 1 %}      {% include featuredbox. html %}    {% endif %}    {% if count == 4 %}      {% break %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 5,
    "url": "http://localhost:4000/page3/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:         {% assign count = 0 %}  {% for post in site. posts %}    {% if post. featured == true %}      {% assign count = count | plus: 1 %}      {% include featuredbox. html %}    {% endif %}    {% if count == 4 %}      {% break %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 6,
    "url": "http://localhost:4000/page4/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:         {% assign count = 0 %}  {% for post in site. posts %}    {% if post. featured == true %}      {% assign count = count | plus: 1 %}      {% include featuredbox. html %}    {% endif %}    {% if count == 4 %}      {% break %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 7,
    "url": "http://localhost:4000/page5/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:         {% assign count = 0 %}  {% for post in site. posts %}    {% if post. featured == true %}      {% assign count = count | plus: 1 %}      {% include featuredbox. html %}    {% endif %}    {% if count == 4 %}      {% break %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 8,
    "url": "http://localhost:4000/page6/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:         {% assign count = 0 %}  {% for post in site. posts %}    {% if post. featured == true %}      {% assign count = count | plus: 1 %}      {% include featuredbox. html %}    {% endif %}    {% if count == 4 %}      {% break %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 9,
    "url": "http://localhost:4000/page7/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:         {% assign count = 0 %}  {% for post in site. posts %}    {% if post. featured == true %}      {% assign count = count | plus: 1 %}      {% include featuredbox. html %}    {% endif %}    {% if count == 4 %}      {% break %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 10,
    "url": "http://localhost:4000/page8/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:         {% assign count = 0 %}  {% for post in site. posts %}    {% if post. featured == true %}      {% assign count = count | plus: 1 %}      {% include featuredbox. html %}    {% endif %}    {% if count == 4 %}      {% break %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 11,
    "url": "http://localhost:4000/page9/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:         {% assign count = 0 %}  {% for post in site. posts %}    {% if post. featured == true %}      {% assign count = count | plus: 1 %}      {% include featuredbox. html %}    {% endif %}    {% if count == 4 %}      {% break %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 12,
    "url": "http://localhost:4000/page10/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:         {% assign count = 0 %}  {% for post in site. posts %}    {% if post. featured == true %}      {% assign count = count | plus: 1 %}      {% include featuredbox. html %}    {% endif %}    {% if count == 4 %}      {% break %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 13,
    "url": "http://localhost:4000/page11/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:         {% assign count = 0 %}  {% for post in site. posts %}    {% if post. featured == true %}      {% assign count = count | plus: 1 %}      {% include featuredbox. html %}    {% endif %}    {% if count == 4 %}      {% break %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 14,
    "url": "http://localhost:4000/page12/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:         {% assign count = 0 %}  {% for post in site. posts %}    {% if post. featured == true %}      {% assign count = count | plus: 1 %}      {% include featuredbox. html %}    {% endif %}    {% if count == 4 %}      {% break %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 15,
    "url": "http://localhost:4000/page13/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:         {% assign count = 0 %}  {% for post in site. posts %}    {% if post. featured == true %}      {% assign count = count | plus: 1 %}      {% include featuredbox. html %}    {% endif %}    {% if count == 4 %}      {% break %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 16,
    "url": "http://localhost:4000/page14/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:         {% assign count = 0 %}  {% for post in site. posts %}    {% if post. featured == true %}      {% assign count = count | plus: 1 %}      {% include featuredbox. html %}    {% endif %}    {% if count == 4 %}      {% break %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 17,
    "url": "http://localhost:4000/page15/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:         {% assign count = 0 %}  {% for post in site. posts %}    {% if post. featured == true %}      {% assign count = count | plus: 1 %}      {% include featuredbox. html %}    {% endif %}    {% if count == 4 %}      {% break %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 18,
    "url": "http://localhost:4000/python-super-multiple-inheritance/",
    "title": "Python의 super 키워드와 다중 상속",
    "body": "2024/07/25 - 파이썬의 객체 지향 프로그래밍(OOP)에서 상속은 코드의 재사용성을 높이는 중요한 개념입니다. 이때 부모 클래스의 메서드를 자식 클래스에서 호출해야 하는 경우가 자주 발생합니다. 이러한 상황에서 super 키워드는 매우 유용하게 사용됩니다. super 키워드는 자식 클래스에서 부모 클래스의 메서드를 호출할 때 사용됩니다. 이를 통해 자식 클래스는 부모 클래스의 메서드를 재사용하거나 확장할 수 있습니다. 또, 파이썬은 다중 상속을 지원하는데, 다중 상속에서 발생할 수 있는 문제를 MRO를 통해 해결하게 됩니다. 이번 포스팅에서는 super 키워드와 파이썬의 다중 상속에 대해 자세히 알아보겠습니다. super 키워드 기본 사용법super 키워드는 주로 클래스의 생성자 메서드인 __init__ 메서드 내에서 사용되지만, 그 외의 메서드에서도 부모 클래스의 메서드를 호출하는 데 사용할 수 있습니다. 다음은 super 키워드를 사용하여 부모 클래스의 __init__ 메서드를 호출하는 간단한 예제입니다. 123456789101112class Animal :  def __init__(self, anme) :    self. name = nameclass Dog(Animal) :  def __init__(self, name, breed) :    super(). __init__(name)    self. breed = breeddog = Dog( Buddy ,  Golden Retriever )print(dog. name) # Buddyprint(dog. breed) # Golden Retrieversuper 키워드는 부모 클래스의 다른 메서드를 호출하는 데도 사용할 수 있습니다. 다음은 super키워드를 사용하여 부모 클래스의 다른 메서드를 호출하는 예제입니다. 123456789101112131415161718class Animal :  def __init__(self, name) :    self. name = name    def make_sound(self) :    return  Some generic sound class Dog(Animal) :  def __init__(self, name, breed) :    super(). __init__(name)    self. breed = breed    def make_sound(self) :    original_sound = super(). make_sound()    return f {original_sound} and Woof! dog = Dog( Buddy ,  Golden Retriever )print(dog. make_sound()) # Some generic sound and Woof!다중 상속과 super 키워드파이썬은 다중 상속을 지원하기 때문에 한 클래스가 여러 부모 클래스를 가질 수 있습니다. super 키워드는 다중 상속 시 메서드 호출 순서를 관리하는 데 중요한 역할을 합니다. 이를 메서드 탐색 순서(Method Resolution Order, MRO)라고 합니다. 다음은 다중 상속과 super 키워드를 사용한 예제입니다. 123456789101112131415161718192021class A :  def __init__(self, name) :    self. name = name    def make_sound(self) :    return f My name is {self. name}.  class B(A) :    def make_sound(self) :    return f I'm {self. name}.  class C(A) :    def make_sound(self) :    return f Hi, I'm {self. name}.  class D(B, C) :    def make_sound(self) :    return f {super(). make_sound()} Nice to meet you.  person = D( Alice )print(person. make_sound()) # I'm Alice. Nice to meet you. 위 예제는 일명 다이아몬드 상속이라고 불리는 케이스입니다. 클래스 B와 C는 둘 다 클래스 A를 상속 받고, 클래스 D는 클래스 B와 C를 상속 받아서 만들어졌습니다. 그리고 모든 클래스들이 make_sound 메서드가 있는 경우인데요. 이 경우에 클래스 D의 super 메서드는 클래스 B의 make_sound 메서드를 호출한 것을 확인할 수 있습니다. 메서드 탐색 순서 (MRO): 파이썬에서는 super 키워드가 어떤 메서드를 우선해서 호출하는지는 메서드 탐색 순서(MRO)를 따릅니다. MRO는 __mro__ 속성이나 mro() 메서드를 호출하여 확인할 수 있습니다. 12345&gt;&gt;&gt; print(D. __mro__)(&lt;class '__main__. D'&gt;, &lt;class '__main__. B'&gt;, &lt;class '__main__. C'&gt;, &lt;class '__main__. A'&gt;, &lt;class 'object'&gt;)&gt;&gt;&gt; print(D. mro())[&lt;class '__main__. D'&gt;, &lt;class '__main__. B'&gt;, &lt;class '__main__. C'&gt;, &lt;class '__main__. A'&gt;, &lt;class 'object'&gt;]위 예제에서 D 클래스의 MRO는 다음과 같습니다. MRO는 왼쪽에서 오른쪽 순으로 메서드를 찾게 됩니다. 파이썬은 다중 상속을 하는 경우, 부모 클래스의 목록 중에서 왼쪽에 있는 클래스들을 우선합니다. 즉, class D(B, C)와 같이 선언되었다면, 클래스 B가 클래스 C보다 우선하게 됩니다. 파이썬의 super 키워드는 객체 지향 프로그래밍에서 상속을 활용하여 코드의 재사용성과 확장성을 높이는 데 중요한 역할을 합니다. super 키워드를 사용하면 부모 클래스의 메서드를 호출하고 확장할 수 있으며, 다중 상속 시에도 사용이 가능합니다. 파이썬은 다중 상속을 지원하며, MRO를 통해 다중 상속 시에 발생할 수 있는 문제들을 해결합니다. 이번 포스팅이 파이썬의 super 키워드와 다중 상속에 대해 이해하는 데 도움이 되셨기를 바랍니다. "
    }, {
    "id": 19,
    "url": "http://localhost:4000/python-class/",
    "title": "Python에서 class 다루기",
    "body": "2024/07/24 - 클래스(class)는 객체 지향 프로그래밍(Object-Oriented Programming, OOP)을 구현하는 데 핵심적인 역할을 하고 있습니다. 클래스는 객체 지향 프로그래밍에서 객체를 생성하기 위한 blueprint입니다. 클래스는 속성(attributes)과 메서드(methods)를 정의하며, 이를 통해 객체의 상태와 동작을 기술합니다. 클래스는 코드의 재사용성을 높이고, 구조화된 코드를 작성하는 데 도움을 줍니다. 이번 포스팅에서는 파이썬에서 클래스를 사용하는 방법에 대해 알아보도록 하겠습니다. 파이썬의 기본 문법에 대해서는 이전에 작성해 둔 Python Tutorial 포스팅을 참고하시기 바랍니다. class의 정의와 instance 생성파이썬에서 클래스를 정의하려면 class 키워드를 사용합니다. 클래스명은 보통 대문자로 시작하는 것이 일반적입니다. 12345678910class Dog :  def __init__(self, name, age) :    self. name = name    self. age = age    def bark(self) :    return f {self. name} is barking.  my_dog = Dog( Cookie , 3)print(my_dog. bark()) # Cookie is barking. __init__ 메서드: __init__ 메서드는 클래스의 생성자(Constructor)로, 클래스 인스턴스가 생성될 때 자동으로 호출되는 메서드입니다. 이를 통해 객체의 초기 상태를 설정할 수 있습니다. self 키워드: 인스턴스 속성은 self 키워드를 사용하여 정의합니다. self는 인스턴스 자신을 가리키며, 클래스 내에서 메서드와 속성에 접근할 때 사용됩니다. class의 상속상속(Inheritance)은 기존 클래스의 속성과 메서드를 물려받아 새로운 클래스를 생성하는 방법입니다. 이를 통해 코드의 재사용성을 높일 수 있습니다. 참고로, 파이썬은 다중 상속을 지원하며, 어떤 부모 클래스의 메서드를 호출할 것인지는 메서드 해결 순서(Method Resolution Order, MRO)를 따르게 됩니다. 12345678910111213141516171819class Animal :  def __init__(self, name) :    self. name = name    def speak(self) :    passclass Dog(Animal) :  def speak(self) :    return f {self. name} says Woof! class Cat(Animal) :  def speak(self) :    return f {self. name} says Meow! dog = Dog( Buddy )cat = Cat( Kitty )print(dog. speak()) # Buddy says Woof!print(cat. speak()) # Kitty says Meow!메서드 오버라이딩: 자식 클래스는 부모 클래스의 메서드를 오버라이딩(재정의) 할 수 있습니다. 이를 통해 자식 클래스는 부모 클래스와 다른 동작을 정의할 수 있습니다. 위 예제에서 Dog과 Cat 클래스는 각각 speak 메서드를 오버라이딩하여 다른 동작을 하도록 만들었습니다. super 키워드: super 키워드는 자식 클래스에서 부모 클래스의 메서드를 호출할 때 사용됩니다. 이를 통해 자식 클래스는 부모 클래스의 메서드를 재사용하거나 확장할 수 있습니다. class의 캡슐화캡슐화(Encapsulation)은 객체의 속성과 메서드를 보호하여 객체의 내부 상태를 숨기고, 외부에서는 객체의 속성과 메서드에 직접 접근하지 못하도록 하는 개념입니다. 이를 통해 데이터의 무결성을 지키고, 객체 간의 결합도를 낮출 수 있습니다. 접근 제한자: 파이썬에서는 접근 제한자를 통해 속성과 메서드의 접근 범위를 제어할 수 있습니다.  공개(Public) : 모든 곳에서 접근 가능. 이름 앞에 아무것도 붙이지 않는 경우입니다.  비공개(Private) : 클래스 내부에서만 접근 가능. 이름 앞에 밑줄 두 개(__)를 붙이는 경우입니다. 123456789101112131415class Person :  def __init__(self, name, age) :    self. name = name # public    self. __age = age # private    def get_age(self) :    return self. __age    def set_age(self, age) :    if age &gt; 0 :      self. __age = agep = Person( Alice , 30)print(p. name) # Aliceprint(p. get_age()) # 30위 예제에서는 age 속성을 private으로 설정하여 클래스 외부에서는 메서드를 통해서만 접근할 수 있도록 하였습니다. 이러한 방식으로 캡슐화를 구현할 수 있습니다. class의 다형성다형성(Polymorphism)은 동일한 인터페이스를 통해 서로 다른 데이터 타입의 객체를 다룰 수 있게 하는 개념입니다. 이를 통해 코드의 유연성과 재사용성을 높일 수 있습니다. 1234567891011121314151617181920212223class Shape :  def area(self) :    passclass Rectangle(Shape) :  def __init__(self, width, height) :    self. width = width    self. height = height    def area(self) :    return self. width * self. heightclass Circle(Shape) :  def __init__(self, radius):    self. radius = radius    def area(self) :    return 3. 14 * self. radius ** 2shapes = [Rectangle(3, 4), Circle(5)]for shape in shapes :  print(shape. area())위 예제에서 Shape 클래스는 공통 인터페이스를 제공하며, Rectange과 Circle 클래스는 이를 구현하여 각각의 면적을 계산합니다. 이러한 방식을 통해 다양한 형태의 객체를 동일한 방식으로 처리할 수 있습니다. class의 Metaclass파이썬에서는 메타클래스(Metaclass)를 사용하여 클래스의 동작을 제어할 수 있습니다. 메타클래스는 클래스의 클래스이며, 클래스를 생성하고 조작하는 역할을 합니다. 1234567class MyMeta(type) :  def __new__(cls, name, bases, dct) :    print(f Creating class {name} )    return super(). __new__(cls, name, bases, dct)class MyClass(metaclass=MyMeta) :  pass위 코드를 실행하면 Creating class MyClass 문구가 출력됩니다. 메타클래스를 사용하면 클래스 생성 시점에서 추가적인 로직을 실행하거나, 클래스 속성과 메서드를 동적으로 변경할 수 있습니다. 파이썬의 클래스는 객체 지향 프로그래밍의 핵심 개념으로, 더욱 효율적이고 구조화된 코드를 작성할 수 있도록 해 주는 강력한 도구입니다. 이번 포스팅이 파이썬의 클래스에 대해 이해하는 데 도움이 되셨기를 바랍니다. "
    }, {
    "id": 20,
    "url": "http://localhost:4000/python-data-types/",
    "title": "Python의 자료형 살펴보기",
    "body": "2024/07/23 - 파이썬은 많은 개발자들에게 사랑 받는 프로그래밍 언어입니다. 파이썬을 잘 사용하기 위해서는 자료형(data type)을 이해하는 것이 무엇보다 중요합니다. 이번 포스팅에서는 파이썬의 자료형에 대해 자세히 알아보도록 하겠습니다. 파이썬의 기본 문법에 대해서는 이전에 작성해 둔 Python Tutorial 포스팅을 참고하시기 바랍니다. 기본 자료형파이썬의 기본 자료형은 크게 숫자형, 문자열, 리스트, 튜플, 세트, 딕셔너리가 있습니다. 각 자료형은 고유한 특성과 용도를 가지고 있기 때문에, 상황에 맞게 적절히 사용해야 합니다. 숫자형: 숫자형에는 정수형(int), 실수형(float), 복소수형(complex) 등이 존재합니다.  정수형(int) : 정수 값을 나타냅니다. (x = 10) 실수형(float) : 부동 소수점을 포함한 실수 값을 나타냅니다. (y = 10. 5) 복소수형(complex) : 실수부와 허수부로 구성된 복소수를 나타냅니다. (z = 1 + 2j)문자열 (String): 문자열은 큰따옴표(  )나 작은 따옴표('')로 감싸서 선언할 수 있습니다. 문자열은 불변(immutable) 자료형으로, 생성 후에는 변경할 수 없으나, 다양한 메서드를 이용하여 조작할 수 있습니다. 1s =  Hello, world! 리스트 (List): 리스트는 여러 값을 하나의 변수에 저장할 수 있는 자료형으로, 대괄호([])를 사용하여 정의합니다. 리스트는 가변(mutable) 자료형으로, 요소를 추가, 삭제, 변경할 수 있습니다. 1my_list = [1, 2, 3, 4, 5]튜플 (Tuple): 튜플은 리스트와 유사하지만, 불변(immutable) 자료형입니다. 소괄호(())를 사용하여 정의합니다. 1my_tuple = (1, 2, 3, 4, 5)세트 (Set): 세트는 중복을 허용하지 않는 자료형으로, 중괄호({})를 사용하여 정의합니다. 순서가 없기 때문에 인덱싱이 불가능하다는 특징이 있습니다. 1my_set = {1, 2, 3}딕셔너리 (Dictionary): 딕셔너리는 키-값(key-value) 쌍으로 데이터를 저장하는 자료형입니다. 중괄호({})를 사용하여 정의하며, 키를 통해 값을 조회할 수 있습니다. 1my_dict = { name :  Alice ,  age : 23}자료형 변환파이썬에서는 자료형 간의 변환이 매우 용이합니다. 이를 통해 다양한 형태의 데이터를 유연하게 처리할 수 있습니다. 암시적 형변환: 파이썬은 필요에 따라 자동으로 자료형을 변환합니다. 이를 암시적 형변환(implicit type conversion)이라고 합니다. 아래 예시에서 int 형과 float 형을 더하기 위해 암시적으로 float 형으로 변환되는 것을 확인할 수 있습니다. 123x = 10y = 2. 5z = x + y # 12. 5 (float)명시적 형변환: 명시적 형변환(explicit type conversion)이란 사용자가 직접 자료형을 변환하는 방법을 의미합니다. 아래 예시에서 string 타입을 int 형으로 명시적으로 변환한 것을 확인할 수 있습니다. 123x = 10y =  20 z = x + int(y) # 30 (int)확장 자료형기본 자료형 이외에도 파이썬은 데이터 처리를 위한 다양한 확장 자료형을 제공합니다. 배열 (Array): 배열은 동일한 자료형의 요소들을 저장하는 자료형으로, array 모듈을 사용하여 정의할 수 있습니다. 배열은 리스트와 유사하지만, 더 효율적인 메모리 사용과 성능을 제공합니다. 배열의 사용법에 대해서는 Python의 배열(Array) - 효율적인 데이터 처리하기 포스팅을 참고하시기 바랍니다. 12import array as arrmy_array = arr. array('i', [1, 2, 3, 4])데이터프레임 (DataFrame): 데이터프레임은 표 형태의 데이터를 저장하고 조작하기 위한 자료형으로, 주로 pandas 라이브러리를 사용하여 정의합니다. 123import pandas as pddata = {'name': ['Alice', 'Bob'], 'age': [25, 30]}df = pd. DataFrame(data)사용자 정의 자료형파이썬에서는 클래스(class)를 사용하여 사용자 정의 자료형을 만들 수 있습니다. 이를 통해 객체 지향 프로그래밍(OOP)의 강력한 기능을 활용할 수 있습니다. 아래 예시는 이름과 나이를 가지는 클래스를 생성하고, greet 함수를 정의한 것입니다. 12345678910class Person :  def __init__(self, name, age) :    self. name = name    self. age = age    def greet(self) :    return f Hello, my name is {self. name}. I'm {self. age} years old.  p = Person( Alice , 25)print(p. greet()) # Hello, my name is Alice. I'm 25 years old. 파이썬의 자료형은 매우 다양하고 강력하며, 이를 잘 이해하고 활용하면 효율적이고 안정적인 코드를 작성할 수 있습니다. 이번 포스팅에서는 파이썬의 기본 자료형부터 확장 자료형, 그리고 사용자 정의 자료형까지 다뤘습니다. 파이썬의 자료형을 제대로 이해하고 활용하면 더욱 발전된 프로그래밍을 할 수 있을 것입니다. 파이썬의 자료형에 대한 더 많은 정보가 필요하다면 파이썬 공식 문서를 참고하시길 바랍니다. "
    }, {
    "id": 21,
    "url": "http://localhost:4000/python-array/",
    "title": "Python의 배열(Array) - 효율적인 데이터 처리하기",
    "body": "2024/07/23 - 파이썬은 다양한 자료형(data type)을 제공합니다. 그 중에서도 배열(Array)은 확장 자료형으로 효율적인 데이터 처리를 위해 반드시 알아야 할 중요한 개념입니다. 이번 포스팅에서는 파이썬의 배열에 대해 자세히 알아보겠습니다. 파이썬의 기본 문법에 대해서는 이전에 작성해 둔 Python Tutorial 포스팅을 참고하시기 바랍니다. 또, 파이썬의 자료형에 대해서는 Python의 자료형 살펴보기 포스팅을 참고하시기 바랍니다. 배열(Array)이란?배열은 동일한 자료형의 요소들을 저장하는 자료구조입니다. 파이썬에서는 기본적으로 리스트(List)를 사용하지만, 배열(Array)을 사용하면 더 효율적인 메모리 사용과 성능을 얻을 수 있습니다. 배열은 특히 대량의 데이터 처리에 유리합니다. Python에서 배열 사용하기파이썬에서 배열을 사용하기 위해서는 array 모듈을 임포트해야 합니다. 배열은 리스트와 유사하지만, 모든 요소가 동일한 자료형이어야 한다는 점에서 차이가 있습니다. 배열 생성하기: 배열을 생성하려면 array. array 메소드를 사용합니다. 이 때, 배열의 자료형과 초기 요소들을 지정해줍니다. 123import arraymy_array = array. array('i', [1, 2, 3, 4, 5])print(my_array) # array('i', [1, 2, 3, 4, 5])위 코드에서 'i'는 배열이 정수형(integer) 요소들로 구성된다는 것을 의미합니다. 파이썬의 array 모듈은 다양한 자료형 코드를 지원합니다.       자료형 코드   설명   최소 크기         'b'   부호 있는 정수   1 byte       'B'   부호 없는 정수   1 byte       'h'   부호 있는 정수   2 byte       'H'   부호 없는 정수   2 byte       'i'   부호 있는 정수   2 byte       'I'   부호 없는 정수   2 byte       'l'   부호 있는 정수   4 byte       'L'   부호 없는 정수   4 byte       'q'   부호 있는 정수   8 byte       'Q'   부호 없는 정수   8 byte       'f'   부동 소수점   4 byte       'd'   부동 소수점   8 byte   배열 요소 접근: 배열 요소에 접근하는 방법은 리스트와 동일합니다. 인덱스를 사용하여 요소를 조회하거나, 변경할 수 있습니다. 12345import arraymy_array = array. array('i', [1, 2, 3, 4, 5])print(my_array[0]) # 1my_array[1] = 10print(my_array) # array('i', [1, 10, 3, 4, 5])배열 메서드: 배열은 다양한 메서드를 제공하여 요소를 추가, 제거, 검색할 수 있습니다.  append() : 배열 끝에 요소를 추가합니다.  insert() : 특정 인덱스에 요소를 추가합니다.  pop() : 특정 인덱스의 요소를 제거하고 반환합니다.  remove() : 첫 번째로 일치하는 요소를 제거합니다. 123456789101112131415161718import arraymy_array = array. array('i', [1, 2, 3, 4, 5])# append()my_array. append(6)print(my_array) # array('i', [1, 2, 3, 4, 5, 6])# insert()my_array. insert(2, 7)print(my_array) # array('i', [1, 2, 7, 3, 4, 5, 6])# pop()my_array. pop(3)print(my_array) # array('i', [1, 2, 7, 4, 5, 6])# remove()my_array. remove(7)print(my_array) # array('i', [1, 2, 4, 5, 6])배열 vs. 리스트파이썬에서 리스트와 배열은 비슷해 보이지만, 몇 가지 중요한 차이점이 있습니다.  자료형 : 리스트는 서로 다른 자료형의 요소들을 가질 수 있지만, 배열은 동일한 자료형의 요소들로만 구성됩니다.  성능 : 배열은 메모리 효율성과 성능 면에서 리스트보다 뛰어납니다. 이는 배열이 메모리 상에서 연속된 공간을 차지하기 때문입니다.  용도 : 리스트는 일반적인 용도로, 배열은 대량의 데이터 처리가 필요한 경우에 적합합니다. 파이썬에서 배열은 효율적인 데이터 처리를 위해 중요한 자료구조입니다. 배열을 사용하면 메모리 효율성과 성능을 크게 향상시킬 수 있습니다. 배열에 대한 더 자세한 내용은 파이썬 공식 문서를 참고해 보시길 바랍니다. "
    }, {
    "id": 22,
    "url": "http://localhost:4000/python-lambda-function/",
    "title": "Python Lambda Function에 대하여",
    "body": "2024/07/22 - 파이썬에서는 람다 함수(lambda function)를 사용하여 익명 함수(Anonymous Function)를 간단하게 정의할 수 있습니다. 람다 함수는 이름이 없는 함수로, 주로 짧은 코드 블럭에서 일회성으로 사용됩니다. 이번 포스팅에서는 파이썬 람다 함수의 개념과 사용법, 그리고 예제를 통해 람다 함수를 어떻게 활용할 수 있는지에 대해 자세히 설명하겠습니다. 람다 함수란?람다 함수는 lambda 키워드를 사용하여 정의되는 익명 함수입니다. 일반적인 함수 정의 방식과는 다르게, 람다 함수는 한 줄로 간결하게 작성할 수 있습니다. 기본 문법은 다음과 같습니다. 1lambda arguments: expression여기서 arguments는 함수의 인자들을, expression은 인자들을 사용하여 계산되는 표현식을 의미합니다. 람다 함수는 값으로 평가되며, 주로 다른 함수의 인자로 전달되거나 변수에 할당됩니다. 람다 함수의 장점: 람다 함수는 다음과 같은 장점을 가지고 있습니다.  간결성 : 짧고 간결하게 함수를 정의할 수 있어 코드의 가독성을 높입니다.  일회성 사용 : 일회성으로 사용되는 간단한 함수를 정의할 때 유용합니다.  고차 함수와 함께 사용 : 고차 함수와 함께 사용하여 더욱 직관적인 코드를 작성할 수 있습니다. 간단한 람다 함수의 예시: 다음은 간단한 람다 함수를 사용하는 예제입니다. lambda x, y: x + y는 두 인자를 더하는 람다 함수를 정의하고, 이를 add 변수에 할당합니다. 12add = lambda x, y: x + yprint(add(5, 3)) # 8고차 함수와 Lambda 함수파이썬에서 제공하는 다양한 고차 함수들과 람다 함수는 함께 사용할 때 더욱 직관적이고 효율적인 코드를 작성할 수 있게 됩니다. 파이썬의 고차 함수에 대해서는 Python에서의 고차 함수 (feat. map, filter, reduce)포스팅을 참고 부탁드립니다. map() 함수와 람다 함수: map() 함수와 람다 함수를 같이 사용할 수 있습니다. 람다 함수를 사용하면 따로 함수를 선언하지 않으므로 간결한 코드가 됩니다. 123numbers = [1, 2, 3, 4, 5]squared_numbers = list(map(lambda x: x * x, numbers))print(squared_numbers) # [1, 4, 9, 16, 25]filter() 함수와 람다 함수: filter() 함수와도 람다 함수를 같이 사용할 수 있습니다. 123numbers = [1, 2, 3, 4, 5]even_numbers = list(filter(lambda x: x % 2 == 0, numbers))print(even_numbers) # [2, 4]reduce() 함수와 람다 함수: reduce() 함수를 사용하여 리스트의 요소를 누적하는 경우에도 사용이 가능합니다. 12345from functools import reducenumbers = [1, 2, 3, 4, 5]sum_of_numbers = reduce(lambda x, y: x + y, numbers)print(sum_of_numbers) # 15sorted() 함수와 람다 함수: sorted() 함수를 사용하면서 람다 함수를 사용하여 key 인자를 함수로 받아 정렬 기준을 정의할 수 있습니다. 12345678students = [  {'name': 'Alice', 'grade': 'B'},  {'name': 'Bob', 'grade': 'A'},  {'name': 'Charlie', 'grade': 'C'},]sotred_students = sorted(students, key=lambda student: student['grade'])print(sorted_students) # [{'name': 'Bob', 'grade': 'A'}, {'name': 'Alice', 'grade': 'B'}, {'name': 'Charlie', 'grade': 'C'}]람다 함수 사용 시의 주의사항람다 함수는 간결하고 일회성으로 사용하기 좋지만, 복잡한 로직을 포함하는 경우에는 일반 함수를 사용하는 것이 더 적합할 수 있습니다. 다음은 람다 함수를 사용할 때의 몇 가지 주의사항입니다.  가독성 : 너무 복잡한 람다 함수를 사용하면 코드의 가독성이 오히려 떨어질 수 있습니다. 간단한 함수를 정의하는 경우에만 사용하는 것이 좋습니다.  디버깅 : 람다 함수는 이름이 없기 때문에 디버깅이 어려울 수 있습니다. 복잡한 로직이 필요한 경우 일반 함수를 사용하는 것이 좋습니다. 파이썬의 람다 함수는 코드의 간결성과 가독성을 높이는 강력한 도구입니다. 짧고 단순한 함수를 정의할 때 유용하며, 특히 고차 함수와 함께 사용하면 더욱 효과적입니다. 하지만 복잡한 로직을 처리할 때에는 일반 함수를 사용하는 것이 좋을 수 있습니다. 람다 함수의 개념과 사용법을 잘 이해하고, 적절히 활용하면 더욱 효율적이고 직관적인 파이썬 코드를 작성할 수 있을 것입니다. "
    }, {
    "id": 23,
    "url": "http://localhost:4000/python-higher-order-function/",
    "title": "Python에서의 고차 함수 (feat. map, filter, reduce)",
    "body": "2024/07/21 - 프로그래밍 언어에서 고차 함수(Higher-order function)는 함수를 인자로 받거나, 함수를 반환하는 함수를 의미합니다. 이러한 함수들은 함수형 프로그래밍의 핵심 요소로, 코드의 재사용성과 가독성을 높이는 데 큰 역할을 합니다. 특히 파이썬에서는 고차 함수를 활용하기 좋습니다. 고차 함수의 개념고차 함수는 다음 두 가지 특성 중 하나 이상을 만족하는 함수입니다.  하나 이상의 함수를 인자로 받을 수 있다.  함수를 반환할 수 있다. 이러한 특성 덕분에 고차 함수는 매우 유연하고 강력한 도구로 사용됩니다. 대표적인 고차 함수로는 map(), filter(), reduce() 등이 있습니다. 고차 함수의 장점: 고차 함수는 다음의 여러 가지 장점을 가지고 있습니다.  코드의 재사용성 : 고차 함수를 사용하면 동일한 코드 블럭을 여러 번 사용할 수 있어 코드의 재사용성이 높아집니다.  가독성 향상 : 고차 함수를 사용하면 코드를 간결하게 작성할 수 있어 가독성이 향상됩니다. 특히, 익명 함수(lambda 함수)를 사용하면 더 짧고 명료한 코드를 작성할 수 있습니다.  유연성 : 함수를 인자로 받거나 반환할 수 있어 매우 유연한 코드를 설계할 수 있습니다. 함수를 인자로 받는 함수의 예시: 다음 예시는 함수를 인자로 받는 고차 함수를 생성합니다. apply_function 함수는 함수를 인자로 받아 해당 함수를 실행하게 됩니다. 12345678def apply_function(func, value) :  return func(value)def square(x) :  return x * xresult = apply_function(square, 5)print(result) # 25함수를 반환하는 함수의 예시: 다음 예시는 함수를 반환하는 고차 함수를 생성합니다. create_multiplier 함수는 입력값에 특정 값을 곱하는 기능을 하는 함수를 반환합니다. 1234567def create_multiplier(n) :  def multiplier(x) :    return x * n  return multipliermultiply_by_3 = create_multiplier(3)print(multiply_by_3(10)) # 30Python에서의 고차 함수파이썬은 고차 함수를 매우 효율적으로 지원합니다. 파이썬에서 자주 사용되는 몇 가지 고차 함수들에 대해서 설명하도록 하겠습니다. map(): map() 함수는 주어진 함수와 iterable을 인자로 받아, iterable의 각 요소에 함수를 적용한 결과를 반환합니다. 123456def square(x) :  return x * xnumbers = [1, 2, 3, 4, 5]squared_numbers = list(map(square, numbers))print(squared_numbers) # [1, 4, 9, 16, 25]filter(): filter() 함수는 주어진 함수와 iterable을 인자로 받아, 함수의 조건을 만족하는 요소만을 포함하는 iterable을 반환합니다. 123456def is_even(n) :  return n % 2 == 0numbers = [1, 2, 3, 4, 5]even_numbers = list(filter(is_even, numbers))print(even_numbers) # [2, 4]reduce(): reduce() 함수는 iterable의 각 요소에 누적 함수를 적용하여 단일 값을 반환합니다. 이 함수는 functools 모듈에서 제공됩니다. 12345678from functools import reducedef add(x, y) :  return x + ynumbers = [1, 2, 3, 4, 5]sum_of_numbers = reduce(add, numbers)print(sum_of_numbers) # 15고차 함수는 파이썬을 비롯한 여러 프로그래밍 언어에서 강력한 도구로 활용됩니다. 함수를 인자로 받거나 반환하는 이러한 함수들은 코드의 재사용성과 가독성을 높이며, 유연하고 간결한 코드를 작성하는 데 큰 도움이 됩니다. 이러한 고차 함수를 잘 활용하면 더욱 효율적인 코드를 작성할 수 있을 것입니다. "
    }, {
    "id": 24,
    "url": "http://localhost:4000/django-restful-api/",
    "title": "Django를 사용하여 RESTful API 구축하기",
    "body": "2024/07/19 - Django는 웹 개발을 위한 강력한 프레임워크로, RESTful API를 빠르고 쉽게 구축할 수 있습니다. 이번 포스팅에서는 Django와 Django REST framework를 사용하여 RESTful API를 구축하는 방법에 대해 설명하겠습니다. RESTful API는 클라이언트와 서버 간의 통신을 효율적으로 관리하는 방법으로, CRUD(Create, Read, Update, Delete) 작업을 쉽게 수행할 수 있습니다. 우선 Python이 설치되어 있어야 합니다. 파이썬을 설치하는 과정과 기본 문법에 대해서는 이전에 작성해 둔 Python Tutorial 포스팅을 참고하시기 바랍니다. 환경 설정Django 프레임워크 설치: 먼저, 터미널이나 명령 프롬프트에서 다음 명령어를 통해 Django와 Django REST framework를 설치합니다. 1pip install django djangorestframeworkDjango 어플리케이션 생성: 그리고 적절한 디렉토리로 이동하여 새로운 Django 프로젝트와 어플리케이션을 생성합니다. 123django-admin startproject myprojectcd myprojectdjango-admin startapp myapp생성된 기본 프로젝트와 어플리케이션의 구조는 다음과 같습니다. 1234567891011121314myproject/  manage. py  myproject/    __init__. py    settings. py    urls. py    wsgi. py  myapp/    __init__. py    admin. py    apps. py    models. py    tests. py    views. py설정 파일 수정: myproject 디렉토리 하에 있는 settings. py 파일을 수정해줍니다. INSTALLED_APPS 항목에 rest_framework와 myapp을 추가합니다. 12345INSTALLED_APPS = [  . . .   'rest_framework',  'myapp',]모델 생성이번에는 간단한 Todo 리스트를 관리하는 API를 생성해보겠습니다. 먼저, models. py 파일에서 Todo 모델을 생성합니다. 제목(title)과 설명(description), 그리고 완료 여부(completed) 세 가지 필드를 가지는 모델입니다. 123456789from django. db import modelsclass ToDo(models. Model) :  title = models. CharField(max_length=100)  description = models. TextField()  completed = models. BooleanField(default=False)  def __str__(self) :    return self. title모델을 생성해 준 후, 데이터베이스를 마이그레이션 합니다. python 명령어를 못 찾는 경우, python3 명령어를 사용하셔도 무방합니다. 12python manage. py makemigrationspython manage. py migrate직렬화다음으로, myapp 디렉토리 하에 serializers. py 파일을 생성하고, 위에서 만든 모델을 직렬화하는 코드를 작성해줍니다. 1234567from rest_framework import serializersfrom . models import ToDoclass ToDoSerializer(serializers. ModelSerializer) :  class Meta :    model = ToDo    fields = '__all__'Viewset 생성views. py 파일을 수정해서 ToDo API 뷰셋을 생성합니다. 1234567from rest_framework import viewsetsfrom . models import ToDofrom . serializers import ToDoSerializerclass ToDoViewSet(viewsets. ModelViewSet) :  queryset = ToDo. objects. all()  serializer_class = ToDoSerializerURL 설정마지막으로, urls. py 파일을 수정하여 API 엔드포인트를 설정해줍니다. 123456789101112from django. contrib import adminfrom django. urls import path, includefrom rest_framework. routers import DefaultRouterfrom myapp. views import ToDoViewSetrouter = DefaultRouter()router. register(r'todos', ToDoViewSet)urlpatterns = [  path('admin/', admin. site. urls),  path('api/', include(router. urls)),]서버 실행 및 테스트이제 /api/todos 엔드포인트를 통해 CRUD 기능을 사용할 수 있습니다. 서버는 다음 명령어를 통해 실행 가능합니다. 1python manage. py runserver서버는 http://127. 0. 0. 1:8000/에서 실행되며, 브라우저나 postman 같은 도구를 사용하여 API 요청을 보내며 테스트 해 볼 수 있습니다. 참고로 다음 요청들이 가능합니다.       Endpoint   Description         GET /api/todos/   모든 ToDo 항목을 조회합니다.        POST /api/todos/   새로운 ToDo 항목을 생성합니다.        PUT /api/todos/{id}/   특정 ToDo 항목을 수정합니다.        DELETE /api/todos/{id}   특정 ToDo 항목을 삭제합니다.    API 보안 설정추가로, API 보안을 위해 Django REST framework에서 제공하는 인증 기능을 사용할 수 있습니다. settings. py 파일에서 인증 설정을 다음과 같이 추가해줍니다. 123456789REST_FRAMEWORK = {  'DEFAULT_AUTHENTICATION_CLASSES': (    'rest_framework. authentication. BasicAuthentication',    'rest_framework. authentication. SessionAuthentication',  ),  'DEFAULT_PERMISSION_CLASSES': (    'rest_framework. permissions. IsAuthenticated',  ),}그리고 views. py 파일에서 뷰에 인증을 적용해줍니다. 123456from rest_framework. permissions import IsAuthenticatedclass ToDoViewSet(viewsets. ModelViewSet):  queryset = ToDo. objects. all()  serializer_class = ToDoSerializer  permission_classes = [IsAuthenticated]이번 포스팅에서는 파이썬과 Django, Django REST framework를 사용하여 RESTful API를 구축하는 방법을 다루어보았습니다. 모델 생성, 직렬화, 뷰 설정, URL 라우팅, API 보안 설정까지의 과정을 단계별로 설명하였습니다. Django와 DRF는 강력한 기능을 제공하여 보다 신속하고 효율적인 API 개발이 가능하다는 장점이 있습니다. RESTful API 설계와 구현에 대해 더 많은 정보를 원하신다면, Django REST framework 공식 문서와 RESTful API 디자인 원칙을 참고하면 좋습니다. "
    }, {
    "id": 25,
    "url": "http://localhost:4000/nodejs-typescript/",
    "title": "Node.js에서 Typescript 사용하기",
    "body": "2024/07/19 - Typescript와 Node. js를 함께 사용하는 것은 더 강력하고 유지보수성이 좋은 어플리케이션을 만드는 데 큰 도움이 됩니다. Typescript는 Javascript의 슈퍼셋으로, 몇 가지 장점들이 존재합니다.  타입스크립트는 변수와 함수에 타입을 지정할 수 있어 코드 작성 시 타입 오류를 미리 찾아낼 수 있습니다. 이는 런타임 에러를 줄이고, 코드의 안정성을 높여줍니다.  타입스크립트는 코드 자동 완성, 리팩토링, 내비게이션 등의 기능을 제공하여 개발 생산성을 높여줍니다.  클래스, 인터페이스, 제네릭 등 객체 지향 프로그래밍(OOP)의 개념을 잘 지원하여 더 구조화되고 재사용 가능한 코드를 작성할 수 있습니다.  코드 베이스가 커질수록 타입 시스템이 유지보수를 쉽게 만들어줍니다. 타입을 지정함으로써 다른 개발자들이 코드를 이해하고 수정하기 쉬워집니다.  기존 자바스크립트 프로젝트를 점진적으로 타입스크립트로 전환할 수 있어, 새로운 프로젝트 뿐만 아니라 기존 프로젝트에도 쉽게 적용할 수 있습니다. 이번 포스팅에서는 Typescript와 Node. js를 함께 사용하는 방법에 대해 다뤄보도록 하겠습니다. 우선 Node. js와 npm, express. js가 설치되어 있어야 합니다. Node. js 및 패키지를 설치하는 과정과 서버를 실행하는 과정에 대해서는 이전에 작성해 둔 Node. js Tutorial 포스팅을 참고하시기 바랍니다. 프로젝트 초기화우선 프로젝트 디렉토리를 생성하고, 해당 디렉토리로 이동한 후 npm 초기화를 진행하여 기본 설정을 가진 package. json 파일을 생성합니다. 123$ mkdir my-project$ cd my-project$ npm init -yTypescript 설치터미널 혹은 명령 프롬프트를 열어서 Typescript와 ts-node를 설치합니다. ts-node는 Typescript 파일을 직접 실행할 수 있게 해주는 패키지이며, @types/node는 node에 사용되는 타입스크립트의 타입이 정의된 라이브러리입니다. 1$ npm install typescript ts-node @types/nodetsconfig. json 파일 생성타입스크립트 설정을 위해 tsconfig. json 파일을 생성합니다. 1$ npx tsc --init그리고 생성된 tsconfig. json 파일을 다음과 같이 수정해줍니다. 다음 코드는 타입스크립트가 ES2020 기능을 사용하고, 소스 파일은 src 디렉토리에, 컴파일된 파일은 dist 디렉토리에 저장되도록 합니다. 123456789101112{  compilerOptions : {   target :  ES2020 ,               module :  commonjs ,              outDir :  . /dist ,               rootDir :  . /src ,               strict : true,                 esModuleInterop : true,             skipLibCheck : true,              forceConsistentCasingInFileNames : true   }}index. ts 파일 생성다음으로, src 디렉토리를 생성하고, 그 안에 index. ts 파일을 생성해줍니다. 이제 index. ts 파일을 열어 간단한 예제 코드를 작성해 봅시다. 12345const sayHello = (name: string): string =&gt; {  return `Hello, ${name}!`;};console. log(sayHello( World ));스크립트 설정package. json 파일에 타입스크립트 컴파일 및 실행 스크립트를 추가합니다. 1234567{   scripts : {     build :  tsc ,     start :  node dist/index. js ,     dev :  ts-node src/index. ts   }}빌드 및 실행이제 npm run dev 명령어로 개발 모드에서 타입스크립트 파일을 실행할 수 있습니다. 다음 명령어는 src/index. ts 파일을 ts-node를 통해 직접 실행하게 됩니다. 1$ npm run dev그리고 개발이 완료되면, 타입스크립트 파일을 자바스크립트로 컴파일하고 실행해줍니다. npm run build 명령어는 타입스크립트 파일을 컴파일하여 dist 디렉토리에 저장하고, npm start는 컴파일된 자바스크립트 파일을 실행합니다. 12$ npm run build$ npm start타입스크립트와 Node. js를 함께 사용하면 다양한 타입스크립트의 이점을 누릴 수 있습니다. 이는 개발 생산성 향상에 큰 도움이 됩니다. 이번 포스팅에서는 환경 설정부터 간단한 어플리케이션 실행까지 다루었는데, 이를 바탕으로 원하는 어플리케이션을 개발할 수 있기를 바랍니다. "
    }, {
    "id": 26,
    "url": "http://localhost:4000/python-web-scraping/",
    "title": "Python으로 웹 스크래핑(웹 크롤링)하기",
    "body": "2024/07/18 - 웹 스크래핑(웹 크롤링)은 웹사이트에서 데이터를 추출하여 분석하거나 저장하는 기술입니다. 파이썬은 웹 스크래핑 작업에 널리 사용되는 프로그래밍 언어인데요. 이번 포스팅에서는 Requests와 BeautifulSoup 라이브러리를 사용하여 웹 스크래핑 하는 방법에 대해 단계별로 설명하도록 하겠습니다. 파이썬을 설치하는 과정과 기본 문법에 대해서는 이전에 작성해 둔 Python Tutorial 포스팅을 참고하시기 바랍니다. 환경 설정파이썬이 설치되어 있다는 가정 하에, 필요한 두 라이브러리를 사용하기 위해서는 패키지를 설치해야 하는데, 터미널 혹은 명령 프롬프트를 열고 pip를 사용하여 설치하면 됩니다. 1pip install requests beautifulsoup4웹 스크래핑하기웹 스크래핑 프로젝트의 기본 구조는 다음과 같습니다.  웹페이지 요청 : Requests 라이브러리를 사용하여 웹페이지에 HTTP 요청을 보냅니다.  HTML 파싱 : BeautifulSoup을 사용하여 HTML을 파싱하고 원하는 데이터를 추출합니다.  데이터 저장 : 추출한 데이터를 CSV 파일이나 데이터베이스에 저장합니다. 이번에는 간단한 구조를 지니고 있는 특정 뉴스 웹사이트에서 최신 뉴스 헤드라인을 수집하는 예제를 작성해보겠습니다. 웹페이지 요청: 다음 코드는 Requests 라이브러리를 사용하여 news. ycombinator. com이라는 웹사이트에 requests. get 함수를 사용하여 HTTP 요청을 보냅니다. 12345import requestsurl =  https://news. ycombinator. com/ response = requests. get(url)html = response. contentHTML 파싱: 다음으로, BeautifulSoup을 사용하여 HTML을 파싱하고, find_all 메서드를 사용하여 뉴스 헤드라인을 포함하는 모든 &lt;a&gt; 태그를 찾습니다. 제대로 찾아졌는지 확인하기 위해서 번호를 붙여 출력해봅니다. 1234567from bs4 import BeautifulSoupsoup = BeautifulSoup(html,  html. parser )headlines = soup. find_all( a , class_= storylink )for i, headline in enumerate(headlines, start=1) :  print(f {i}. {headline. get_text()} )데이터 저장: 수집한 데이터를 CSV 파일에 저장하면 나중에 분석하거나 공유하기 쉽습니다. 다음은 headlines. csv 파일을 생성하고, 수집한 뉴스 헤드라인을 저장하는 예제입니다. csv. writer를 사용하여 데이터를 csv 형식으로 저장하게 됩니다. 1234567import csvwith open( headlines. csv ,  w , newline=  ) as file :  writer = csv. writer(file)  writer. writerow([ No ,  Headline ])  for i, headline in enumerate(headlines, start=1) :    writer. writerow([i, headline. get_text()])다양한 기능 추가하기Pagination 처리: 많은 웹사이트는 여러 페이지에 걸쳐서 데이터를 제공합니다. 이러한 경우 페이지네이션을 처리해야 합니다. 다음은 페이지네이션을 처리하여 여러 페이지에 걸쳐서 데이터를 수집하는 코드입니다. get_headlines 함수는 주어진 url에서 헤드라인을 추출하고, while 문을 통해 5페이지까지의 뉴스 헤드라인을 수집하게 됩니다. 1234567891011121314151617181920import requestsfrom bs4 import BeautifulSoupdef get_headlines(url) :  response = requests. get(url)  soup = BeautifulSoup(response. content,  html. parser )  return soup. find_all( a , class_= storylink )base_url =  https://news. ycombinator. com/news?p= page_number = 1all_headlines = []while page_number &lt;= 5 :  url = f {base_url}{page_number}   headlines = get_headlines(url)  all_headlines. extend(headlines)  page_number += 1for i, headline in enumerate(all_headlines, start=1) :  print(f {i}. {headline. get_text()} )요청 사이에 지연 추가: 과도한 요청은 서버에 부하를 줄 수 있기도 하고, 데이터가 로드되는 데까지 시간이 걸릴 수 있기 때문에 필요한 경우 요청 사이에 지연을 추가해주는 것이 좋습니다. time을 사용하여 간단한 방법으로 지연을 추가할 수 있습니다. 초 단위로 지정되며, 실수도 허용되기 때문에 0. 1초 등으로도 사용이 가능합니다. 123import timetime. sleep(1) # 1초의 지연 시간을 추가이번 포스팅에서는 파이썬을 사용하여 웹 스크래핑(웹 크롤링)을 하는 방법에 대하여 알아보았습니다. 웹 스크래핑을 통해 다양한 웹사이트에서 데이터를 수집하고, 이를 분석하여 유용한 정보를 얻을 수 있습니다. Requests와 BeautifulSoup 라이브러리를 사용하면 웹 스크래핑 작업을 손쉽게 수행할 수 있습니다. 수집한 데이터를 저장해두면 추후에 유용하게 활용할 수 있을 것입니다. "
    }, {
    "id": 27,
    "url": "http://localhost:4000/express-restful-api/",
    "title": "Express.js를 사용하여 RESTful API 구축하기 (feat. MongoDB)",
    "body": "2024/07/18 - Node. js와 Express. js를 사용하면 빠르고 간단하게 RESTful API를 구축할 수 있습니다. 이번 포스팅에서는 Express. js를 사용하여 RESTful API를 구축하는 방법에 대해 설명하겠습니다. RESTful API는 클라이언트와 서버 간의 통신을 효율적으로 관리하는 방법으로, CRUD(Create, Read, Update, Delete) 작업을 쉽게 수행할 수 있습니다. 우선 Node. js와 npm, express. js가 설치되어 있어야 합니다. Node. js 및 패키지를 설치하는 과정과 서버를 실행하는 과정에 대해서는 이전에 작성해 둔 Node. js Tutorial 포스팅을 참고하시기 바랍니다. index. js 파일 생성프로젝트 폴더로 이동하여 index. js 파일을 생성하고, 기본적인 Express. js 서버를 설정합니다. 다음 코드는 기본 Express. js 서버를 설정하고, JSON 요청을 파싱할 수 있도록 합니다. 123456789const express = require('express');const app = express();const port = 3000;app. use(express. json());app. listen(port, () =&gt; {  console. log(`Server running at http://localhost:${port}/`);});이제 서버에서 node index. js 명령어를 실행하면 서버가 http://localhost:3000/에서 실행됩니다. RESTful API 엔드포인트 정의RESTful API의 주요 작업인 CRUD(Create, Read, Update, Delete) 작업을 위한 엔드포인트를 정의합니다. 이번 포스팅에서는 예제로 간단한 사용자 관리 API를 만들어 보도록 하겠습니다. 사용자 데이터: 우선은 메모리 내에서 데이터를 저장하는 방식으로 구현해보겠습니다. 1234let users = [  { id: 1, name: 'Alice', email: 'alice@example. com' },  { id: 2, name: 'Bob', email: 'bob@example. com' },];CRUD Endpoint: 여기서는 다음 엔드포인트들을 생성하겠습니다.       Endpoint   Description         GET /users   모든 사용자 목록을 가져옵니다.        GET /users/:id   특정 사용자의 정보를 가져옵니다.        POST /users   새로운 사용자를 추가합니다.        PUT /users/:id   특정 사용자의 정보를 업데이트합니다.        DELETE /users/:id   특정 사용자를 삭제합니다.    위 엔드포인트들을 구현한 코드는 다음과 같습니다. 참고로, 아래 예시에서 사용자를 생성할 때 id를 부여하는 방식은 id가 중복될 수 있기 때문에 예시로만 봐주시면 좋을 것 같습니다. 실제 MongoDB 등을 사용하면 id를 이러한 방식으로 지정하지 않습니다. 12345678910111213141516171819202122232425262728293031323334353637// Createapp. post('/users', (req, res) =&gt; {  const user = { id: users. length + 1, . . . req. body };  users. push(user);  res. status(201). send(user);});// Read allapp. get('/users', (req, res) =&gt; {  res. send(users);});// Read oneapp. get('/users/:id', (req, res) =&gt; {  const user = users. find(u =&gt; u. id === parseInt(req. params. id));  if (!user) return res. status(404). send('User not found');  res. send(user);});// Updateapp. put('/users/:id', (req, res) =&gt; {  const user = users. find(u =&gt; u. id === parseInt(req. params. id));  if (!user) return res. status(404). send('User not found');  user. name = req. body. name;  user. email = req. body. email;  res. send(user);});// Deleteapp. delete('/users/:id', (req, res) =&gt; {  const userIdx = users. findIndex(u =&gt; u. id === parseInt(req. params. id));  if (userIdx === -1) return res. status(404). send('User not found');  const deletedUser = users. splice(userIdx, 1);  res. send(deletedUser);});데이터베이스 연동실제 어플리케이션에서는 데이터를 메모리가 아닌 데이터베이스(DB)에 저장합니다. 여기서는 MongoDB를 사용하여 데이터를 관리하는 방법에 대해 설명하겠습니다. MongoDB와 Mongoose 설치: 다음 명령어를 통해 MongoDB, Mongoose를 설치해줍니다. 1$ npm install mongooseMongoDB 연결 및 schema 정의: index. js 파일을 수정하여 MondoDB에 연결하고, 사용자 스키마를 정의해줍니다. 123456789101112const mongoose = require('mongoose');mongoose. connect('mongodb://localhost/mydatabase', { useNewUrlParser: true, useUnifiedTopology: true })  . then(() =&gt; cconsole. log('MongoDB connected'))  . catch(err =&gt; console. error(err));const UserSchema = new mongoose. Schema({  name: String,  email: String});const User = mongoose. model('User', UserSchema);CRUD Endpoint 수정: 이제 CRUD 엔드포인트를 MongoDB와 연동되도록 수정합니다. 123456789101112131415161718192021222324252627282930313233// Createapp. post('/users', async (req, res) =&gt; {  const user = new User(req. body);  await user. save();  res. status(201). send(user);});// Read allapp. get('/users', async (req, res) =&gt; {  const users = await User. find();  res. send(users);});// Read oneapp. get('/users/:id', async (req, res) =&gt; {  const user = await User. findById(req. params. id);  if (!user) return res. status(404). send('User not found');  res. send(user);});// Updateapp. put('/users/:id', async (req, res) =&gt; {  const user = await User. findByIdAndUpdate(req. params. id, req. body, { new: true });  if (!user) return res. status(404). send('User not found');  res. send(user);});// Deleteapp. delete('/users/:id', async (req, res) =&gt; {  const user = await User. findByIdAndDelete(req. params. id);  if (!user) return res. status(404). send('User not found');  res. send(user);});이번 포스팅에서는 Node. js와 Express. js를 사용하여 RESTful API를 구축하는 방법을 다루어보았습니다. Node. js와 Express. js는 빠르고 유연한 개발 환경을 제공하여 RESTful API를 구축하는 데 있어 좋은 선택입니다. 기본 서버 설정부터 CRUD 엔드포인트 정의, 그리고 MongoDB와의 연동까지 단계별로 설명하였는데요. 이를 통해 간단한 RESTful API를 만들 수 있으며, 더 복잡한 어플리케이션으로 확장할 수 있을 것입니다. 예를 들어, 인증 및 권한 부여, 데이터 검증, 오류 처리 등을 추가하여 실제 어플리케이션에 가까운 API를 만들어 볼 수 있을 것입니다. "
    }, {
    "id": 28,
    "url": "http://localhost:4000/python-automation-script/",
    "title": "Python 자동화 스크립트 작성하기",
    "body": "2024/07/17 - 파이썬은 그 강력한 기능과 간단한 문법 덕분에 자동화 작업에 널리 사용됩니다. 반복적이고 시간이 많이 걸리는 일상 업무를 자동화하면 효율성을 크게 향상시킬 수 있습니다. 자동화를 하게 되면, 시간을 절약할 수 있고, 수작업에서 발생하는 오류를 줄일 수 있으며, 생산성을 향상할 수 있습니다. 이번 포스팅에서는 파이썬으로 자동화 스크립트를 작성하는 방법에 대해서 소개하도록 하겠습니다. 파이썬을 설치하는 과정과 기본 문법에 대해서는 이전에 작성해 둔 Python Tutorial 포스팅을 참고하시기 바랍니다. 웹 스크래핑(웹 크롤링)웹 스크래핑이란 웹사이트에서 데이터를 자동으로 추출하는 것을 의미합니다. 파이썬의 requests와 BeautifulSoup 라이브러리를 사용하여 웹 스크래핑을 간단하게 수행할 수 있습니다. 두 라이브러리를 사용하기 위해서는 패키지를 설치해야 하는데, 터미널 혹은 명령 프롬프트를 열고 pip를 사용하여 설치하면 됩니다. 1pip install requests beautifulsoup4다음은 example. com이라는 사이트에서 모든 &lt;h1&gt; 태그를 찾아 그 텍스트를 출력하는 예시입니다. 12345678910import requestsfrom bs4 import BeautifulSoupurl =  https://example. com response = requests. get(url)soup = BeautifulSoup(response. content,  html. parser )h1s = soup. find_all( h1 )for h1 in h1s :  print(h1. get_text())참고로, example. com 사이트의 구조는 다음과 같습니다.  따라서, 위 코드를 실행하게 되면 Example Domain이 출력됩니다. 파일 처리 자동화파이썬을 이용하여 파일을 읽고 쓰는 작업을 자동화 할 수도 있습니다. 파이썬의 os 모듈을 사용하여 파일 및 디렉토리를 쉽게 관리할 수 있습니다. 다음은 특정 디렉토리 내의 모든 텍스트 파일을 읽고 내용을 출력하는 코드입니다. 123456789import osdirectory =  /path/to/directory for filename in os. listdir(directory) :  if filename. endswith( . txt ) :    with open(os. path. join(directory, filename),  r ) as file :      content = file. read()      print(content)엑셀 파일 자동화엑셀 파일을 처리하는 작업은 openpyxl 라이브러리를 사용하여 자동화할 수 있습니다. 사용하기 전에 우선 openpyxl 패키지를 설치해줍니다. 1pip install openpyxl다음은 example. xlsx 파일의 2행부터 10행까지의 데이터를 출력하는 코드입니다. 1234567from openpyxl import load_workbookworkbook = load_workbook( example. xlsx )sheet = workbook. activefor row in sheet. iter_rows(min_row=2, max_row=10, values_only=True) :  print(row)작업 스케쥴링자동화 스크립트를 정기적으로 실행하기 위해서는 작업 스케쥴링이 필요합니다. 파이썬에서 제공하는 schedule 라이브러리를 사용하면 작업 스케쥴링 또한 간단하게 할 수 있습니다. 다음은 특정 함수를 매일 오전 10시에 실행하는 코드입니다. 1234567891011import scheduleimport timedef job() :  print( Scheduling job running. . .  )schedule. every(). day. at( 10:00 ). do(job)while True :  schedule. run_pending()  time. sleep(1)이메일 자동화파이썬의 smtplib 모듈을 사용하면 이메일을 보내는 것 또한 자동화 할 수 있습니다. smtp 서버를 이용하기 때문에 smtp 서버가 없다면 무료로 제공되는 서버를 이용할 수도 있을 것입니다. 참고로, 구글에서도 무료 smtp 서버를 제공하니 필요하다면 확인해보시면 좋을 것 같습니다. 다음은 간단한 텍스트 이메일을 보내는 코드입니다. 1234567891011121314151617import smtplibfrom email. mime. text import MIMETextdef send_email(subject, body, to_email) :  from_email =  from_email@example. com   password =  password   msg = MIMEText(body)  msg[ Subject ] = subject  msg[ From ] = from_email  msg[ To ] = to_email  with smtplib. SMTP_SSL( smtp. example. com , 465) as server :    server. login(from_email, password)    server. sendmail(from_email, to_email, msg. as_string())send_email( Test Subject ,  This is a test email.  ,  to_email@example. com )파이썬은 자동화 스크립트를 작성하기에 최적화된 언어입니다. 다양한 라이브러리와 간단한 문법 덕분에 초보자도 쉽게 자동화 작업을 시작할 수 있습니다. 위에서 소개한 예시들 이외에도 파이썬으로 자동화할 수 있는 작업은 무궁무진합니다. 자동화를 통해 일상 업무를 효율적으로 관리하고, 시간을 절약하고 생산성을 높일 수 있을 것입니다. "
    }, {
    "id": 29,
    "url": "http://localhost:4000/nodejs-tutorial/",
    "title": "Node.js Tutorial - 5분만에 훑어보기",
    "body": "2024/07/17 - Node. js란 javascript를 사용하여 서버 측 어플리케이션을 개발할 수 있는 런타임 환경입니다. Chrome의 V8 Javascript 엔진을 기반으로 하며, 비동기 이벤트 기반 아키텍쳐로 고성능과 확장성을 제공합니다. Node. js 설치하기Node. js를 설치하려면 공식 웹사이트에서 최신 LTS(Long Term Support) 버전을 다운로드하고 설치하셔야 합니다. 기본 설정으로 설치하면 대부분의 경우 문제가 발생하지 않으므로, 우선은 기본 설정 그대로 설치합니다. 설치가 완료되면 명령 프롬프트나 터미널 등에서 node -v 명령어를 통해 설치된 Node. js의 버전을 확인하실 수 있습니다. 또, npm -v 명령어로 Node. js와 함께 설치되는 npm(Node Package Manager)의 버전도 확인하실 수 있습니다. npm은 Node. js 패키지 관리를 도와주는 도구입니다. 1234$ node -vv20. 15. 1$ npm -v10. 7. 0Node. js 프로젝트 시작하기프로젝트 폴더 생성: 우선 터미널에서 프로젝트를 저장할 폴더를 생성하고, 해당 폴더로 이동해줍니다. 여기서는 예시로 my-first-node-project라는 폴더를 생성하였습니다. 12$ mkdir my-first-node-project$ cd my-first-node-projectpackage. json 파일 생성: package. json 파일은 프로젝트의 metadata를 포함하는 파일로, 프로젝트의 의존성, 스크립트 등을 관리하게 됩니다. npm을 사용하여 package. json 파일을 생성할 수 있습니다. 1$ npm init -y위 명령어를 실행하면 기본 설정으로 package. json 파일이 생성됩니다. 생성된 package. json 파일을 열어보면 다음과 같은 내용이 포함되어 있습니다. 123456789101112{  name :  my-first-node-project ,  version :  1. 0. 0 ,  main :  index. js ,  scripts : {   test :  echo \ Error: no test specified\  &amp;&amp; exit 1  },  keywords : [],  author :   ,  license :  ISC ,  description :   }index. js 파일 생성: package. json 파일을 살펴보면,  main :  index. js 라는 구문을 보실 수 있습니다. 어플리케이션을 실행했을 때 가장 처음으로 실행되는 js 파일을 의미합니다. 프로젝트 폴더에 index. js 파일을 생성하고, 간단한 코드를 작성해보겠습니다. 1234567891011121314const http = require('http');const hostname = '127. 0. 0. 1';const port = 3000;const server = http. createServer((req, res) =&gt; {  res. statusCode = 200;  res. setHeader('Content-Type', 'text/plain');  res. end('Hello, World!\n');});server. listen(port, hostname, () =&gt; {  console. log(`Server running at http://${hostname}:${port}/`);});위 코드는 http 서버를 생성하여, http://127. 0. 0. 1:3000/에서 Hello, World! 메시지를 반환하는 내용입니다. 이제 이 서버를 실행시켜 봅시다. 서버 실행: 터미널에서 node index. js 명령을 실행하여 서버를 시작합니다. 1$ node index. js브라우저를 열고, http://127. 0. 0. 1:3000/에 접속하면, Hello, World! 메시지를 확인하실 수 있습니다.  Node. js 프로젝트 관리 및 확장기본적인 Node. js 프로젝트를 설정하고, 서버를 실행해보는 것에 더하여 프로젝트를 관리하고 확장하는 방법에 대하여 설명하겠습니다. Express. js: Express. js는 Node. js를 위한 빠르고 간단한 웹 프레임워크로, 서버 어플리케이션 개발을 더욱 쉽게 만들어줍니다. 다음 명령어로 express를 설치해줍니다. 1$ npm install expressExpress. js를 설치한 후, 서버 코드를 수정하여 Express. js를 사용하도록 변경해보겠습니다. 위에서 작성했던 index. js 파일을 다음과 같이 수정합니다. 1234567891011const express = require('express');const app = express();const port = 3000;app. get('/', (req, res) =&gt; { res. send('Hello, World!');});app. listen(port, () =&gt; { console. log(`Server running at http://localhost:${port}/`);});위 코드는 Express. js를 사용하여 동일한 서버 기능을 구현한 것입니다. 터미널에서 다시 서버를 실행하고, 브라우저를 새로고침하면 동일하게 Hello, World! 메시지를 확인하실 수 있습니다. Nodemon: 현재는 개발 중 코드 변경 시마다 서버를 수동으로 재시작해야 하는 불편함이 있습니다. Nodemon은 이러한 문제를 해결해주는 도구로, 코드 변경을 감지하여 자동으로 서버를 재시작해줍니다. 다음 명령어로 Nodemon을 설치할 수 있습니다. 1$ npm install -g nodemon만약 위 명령어를 실행했는데 permission 에러가 발생한다면, sudo npm install -g nodemon 명령어를 사용해주세요. Nodemon을 설치했다면, node index. js 명령어 대신 nodemon index. js 명령어를 통해 서버를 실행하실 수 있습니다. 1$ nodemon index. js이렇게하면 코드 변경 시마다 Nodemon이 자동으로 서버를 재시작해주기 때문에 편하게 개발을 진행할 수 있습니다. 이번 포스팅에서는 Node. js 설치부터 첫 프로젝트를 시작하는 방법을 다루었습니다. Node. js는 서버 측 어플리케이션 개발에 강력한 도구이며, Express. js와 Nodemon 같은 도구를 사용하면 개발 생산성을 크게 향상시킬 수 있습니다. 이 튜토리얼이 여러분의 프로젝트에 도움이 되기를 바랍니다. "
    }, {
    "id": 30,
    "url": "http://localhost:4000/python-string-formatting/",
    "title": "Python String Formatting 방법",
    "body": "2024/07/16 - python은 다양한 문자열 포맷팅 방법을 지원합니다. 본 포스팅에서는 각 방법의 사용법과 장단점 등에 대하여 설명하도록 하겠습니다. 참고로, python의 버전에 따라 지원되는 포맷팅 방법이 달라지기도 하니 사용하는 python의 버전을 확인하고 사용하시기 바랍니다. % operator% operator는 C 스타일로 문자열을 포맷팅하는 방법입니다. python3 이전에 사용되던 방법으로, python 버전에 상관이 없으며, C 문법에 익숙하다면 간단하게 사용할 수 있습니다. % operator를 사용하는 경우, 포맷팅하고자 하는 자료형의 데이터 타입이 동일해야 하는데, 때문에 자료형 별로 어떠한 문자열 포맷 코드를 사용해야 하는지를 알고 있어야 합니다. 사용 예시는 다음과 같습니다. 12&gt;&gt;&gt;  Hello %s  %  World 'Hello World'많이 사용되는 포맷 코드는 다음과 같습니다. 참고로 % 문자 자체를 출력하고 싶은 경우에는 %%를 사용합니다.       포맷 코드   설명         %s   문자열       %d   정수       %f   실수       %o   8진수       %x, %X   16진수 (lowercase, uppercase)       %c   단일 문자   포맷 코드와 연결된 데이터의 타입이 다를 경우에는 에러가 발생하게 됩니다. 예를 들어, %d 포맷 코드를 사용하였는데 문자열을 넣어주는 경우 TypeError가 발생합니다. 하지만 특이하게 %s 포맷 코드의 경우에는 어떠한 타입의 값이건 넣을 수 있습니다. 1234&gt;&gt;&gt;  I am %s years old  % 31'I am 31 years old'&gt;&gt;&gt;  Pi number is %s  % 3. 14'Pi number is 3. 14'위와 같이 정수 타입인 %d나 실수 타입인 %f를 쓰지 않아도 %s를 사용하면 자동으로 넘어오는 값들을 문자열로 바꾸어 대입해주게 됩니다. 여러 개의 값 사용하기: 문자열 안에 여러 개의 포맷 코드를 사용하는 경우에는 % 뒤에 오는 값들을 콤마로 구분하여 소괄호로 감싸야 합니다. 소괄호로 묶지 않으면 에러가 발생하게 됩니다. 값들은 순서대로 연결되며, 포맷 코드의 개수와 변수의 개수가 동일하여야 합니다. 1234&gt;&gt;&gt;  %d + %d = %d  % (1, 2, 3)'1 + 2 = 3'&gt;&gt;&gt;  Today is %d %s  % (6, 'June')'Today is 6 June'값들이 소괄호로 묶여 있지 않다거나(이 경우 값이 하나만 넘어온 것으로 간주됩니다), 값이 적거나 많은 경우에는 다음과 같이 에러가 발생합니다. 123456&gt;&gt;&gt;  %d + %d = %d  % 1, 2, 3TypeError: not enough arguments for format string&gt;&gt;&gt;  %d + %d = %d  % (1, 2)TypeError: not enough arguments for format string&gt;&gt;&gt;  %d + %d = %d  % (1, 2, 3, 4, 5)TypeError: not all arguments converted during string formatting장단점: 낮은 버전의 python에서도 호환이 된다는 장점이 있으나, % operator의 경우, 사용하고자 하는 데이터의 타입이 정확히 일치해야 한다는 단점이 있습니다. 또한, 포맷팅할 문자열이 길어지는 경우 가독성이 매우 떨어집니다. 때문에 사용을 권장하지는 않습니다. str. format()python3에서 도입된 방법으로, % operator보다 더 유연하고 읽기 쉬운 포맷팅을 제공합니다. 사용 예시는 다음과 같습니다. 1234&gt;&gt;&gt; name =  Bob &gt;&gt;&gt; age = 25&gt;&gt;&gt;  Hi, my name is {}. I'm {} years old.  . format(name, age) Hi, my name is Bob. I'm 25 years old.  인덱스 및 키워드를 사용한 포맷팅: 다음과 같이 인덱스를 사용하여 순서를 지정해 줄 수도 있습니다. 123&gt;&gt;&gt; greeting =  Hi, my name is {0}. I'm {1} years old.  &gt;&gt;&gt; greeting. format('Bob', 25) Hi, my name is Bob. I'm 25 years old.  혹은 다음과 같이 키워드를 사용하여 포맷팅을 할 수도 있습니다. 이 경우에는 매개변수의 순서가 상관이 없어집니다. 123&gt;&gt;&gt; greeting =  Hi, my name is {name}. I'm {age} years old.  &gt;&gt;&gt; greeting. format(name='Bob', age=25) Hi, my name is Bob. I'm 25 years old.  장단점: str. format() 메소드는 % operator보다는 가독성이 좋아졌지만, 여러 매개변수와 긴 문자열을 처리할 때는 역시나 가독성이 떨어진다는 단점이 있습니다. 때문에 python3. 6 이상이라면 아래에서 설명할 f-string 사용이 권장됩니다. 하지만 낮은 버전의 python3와의 하위 호환이 필요한 경우, str. format() 메소드를 사용하는 것이 좋습니다. f-string (문자열 리터럴)f-string은 python3. 6부터 도입된 가장 현대적인 포맷팅 방법으로, 표현식의 삽입이 가능하다는 장점이 있습니다. 가독성이 매우 뛰어나며, 속도도 빠르기 때문에 하위 버전 호환이 필요한 경우가 아니라면 f-string 사용이 권장됩니다. f-string을 사용하려면 문자열 앞에 f 혹은 F를 붙이고, 중괄호({}) 안에 매개변수를 입력해주면 됩니다. 사용 예시는 다음과 같습니다. 1234&gt;&gt;&gt; name =  Bob &gt;&gt;&gt; age = 25&gt;&gt;&gt; greeting = f Hi, my name is {name}. I'm {age} years old.   Hi, my name is Bob. I'm 25 years old.  다양한 f-string 사용 방법: f-string을 사용하면 다음과 같이 표현식을 사용하여 문자열을 포맷팅 할 수도 있습니다. 1234&gt;&gt;&gt; a = 5&gt;&gt;&gt; b = 10&gt;&gt;&gt; f {a} plus {b} is {a + b} '5 plus 10 is 15'f-string은 여러 줄에 걸쳐서 사용할 수도 있습니다. 다중 라인 포맷팅을 위해 삼중 따옴표(''' 혹은    )를 사용합니다. 12345678&gt;&gt;&gt; name =  Alice &gt;&gt;&gt; age = 30&gt;&gt;&gt; address =  Seoul &gt;&gt;&gt; f   Name = {name}Age = {age}Address = {address}   장단점: f-string은 간결하고 강력한 문자열 포맷팅 방법입니다. 변수, 표현식, 함수 호출 등 다양한 요소를 삽입하여 손쉽게 문자열 포맷팅을 할 수 있습니다. f-string을 사용하면 코드의 가독성이 높아질 뿐만 아니라, 문자열 처리 속도 또한 향상됩니다. 하지만 파이썬 3. 6 이상에서만 사용할 수 있기 때문에 하위 버전과의 호환이 필요한 경우 사용이 제한된다는 단점이 있습니다. 또, 외부 입력값을 f-string에 직접 사용할 때는 악의적인 코드가 실행될 수 있기 때문에 주의가 필요합니다. 문자열 포맷팅 옵션정렬: 간단한 옵션 사용을 통해 문자열을 왼쪽, 오른쪽, 가운데 정렬하여 표시되도록 할 수 있습니다. 왼쪽 정렬은 {:&lt;}, 오른쪽 정렬은 {:&gt;}, 가운데 정렬은 {:^}를 사용합니다. 뒤에 따라오는 숫자는 몇 칸을 사용할 것인지를 의미하며, 문자열의 길이가 해당 숫자보다 긴 경우에는 정렬이 적용되지 않습니다. 사용 예시는 다음과 같습니다. 1234567&gt;&gt;&gt; text =  align &gt;&gt;&gt; f {text:&lt;10} 'align   '&gt;&gt;&gt; f {text:&gt;10} '   align'&gt;&gt;&gt; f {text:^10} ' align  '참고로, 정렬은 남는 공간이 공백으로 채워지는 것으로, 공백이 아닌 다른 문자로 채우고 싶다면 &lt;, &gt;, ^ 기호 앞에 원하는 특정 문자를 입력하면 됩니다. 123&gt;&gt;&gt; text =  align &gt;&gt;&gt; f {text:. ^10} '. . align. . . '숫자 포맷팅: 숫자에 대해서도 마찬가지로 간단한 옵션 사용을 통해 소수점 이하 자리수를 지정하거나({:. nf}), 천 단위 구분 기호를 추가하는 등({:,. nf})의 동작을 할 수 있습니다. 사용 예시는 다음과 같습니다. 12345&gt;&gt;&gt; number = 1234. 56789&gt;&gt;&gt; f {number:. 2f} '1234. 57'&gt;&gt;&gt; f {number:,. 2f} '1,234. 57'여기까지 파이썬에서 제공하는 문자열 포맷팅 방법에 대하여 알아보았습니다. 문자열 포맷팅 방법은 기본적으로 f-string의 사용을 권장하지만, 상황에 맞게 최적의 포맷팅 방법을 선택하여 사용하는 것이 필요합니다. 때문에 각 방식의 특징을 이해할 필요가 있습니다. 적절한 방법을 사용하는 것이 코드의 가독성을 높이고, 데이터를 더 효과적으로 표현할 수 있을 것입니다. "
    }, {
    "id": 31,
    "url": "http://localhost:4000/python-tutorial/",
    "title": "Python Tutorial - 5분만에 훑어보기",
    "body": "2024/07/15 - 파이썬(Python)은 간결함과 직관성 덕분에 프로그래밍 입문자 뿐만 아니라 숙련된 개발자들 사이에서도 널리 사용되고 있는 프로그래밍 언어입니다. 이번 포스팅에서는 파이썬의 기초를 간략하게 다루어 짧은 시간 안에 훑어볼 수 있도록 작성하겠습니다. 파이썬의 기본 문법과 데이터 타입, 변수, 제어문 등을 빠르게 살펴보실 수 있습니다. 파이썬 설치하기파이썬을 시작하려면 우선 공식 웹사이트에서 최신 버전을 다운로드하고 설치하셔야 합니다. 설치는 installer를 사용하여 간단하게 진행되며, 설치가 완료되면 명령 프롬프트나 터미널 등에서 python --version 명령어를 통해 설치된 파이썬의 버전을 확인하실 수 있습니다. 12$ python --versionPython 3. 12. 4만약 command not found: python 명령어가 표시된다면, python3 --version 명령어를 사용하면 됩니다. 파이썬 기본 문법파이썬은 간결한 문법을 자랑합니다. 다른 언어와 달리 중괄호({})를 사용하지 않고, 대신 들여쓰기를 사용하여 코드 블록을 구분합니다. 들여쓰기가 잘못 되면 잘못된 코드가 실행될 수 있지만, 가독성이 높아지는 효과가 있습니다. 주석: 코드를 작성함에 있어 코드를 설명하는 주석은 코드의 가독성을 높이는 데 중요한 역할을 하기 때문에 필수적인 요소입니다. 파이썬에서는 한 줄과 여러 줄 주석을 다른 방법으로 작성할 수 있습니다. 123456# 한 줄 주석은 샵(#)으로 시작합니다.    이 부분은 여러 줄 주석입니다. 여러 줄에 걸쳐 작성할 수 있습니다.    문자열: 파이썬에서 문자열은 큰따옴표( )나 작은따옴표(')로 감싸서 선언합니다. 만약 문자열 안에 큰따옴표가 있다면, 작은따옴표로 감싸 문자열을 생성하면 큰따옴표까지 문자열에 포함시킬 수 있습니다. 반대도 마찬가지로, 상황에 맞게 큰따옴표와 작은따옴표를 사용하면 됩니다. 1234&gt;&gt;&gt; print( Hello, world! )Hello, world!&gt;&gt;&gt; print(' Hi, My name is Chloe.  ') Hi, My name is Chloe.  변수와 데이터 타입변수란 값을 저장하는 공간으로, 파이썬에서는 값이 할당되면 자동으로 데이터 타입이 지정됩니다. 기본 데이터 타입: 기본 데이터 타입으로는, 정수(Integer, int), 실수(Floating point, float), 문자열(String, str), 불린(Boolean, bool)이 있습니다. 참고로, 불린 값은 대문자(True, False)로 시작해야 한다는 것에 주의해야 합니다. 12345678910111213&gt;&gt;&gt; a = 10&gt;&gt;&gt; b = 3. 14&gt;&gt;&gt; c =  Python &gt;&gt;&gt; d = True&gt;&gt;&gt; print(type(a))&lt;class 'int'&gt;&gt;&gt;&gt; print(type(b))&lt;class 'float'&gt;&gt;&gt;&gt; print(type(c))&lt;class 'str'&gt;&gt;&gt;&gt; print(type(d))&lt;class 'bool'&gt;리스트와 튜플: 리스트와 튜플은 여러 개의 값을 저장할 수 있는 데이터 타입입니다. 리스트는 대괄호([])를 사용하며, 값의 변경이 가능합니다. 반면에 튜플은 소괄호(())를 사용하며, 값의 변경이 허용되지 않는다는 차이점이 있습니다. 12345678910# listfruits = [ apple ,  banana ,  cherry ]print(fruits[0])fruits[1] =  blueberry print(fruits)# tuplecolors = ( red ,  green ,  blue )print(colors[1])colors[1] =  yellow  # 에러 발생 (값 변경 불가)딕셔너리: 딕셔너리는 키-값(key-value) 쌍으로 이루어진 데이터 타입입니다. 중괄호({})를 사용하여 정의하며, 키를 통해 값에 접근할 수 있습니다. 123456789student = {   name :  John ,   age : 21,   major :  Computer Science }print(student[ name ])student[ age ] = 22print(student)연산자파이썬은 다양한 연산자를 지원합니다. 기본적인 산술 연산자와 비교 연산자, 논리 연산자 등을 통해 연산을 수행할 수 있습니다. 산술 연산자: 1234567891011121314&gt;&gt;&gt; x = 10&gt;&gt;&gt; y = 3&gt;&gt;&gt; print(x + y)13&gt;&gt;&gt; print(x - y)7&gt;&gt;&gt; print(x * y)30&gt;&gt;&gt; print(x / y)3. 33333. . . &gt;&gt;&gt; print(x % y)1&gt;&gt;&gt; print(x ** y)1000비교 연산자: 1234567891011121314&gt;&gt;&gt; x = 10&gt;&gt;&gt; y = 3&gt;&gt;&gt; print(x == y)False&gt;&gt;&gt; print(x != y)True&gt;&gt;&gt; print(x &gt; y)True&gt;&gt;&gt; print(x &lt; y)False&gt;&gt;&gt; print(x &gt;= y)True&gt;&gt;&gt; print(x &lt;= y)False논리 연산자: 12345678&gt;&gt;&gt; a = True&gt;&gt;&gt; b = False&gt;&gt;&gt; print(a anad b)False&gt;&gt;&gt; print(a or b)True&gt;&gt;&gt; print(not a)False제어문제어문을 통해 코드의 분기를 만들고, 동일한 작업을 반복시킬 수 있습니다. 파이썬에서는 다른 언어들과 마찬가지로 조건문과 반복문을 제공합니다. 조건문: 파이썬의 조건문은 if, elif, else 키워드를 사용하여 조건에 따라 실행할 코드를 결정할 수 있습니다. 1234567age = 18if age &gt;= 20 :  print( Adult )elif age &gt;= 13 :  print( Teenager )else :  print( Child )반복문: 파이썬의 반복문은 for 혹은 while 키워드를 사용하여 특정 코드를 반복 실행하도록 할 수 있습니다. 아래 두 코드는 동일한 결과를 출력합니다. 123456789# for 문for i in range(5) :  print(i)# while 문count = 0while count &lt; 5 :  print(count)  count += 1함수함수는 코드의 재사용성을 높이고, 코드를 구조화하는 데 유용합니다. 파이썬에서는 def 키워드를 사용하여 함수를 정의할 수 있습니다. 12345def add(a, b) :  return a + bresult = add(3, 5)print(result)파이썬은 배우기 쉽고 강력한 기능을 제공하는 프로그래밍 언어로, 다양한 분야에서 활용되고 있습니다. 이번 포스팅에서는 파이썬의 기본 문법, 변수와 데이터 타입, 연산자, 제어문, 함수 등에 대하여 소개하였습니다. 이후 포스팅에서 파이썬에 대하여 보다 자세하게 설명하도록 하겠습니다. "
    }, {
    "id": 32,
    "url": "http://localhost:4000/jekyll-search/",
    "title": "Jekyll Blog(Github Pages) 검색 엔진에 노출시키기 (Google Search Console)",
    "body": "2024/07/03 - 블로그를 만들었다면 다른 사람들이 내 블로그를 검색해서 유입되길 기대할 겁니다. 하지만 Github Pages와 Jekyll로 만든 블로그의 경우 검색 엔진에 자동으로 노출되지 않기 때문에 직접 사이트맵을 등록하여 데이터가 수집되도록 해야 합니다. Google Search Console, Naver Search Advisor 등을 사용하여 각 검색 엔진마다 등록해 줄 수 있습니다. 이번 포스팅에서는 구글 검색 엔진에 등록하는 방법에 대해서 소개하도록 하겠습니다. Google Search Console구글에서는 구글 서치 콘솔(Google Search Console)을 통해 사이트맵을 등록하고, 검색을 통해 노출된 양과 유입된 내용을 확인할 수 있습니다. 참고로 구글 서치봇이 정보를 수집하는 데에 길게는 한 달까지도 소요될 수 있으며, 수집이 완료되었다고 해서 검색 상단에 노출되는 것이 보장되지는 않습니다. 시작하기: 우선 구글 서치 콘솔(Google Search Console) 사이트에 접속합니다. 여기서 URL 접두어 항목에 github pages blog url을 입력하고 계속을 클릭합니다. 만약 도메인을 따로 구매한 경우라면, 왼쪽에 위치한 도메인 항목에 입력하면 됩니다.  소유권 확인하기: 다음으로 소유권 확인 과정이 필요합니다. 여기서 선택할 수 있는 방법들이 몇 가지 있는데, 사용 중인 테마에 따라서 특정 방법을 사용해야 한다던가 하는 제약이 있을 수는 있습니다. 참고로, 이전 포스팅을 통해 Google Analytics를 설정한 상태라면 보다 편리하게 소유권을 확인할 수도 있습니다.  HTML 파일 업로드: 첫 번째로 권장되는 방법은 HTML 파일을 직접 업로드하는 것입니다. 올려져 있는 . html 파일을 다운 받아 가장 상위 폴더에 해당 파일을 위치시키면 됩니다. 특정 URL에 파일을 업로드할 수 없는 경우에는 사용할 수 없지만, github pages로 만든 블로그에는 적용이 가능합니다.  HTML 태그 추가: 두 번째 방법은 HTML 메타 태그를 추가하는 것입니다. jekyll에서는 header 부분을 세팅할 수 있기 때문에 적용이 가능합니다. 다만, header를 수정할 수 없는 경우에는 사용할 수 없다는 단점이 있습니다.  Google 애널리틱스 계정 사용: 또 다른 방법으로, Google Analytics 연결하기를 마친 경우라면, 별다른 코드의 수정이나 파일 업로드 없이 소유권 확인이 가능합니다. 보다 간편한 방법이기도 하고, Google Analytics를 사용하는 경우라면 해당 방법을 추천드립니다.  설정을 마친 후, 확인 버튼을 클릭하면, 정상적으로 소유권 확인이 되었다면 다음과 같은 화면이 표시됩니다.  sitemap 제출하기: 이제 sitemap을 제출하여 서치봇이 블로그의 글들을 크롤링할 수 있도록 해 줍니다. sitemap을 만드는 방법에 대해서는 다음 포스팅에서 따로 정리하도록 하고, 여기서는 이미 생성되어 있는 sitemap을 제출하는 과정에 대해서만 설명하겠습니다. 참고로, https://chloeeekim. github. io/sitemap. xml과 같이 블로그 주소 뒤에 sitemap. xml을 붙여 sitemap 파일이 존재하는지 확인할 수 있습니다. 특정 테마들의 경우 이미 sitemap이 생성되어 있을 것입니다. 왼쪽 메뉴 탭에서 색인 &gt; Sitemaps 메뉴로 이동합니다. 그런 다음, URL에 sitemap. xml을 입력하고 제출합니다.  시간이 지나면 자동으로 구글 서치봇이 sitemap에 있는 페이지들을 크롤링하여 색인을 생성하게 됩니다. 이 시간은 경우에 따라 시간이 오래 걸릴 수 있기 때문에 빠른 색인 생성을 위해 추가적인 작업을 해 주면 좋습니다. URL 검사를 통한 색인 생성 요청: 왼쪽 메뉴 탭에서 URL 검사를 클릭하거나, 상단에 위치한 서치 바에서 원하는 url을 입력하여 검사를 시도합니다. https://chloeeekim. github. io/jekyll-search/와 같이 특정 포스팅을 검사해줍시다. 다음과 같이 표시되면 해당 페이지는 아직 색인이 생성되지 않은 상태인 것을 알 수 있습니다.  여기서 색인 생성 요청을 통해 해당 페이지의 색인 생성을 요청할 수 있습니다. 클릭하면 색인을 생성할 수 있는지를 테스트하면서 약 1~2분의 시간이 지난 후 색인 생성이 요청됩니다.  구글의 경우 색인 생성이 완료되기까지 그렇게 오랜 시간이 소요되지는 않았습니다. 제 경험상 24시간 이내로 색인 생성이 완료되었습니다. 하지만 상황에 따라 시간이 더 많이 걸리거나 적게 걸릴 수 있다는 점 참고 부탁드립니다. 색인이 생성된 url을 검사하면 다음과 같이 표시되어 상세한 정보를 확인할 수 있습니다.  이렇게 구글 서치 콘솔을 이용하여 구글에 블로그 포스팅이 검색되도록 해보았습니다. 검색 엔진에 노출시키는 과정은 시간이 오래 걸리기 때문에 최대한 빠르게 등록해주시는 게 좋습니다. 참고로 저의 경우에는 sitemap을 통해 색인 생성이 완료되는 데까지 1주일 이내의 시간이 소요되었습니다. "
    }, {
    "id": 33,
    "url": "http://localhost:4000/jekyll-google-analytics/",
    "title": "Jekyll Blog(Github Pages)에 Google Anayltics 연결하기",
    "body": "2024/06/29 - Github Pages와 Jekyll로 생성한 블로그의 경우, 트래픽 분석 등을 따로 제공하지 않기 때문에 누가 어떤 방식으로 내 블로그에 유입되었는지 알기 힘들다는 한계점이 있습니다. 이를 보완하기 위하여 Google Analytics를 통해 누가, 얼마나, 어떤 방식으로, 어느 지역에서 유입되는지를 확인할 수 있습니다. 참고로, 2024년 현재 구글 애널리틱스(Google Analytics, GA)는 GA4 버전만 생성 가능합니다. 이전 버전인 유니버셜 애널리틱스(Universal Analytics, UA)는 추후 지원이 되지 않을 수 있습니다. GA 계정 만들기우선 GA를 적용하기 위해 GA 계정부터 생성해야 합니다. Google Analytics에 접속하여 계정부터 설정해줍니다. 첫 번째로 계정 ID를 등록합니다. 여러 개의 ID를 생성할 수도 있습니다.  두 번째로 GA를 통해 관리할 url을 속성에 넣어줍니다. 저는 제 github. io 주소를 입력하였습니다. 또, 시간대와 통화 등을 대한민국으로 설정을 바꿔주면 되는데, 추후에 변경할 수도 있으니 넘어가셔도 좋습니다.  이후에 비즈니스 세부정보, 목표 등을 적당히 설정해주고, 데이터 수집과 관련한 사항에 동의해줍니다. 마지막으로 데이터 소스 플랫폼을 웹으로 선택해줍니다.  데이터 스트림 설정에서는 관리할 사이트의 url을 입력하고, 우측 상단의 만들고 계속하기를 클릭합니다.  이제 측정 ID가 부여됩니다. 이 ID가 G-XXXXXXXX 형식인 것이 GA4 버전입니다. UA 버전의 경우 UA-XXXXXXXX-X와 같은 형식으로 나타납니다.  여기서 태그 사용을 선택하고 다음으로 넘어가면, 아래와 같은 화면이 표시됩니다. 아직 태그를 설정해주지 않았기 때문에 데이터 수집이 활성화되어 있지 않은 상태입니다. 이제 블로그에 GA를 연결할 준비가 완료되었습니다. 참고로 아래 내용은 설정 &gt; 데이터 수집 및 수정 &gt; 데이터 스트림에서도 확인할 수 있습니다.  Jekyll 블로그에 GA 연결하기블로그의 설정 등에 따라 방법이 여러 가지로 나뉠 수 있습니다. 저처럼 특정 테마를 사용하여 블로그를 세팅한 경우에는 블로그에서 지원하는 버전이 UA일 수 있습니다. 사용하고 있는 테마의 document나 _config. yml 파일을 살펴봅니다. 예시가 GA4 버전인 경우: 여기서 G-XXXXXXXX 형식의 태그가 예시로 되어 있다면 별다른 변경 없이 발급받은 측정 ID를 _config. yml에 다음과 같이 추가해주기만 하면 됩니다. 1google_analytics:  G-XXXXXXXX 예시가 UA 버전인 경우: 하지만 UA-XXXXXXXX-X와 같은 형식의 태그가 예시로 되어 있다면, 유니버셜 애널리틱스를 기준으로 테마가 만들어져 있는 상태입니다. 따라서 GA4 태그를 사용하기 위해서는 수정이 불가피합니다. 우선 설정 &gt; 데이터 수집 및 수정 &gt; 데이터 스트림 &gt; 태그 안내 보기로 들어갑니다. 상단의 탭에서 직접 설치를 클릭하면 다음과 같이 gtag 코드가 나옵니다.  123456789&lt;!-- Google tag (gtag. js) --&gt;&lt;script async src= https://www. googletagmanager. com/gtag/js?id=G-XXXXXXXXXX &gt;&lt;/script&gt;&lt;script&gt; window. dataLayer = window. dataLayer || []; function gtag(){dataLayer. push(arguments);} gtag('js', new Date()); gtag('config', 'G-XXXXXXXXXX');&lt;/script&gt;설명에도 나와있듯, 해당 코드를 &lt;head&gt; 요소 안에 붙여 넣으면 됩니다. 여기서도 테마마다 설정하는 방법이 달라집니다. _includes 폴더에 analytics. html이 있는 경우에는 해당 파일을 수정하면 되는데, 없는 경우에는 &lt;head&gt; 요소를 붙이는 파일을 찾아야 합니다. 저는 _layouts 폴더에 있는 default. html 파일을 수정하였습니다. GA 연결 확인하기수정된 코드를 github에 올리고, 빌드가 완료될 때까지 몇 분 정도 기다려줍니다. 빠르게 확인할 수 있는 방법으로 개발자 도구 &gt; Console에 gtag를 입력해 볼 수 있습니다. 제대로 연결되지 않았다면 Uncaught ReferenceError가 발생하고, 제대로 연결된 경우 다음과 같이 gtag를 확인할 수 있습니다.  Google Analytics에서는 보고서 &gt; 실시간 탭에서 사용자가 확인되면 GA 연결은 성공적으로 끝납니다.  "
    }, {
    "id": 34,
    "url": "http://localhost:4000/jekyll-setup-windows/",
    "title": "Github pages와 Jekyll 설치하기 - Windows ver.",
    "body": "2024/06/26 - jekyll은 github pages를 지원하는 정적 웹사이트 생성기입니다. 저장되어 있는 html, markdown 파일을 그대로 가져와서 선택한 레이아웃에 따라 html 코드로 변환해 정적 웹사이트를 생성해줍니다. jekyll은 매우 가벼우며, liquid 언어를 지원하여 동적 컨텐츠 로드가 가능하다는 장점이 있습니다. 또한 markdown 언어를 사용하기 때문에 문법이 쉽고, 작성이 간편하다는 것도 장점입니다. 사실 windows는 jekyll이 공식적으로 지원되는 플랫폼은 아닙니다. 하지만 실행이 불가능한 것은 아니기 때문에 약간의 수정을 통해 실행시킬 수 있습니다. Github Pages 생성하기github 계정이 있다는 전제하에, 새 repository를 생성하는 것으로 시작합니다. github pages를 사용하기 위해서는 특정한 repository의 이름을 설정해야 하는데, githubId. github. io와 같은 형식으로 설정해줘야 합니다. github id가 아닌 다른 repository 이름을 설정하는 경우, 추가적인 세팅이 필요해지기 때문에 되도록이면 id를 사용합니다.  저의 경우에는 이미 chloeeekim. github. io repository가 있다고 표시됩니다. repository의 세팅은 변경할 내용 없이 생성해도 괜찮습니다. repository가 만들어지면 github pages도 생성이 완료된 것입니다. github pages가 잘 동작하는지 알고 싶다면, repository에 index. html이라는 이름으로 원하는 내용을 입력하고 commit 해줍니다. 약간의 시간이 지나고 나서 githubId. github. io에 접속하면, 입력한 내용이 표시되는 것을 확인할 수 있습니다. 이제 github pages를 사용할 준비는 끝났습니다. Ruby 및 Jekyll 설치하기jekyll을 사용하기 위해서는 먼저 ruby를 설치해야 합니다. ruby를 설치하는 방법은 다양하지만, windows에서는 ruby installer를 이용하면 간단하게 설치할 수 있습니다. ruby installer download 페이지에 가서 ruby installer를 다운받아 주면 됩니다.  사이트 좌측 상단을 보면 WITH DEVKIT 항목이 있는데, 꼭 Ruby+Devkit 버전을 다운받아야 합니다. 설치는 간단하게 진행되며, optional한 부분은 건드릴 필요 없이 기본 옵션으로 설치하면 됩니다. ruby installer는 windows를 기반으로 ruby 언어와 실행 환경 등을 포함하고 있습니다. 참고로 ruby installer 2. 4 버전 이전의 경우에는 devkit을 따로 설치해야 합니다. ruby installer 설치가 완료되었다면, ruby command prompt를 실행해줍니다.  12% ruby --versionruby 3. 1. 2p20 (2022-04-12 revision 4491bb740a) [x64-mingw-ucrt]ruby --version 명령어로 루비 정보가 표시된다면 정상적으로 설치가 완료된 것입니다. 그런 다음, jekyll과 bundler를 설치해 줍니다. 1gem install jekyll bundler설치가 완료되면, 다음 명령어로 jekyll이 잘 설치되었는지도 확인할 수 있습니다. 12% jekyll -vjekyll 4. 3. 3Jekyll Theme 적용기존에 존재하는 테마를 사용하지 않을 수도 있지만, jekyll의 또 다른 장점 중 하나가 무료로 제공되는 다양한 테마가 굉장히 많다는 것입니다. 다음 사이트들에서 어마어마한 테마들을 구경하고 선택할 수 있습니다.  https://jekyllthemes. org https://jekyllthemes. io/free http://themes. jekyllrc. org위 사이트에서 마음에 드는 테마를 찾아 사용하거나 혹은 github에서 jekyll-theme 등으로 검색하여 찾을 수도 있습니다. 우선 테마를 사용하여 설정을 마친 다음에는 원하는 대로 커스터마이징을 할 수 있기도 하고, 언제든 테마를 바꿀 수도 있으니 마음 편하게 테마를 고르시면 됩니다. 저는 mediumish라는 테마를 선택하였습니다. 꼭 같은 테마가 아니어도 상관 없으니, 원하시는 테마를 선택합니다. 테마를 골랐다면, 해당 테마의 github 페이지로 이동하여 code를 다운받아 줍니다. clone을 해도 상관없고, . zip 파일로 받아도 됩니다. 다운받은 파일들을 위에서 생성한 github pages repository에 옮겨줍니다. ruby command prompt에서 내 repository가 가져와진 경로로 이동하여 아래 명령어들을 순서대로 실행해줍니다. 12bundle installbundle update문제 없이 설치가 끝났다면, 로컬 서버를 실행할 시간입니다. 로컬 서버 실행아래 명령어 중 하나로 jekyll server를 로컬에서 실행할 수 있습니다. 12bundler exec jekyll servejekyll serve실행시키면 Server address: http://127. 0. 0. 1:4000/와 같이 로컬 서버 주소가 표시됩니다. 참고로 --serve 옵션을 통해 변경사항을 자동으로 감지하도록 할 수도 있습니다. 이후에는 로컬 서버에 접속하여 실제로 실행시켜 볼 수 있습니다. 각종 에러에 대처하기jekyll을 설치하고 실행할 수 있다고는 하지만, windows는 공식적으로 지원되는 플랫폼이 아니기 때문에 에러가 발생하는 경우가 있습니다. 아래에서 몇 가지 에러에 대처하는 방법을 설명하겠습니다. Liquid Exception: Incompatible character encoding: UTF-8 인코딩을 사용하는 경우 발생할 수 있는 에러입니다. 예를 들어, windows 계정명이 한글인 경우가 있을 수 있습니다. C:\User\계정명처럼 한글이 포함된 경로 때문에 에러가 발생할 수 있습니다. 이 경우 다음 명령어를 통해 UTF-8 인코딩 옵션을 켜주면 해결이 가능합니다. 1chcp 65001cannot load such file -- webrick (LoadError): webrick을 찾을 수 없어서 발생하는 에러입니다. 따라서 webrick을 추가해주면 해결이 가능합니다. 1bundle add webrickAn error occurred while installing wdm (0. 1. 1), and Bundler cannot continue. : wdm 설치에 실패하여 발생하는 에러입니다. windows에서 --watch 옵션을 사용하기 위해서는 wdm을 설치해야 하는데, 만약 --watch 옵션을 사용하지 않을 것이라면 Gemfile에서 아래 코드를 주석 처리하여 줍니다. 1gem  wdm ,  ~&gt; 0. 1. 1 , :platforms =&gt; [:mingw, :x64_mingw, :mswin]--watch 옵션을 사용하고 싶은 경우에는 현재 ruby의 버전을 특정 버전으로 낮추는 방법 밖에는 없습니다. 우선 설치되어 있는 ruby를 완전히 삭제하고, C:\ 드라이브에 있는 Ruby 관련 폴더도 삭제해줍니다. 이후 ruby 3. 1. 2-1 버전을 다운받아 설치한 후, bundle install부터 다시 실행시켜 주면 해결이 가능합니다. "
    }, {
    "id": 35,
    "url": "http://localhost:4000/minimum-depth-of-binary-tree/",
    "title": "[Leetcode] 111. Minimum Depth of Binary Tree",
    "body": "2019/10/28 - binary tree가 주어졌을 때, 해당 트리의 minimum depth를 구하는 문제  root 노드의 depth는 1이다. Example 1:  Input : root = [3,9,20,null,null,15,7] Output : 2Example 2:  Input : root = [2,null,3,null,4,null,5,null,6] Output : 5Solution 1Note:  queue를 사용하여 level order로 순회 level(depth)를 [node, level]의 형태로 queue에서 관리12345678910111213141516171819202122232425# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def minDepth(self, root: TreeNode) -&gt; int:    if not root :      return 0    res = -1    queue = [[root, 1]]    while queue :      temp = queue. pop(0)      node, level = temp[0], temp[1]      if res != -1 and level &gt;= res :        break      if not node. left and not node. right :        res = (min(res, level) if res != -1 else level)      if node. left :        queue. append([node. left, level + 1])            if node. right :        queue. append([node. right, level + 1])    return resSolution 2Note:  recursive하게 해결 한 단계씩 들어갈 때마다 depth 값을 1씩 증가 minimum 값을 구해야 하므로 sys. maxsize 값과 비교12345678910111213141516171819# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def minDepth(self, root: TreeNode) -&gt; int:    if not root :      return 0    if not root. left and not root. right:      return 1    depth = sys. maxsize    if root. left:      depth = self. minDepth(root. left)    if root. right:      depth = min(depth, self. minDepth(root. right))    return depth+1"
    }, {
    "id": 36,
    "url": "http://localhost:4000/binary-tree-level-order-traversal/",
    "title": "[Leetcode] 102. Binary Tree Level Order Traversal",
    "body": "2019/10/28 - binary tree가 하나 주어졌을 때, 해당 트리의 level order traversal의 결과를 구하는 문제  왼쪽에서 오른쪽 순서로 순회하며, 레벨별로 나타내어야 한다. Example 1:  Input : root = [3,9,20,null,null,15,7] Output : [[3],[9,20],[15,7]]Example 2:  Input : root = [1] Output : [[1]]Example 3:  Input : root = [] Output : []Solution 1Note:  queue를 사용하여 해결 해당 노드의 level을 확인하기 위하여 queue에서 [node, level]의 형태로 관리12345678910111213141516171819202122232425# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:    if not root :      return []    res = [[]]    queue = [[root, 0]]    while queue :      temp = queue. pop(0)      node, level = temp[0], temp[1]      if len(res) &lt;= level :        res. append([node. val])      else :        res[level]. append(node. val)            if node. left :        queue. append([node. left, level + 1])      if node. right :        queue. append([node. right, level + 1])    return resSolution 2Note:  queue를 사용하여 해결 각 레벨별로 tqueue와 tnodes 리스트를 두어 한 레벨이 끝날 때마다 queue와 결과 리스트를 갱신하는 방식123456789101112131415161718192021222324# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:    if not root:      return []    res = []    queue, tqueue, tnodes = [root], [], []    while queue:      node = queue. pop(0)      tnodes. append(node. val)      if node. left:        tqueue. append(node. left)      if node. right:        tqueue. append(node. right)      if not queue:        res. append(tnodes)        queue, tqueue, tnodes = tqueue, [], []    return res"
    }, {
    "id": 37,
    "url": "http://localhost:4000/sqrtx/",
    "title": "[Leetcode] 69. Sqrt(x)",
    "body": "2019/10/27 - 양의 정수가 하나 주어졌을 때, 해당 정수의 제곱근을 구하는 문제  정수 형태로 출력한다. (소수점 아래로는 내림 처리한다. )Example 1:  Input : x = 4 Output : 2Example 2:  Input : x = 8 Output : 2123class Solution:  def mySqrt(self, x: int) -&gt; int:    return int(x ** 0. 5)"
    }, {
    "id": 38,
    "url": "http://localhost:4000/permutations-ii/",
    "title": "[Leetcode] 47. Permutations II",
    "body": "2019/10/27 - 중복되는 숫자가 포함된 리스트가 주어졌을 때, 이를 이용해 만들 수 있는 모든 permutation들을 구하는 문제 Example 1:  Input : nums = [1,1,2] Output : [[1,1,2],[1,2,1],[2,1,1]]Example 2:  Input : nums = [1,2,3] Output : [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]Solution 1Note:  rec() 함수를 생성하여 recursive하게 해결 앞에서 만들어진 리스트(temp)와 남은 리스트(remain)를 관리12345678910111213141516class Solution:  def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:    res = []    def rec(self, temp: List[int], remain: List[int]):      if not remain :        if temp not in res :          res. append(temp)        return      seen = remain[0] - 1      for i, num in enumerate(remain) :        if num != seen :          rem = remain[:i] + remain[i+1:]          rec(self, temp + [num], rem)          seen = num    rec(self, [], nums)    return resSolution 2Note:  itertools의 permutations 함수를 사용 set으로 중복을 제거한 후, list의 형태로 변경하여 리턴12345from itertools import permutationsclass Solution:  def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:    return list(set(permutations(nums)))"
    }, {
    "id": 39,
    "url": "http://localhost:4000/merge-intervals/",
    "title": "[Leetcode] 56. Merge Intervals",
    "body": "2019/10/27 - interval들의 collection이 주어졌을 때, 겹치는 모든 interval들을 합치는 문제 Example 1:  Input : intervals = [[1,3],[2,6],[8,10],[15,18]] Output : [[1,6],[8,10],[15,18]]Example 2:  Input : intervals = [[1,4],[4,5]] Output : [[1,5]]Note: interval들을 sorting 한 후, 하나씩 비교하면서 합치는 방식으로 해결 1234567891011class Solution:  def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:    i = 0    intervals. sort()    while i &lt; len(intervals) - 1 :      if intervals[i][1] &gt;= intervals[i+1][0] :        intervals[i][1] = max(intervals[i][1], intervals[i+1][1])        del intervals[i+1]      else :        i += 1    return intervals"
    }, {
    "id": 40,
    "url": "http://localhost:4000/letter-combinations-of-a-phone-number/",
    "title": "[Leetcode] 17. Letter Combinations of a Phone Number",
    "body": "2019/10/27 - 숫자로 이루어진 문자열이 주어졌을 때, 이 숫자들로 나타낼 수 있는 모든 문자의 combination들을 구하는 문제  숫자는 2부터 9까지이다. (1은 해당하는 문자가 없다. ) 각 숫자에 맵핑되는 문자는 다음과 같다.      2: a, b, c / 3 : d, e, f / 4 : g, h, i / 5 : j, k, l / 6 : m, n, o / 7 : p, q, r, s / 8 : t, u, v / 9 : w, x, y, z   Example 1:  Input : digits = “23” Output : [“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]Example 2:  Input : digits = “” Output : []Example 3:  Input : digits = “2” Output : [“a”,”b”,”c”]Note:  getComb() 함수를 생성하여 recursive하게 해결 dict를 사용하여 각 숫자에 대응하는 문자의 리스트를 관리12345678910111213141516class Solution:  def letterCombinations(self, digits: str) -&gt; List[str]:    numbers = {'1' : [''], '2' : ['a', 'b', 'c'], '3' : ['d', 'e', 'f'],          '4' : ['g', 'h', 'i'], '5' : ['j', 'k', 'l'], '6' : ['m', 'n', 'o'],          '7' : ['p', 'q', 'r', 's'], '8' : ['t', 'u', 'v'], '9' : ['w', 'x', 'y', 'z']}        if digits == '' :      return []        res = []    def getComb(self, temp: str, point: int):      if point == len(digits) :        res. append(temp)        return      for ch in numbers[digits[point]] :        getComb(self, temp + ch, point + 1)    getComb(self,   , 0)    return res"
    }, {
    "id": 41,
    "url": "http://localhost:4000/add-binary/",
    "title": "[Leetcode] 67. Add Binary",
    "body": "2019/10/27 - 두 개의 binary string이 주어졌을 때, 두 binary의 합을 구하는 문제  결과 또한 binary string으로 나타내어야 한다.  입력되는 두 string은 모두 non-empty이며, 0과 1로만 이루어져 있다. Example 1:  Input : a = “11”, b = “1” Output : “100”Example 2:  Input : a = “1010”, b = “1011” Output : “10101”Note: a, b를 모두 뒤집은 다음 index 0부터 더해나가는 방식으로, 결과는 다시 뒤집어야 한다. 12345678910111213class Solution:  def addBinary(self, a: str, b: str) -&gt; str:    res =       up = 0    a, b = a[::-1], b[::-1]    while a or b or up :      vala = int(a[0] if a else 0)      valb = int(b[0] if b else 0)      up, num = divmod(vala + valb + up, 2)      res += str(num)      a = (a[1:] if a else None)      b = (b[1:] if b else None)    return res[::-1]"
    }, {
    "id": 42,
    "url": "http://localhost:4000/permutations/",
    "title": "[Leetcode] 46. Permutations",
    "body": "2019/10/26 - 서로 다른 숫자로 이루어진 리스트가 주어졌을 때, 이를 이용해 만들 수 있는 모든 permutation들을 구하는 문제 Example 1:  Input : nums = [1,2,3] Output : [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]Example 2:  Input : nums = [0,1] Output : [[0,1],[1,0]]Example 3:  Input : nums = [1] Output : [[1]]Solution 1Note:  rec() 함수를 생성하여 recursive하게 해결 앞에서 만들어진 리스트(temp)와 남은 리스트(remain)를 관리 얕은 복사의 문제로 temp. append(num) 대신에 temp + [num]을, rem = remain. remove(num)이나 del num[i] 대신에 remain[:i] + remain[i+1:]을 사용123456789101112class Solution:  def permute(self, nums: List[int]) -&gt; List[List[int]]:    res = []    def rec(self, temp: List[int], remain: List[int]):      if not remain :        res. append(temp)        return      for i, num in enumerate(remain) :        rem = remain[:i] + remain[i+1:]        rec(self, temp + [num], rem)    rec(self, [], nums)    return resSolution 2Note: itertools의 permutations 함수를 사용 12345from itertools import permutationsclass Solution:  def permute(self, nums: List[int]) -&gt; List[List[int]]:    return permutations(nums)"
    }, {
    "id": 43,
    "url": "http://localhost:4000/combination-sum-ii/",
    "title": "[Leetcode] 40. Combination Sum II",
    "body": "2019/10/26 - candidate number의 set이 주어졌을 때, 이를 이용해 target number를 만들 수 있는 모든 unique한 combination을 구하는 문제  candidates 내의 각 숫자는 무조건 한 번만 사용되어야 한다.  target을 포함한 주어지는 모든 숫자는 양의 정수이다.  결과는 겹치는 combination을 포함해서는 안 된다. Example 1:  Input : candidates = [10,1,2,7,6,1,5], target = 8 Output : [[1,1,6],[1,2,5],[1,7],[2,6]]Example 2:  Input : candidates = [2,5,2,1,2], target = 5 Output : [[1,2,2],[5]]Note:  getComb() 라는 함수를 만들어서 recursive하게 해결 target과 동일한 값이 나오면 해당 combination을 res에 append target보다 작은 값일 경우, combination에 일단 포함시키고 다음 값을 고려 target보다 큰 값일 경우, 더 이상 진행하는 것이 의미가 없다.  (참고) candidates가 정렬되어 있다는 조건이 없다. 123456789101112131415class Solution:  def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:    res = []    candidates. sort()    def getComb(self, temp: List[int], tempSum: int, index: int) :      for i in range(index, len(candidates)) :        if tempSum + candidates[i] == target :          if temp + [candidates[i]] not in res :            res. append(temp + [candidates[i]])        elif tempSum + candidates[i] &gt; target :          break        else :          getComb(self, temp+[candidates[i]], tempSum+candidates[i], i+1)    getComb(self, [], 0, 0)    return res"
    }, {
    "id": 44,
    "url": "http://localhost:4000/invert-binary-tree/",
    "title": "[Leetcode] 226. Invert Binary Tree",
    "body": "2019/10/25 - binary tree가 주어졌을 때, 이를 좌우로 뒤집는 문제 Example 1:  Input : root = [4,2,7,1,3,6,9] Output : [4,7,2,9,6,3,1]Example 2:  Input : root = [2,1,3] Output : [2,3,1]Example 3:  Input : root = [] Output : []Note:  invert() 함수를 만들어서 해당 노드의 자식 노드 두 개를 바꾸어주는 방식으로 구현123456789101112131415161718192021# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def invertTree(self, root: TreeNode) -&gt; TreeNode:    if not root :      return root    def invert(self, node: TreeNode):      temp = node. right      node. right = node. left      node. left = temp      if node. right :        invert(self, node. right)      if node. left :        invert(self, node. left)    invert(self, root)    return root"
    }, {
    "id": 45,
    "url": "http://localhost:4000/generate-parentheses/",
    "title": "[Leetcode] 22. Generate Parentheses",
    "body": "2019/10/25 - 숫자 n이 주어졌을 때, n쌍의 parentheses로 만들어지는 모든 조합을 찾는 문제 Example 1:  Input : n = 3 Output : [”((()))”,”(()())”,”(())()”,”()(())”,”()()()”]Example 2:  Input : n = 1 Output : [”()”]Note:  parenthesis() 함수로 recursive하게 해결 앞에서 사용한 (와 )의 개수를 함수 인자로 넘겨줌으로써 이후에 만들어질 수 있는 조합을 탐색123456789101112131415class Solution:  def generateParenthesis(self, n: int) -&gt; List[str]:    res = []    def parenthesis(self, temp: str, open: int, close: int) :      if close == n :        res. append(temp)        return      if open == n :        parenthesis(self, temp +  ) , open, close + 1)      else :        parenthesis(self, temp +  ( , open + 1, close)        if close + 1 &lt;= open :          parenthesis(self, temp +  ) , open, close + 1)    parenthesis(self,   , 0, 0)    return res"
    }, {
    "id": 46,
    "url": "http://localhost:4000/contains-duplicate/",
    "title": "[Leetcode] 217. Contains Duplicate",
    "body": "2019/10/25 - 숫자들이 포함된 리스트가 주어졌을 때, 해당 리스트에 중복된 값이 있는지를 구하는 문제  동일한 값이 두 번 이상 반복되는 것이 존재할 경우 true를 리턴한다.  모든 값이 한 번씩만 등장하는 경우 false를 리턴한다. Example 1:  Input : nums = [1,2,3,1] Output : trueExample 2:  Input : nums = [1,2,3,4] Output : falseExample 3:  Input : nums = [1,1,1,3,3,4,3,2,4,2] Output : trueNote: 중복을 허용하지 않는 set을 생성 후, set과 기존 list의 길이를 비교하여, set이 더 짧다면 중복이 존재하는 것임을 확인할 수 있다. 1234567class Solution:  def containsDuplicate(self, nums: List[int]) -&gt; bool:    setnums = set(nums)    if len(nums) != len(setnums) :      return True    else :      return False"
    }, {
    "id": 47,
    "url": "http://localhost:4000/combination-sum/",
    "title": "[Leetcode] 39. Combination Sum",
    "body": "2019/10/25 - candidate number의 set이 주어졌을 때, 이를 이용해 target number를 만들 수 있는 모든 unique한 combination을 구하는 문제  candidates 내의 숫자는 동일한 숫자를 몇 번을 반복해 사용해도 된다.  target을 포함한 주어지는 모든 숫자는 양의 정수이다.  결과는 겹치는 combination을 포함해서는 안 된다. Example 1:  Input : candidates = [2,3,6,7], target = 7 Output : [[2,2,3],[7]]Example 2:  Input : candidates = [2,3,5], target = 8 Output : [[2,2,2,2],[2,3,3],[3,5]]Example 3:  Input : candidates = [2], target = 1 Output : []Note:  getComb() 라는 함수를 만들어서 recursive하게 해결 target과 동일한 값이 나오면 해당 combination을 res에 append target보다 작은 값일 경우, combination에 일단 포함시키고 다음 값을 고려 target보다 큰 값일 경우, 더 이상 진행하는 것이 의미가 없다.  (참고) candidates가 정렬되어 있다는 조건이 없다. 123456789101112131415class Solution:  def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:    res = []    candidates. sort()    def getComb(self, temp: List[int], tempSum: int, index: int) :      for i in range(index, len(candidates)) :        if tempSum + candidates[i] == target :          temp = temp + [candidates[i]]          res. append(temp)        elif tempSum + candidates[i] &gt; target :          break        else :          getComb(self, temp+[candidates[i]], tempSum+candidates[i], i)    getComb(self, [], 0, 0)    return res"
    }, {
    "id": 48,
    "url": "http://localhost:4000/binary-tree-right-side-view/",
    "title": "[Leetcode] 199. Binary Tree Right Side View",
    "body": "2019/10/25 - binary tree가 주어졌을 때, 해당 트리를 오른쪽에서 본 결과를 구하는 문제  결과는 top에서 bottom 순서로 출력한다. Example 1:  Input : root = [1,2,3,null,5,null,4] Output : [1,3,4]Example 2:  Input : root = [1,null,3] Output : [1,3]Example 3:  Input : root = [] Output : []Solution 1Note:  getview() 함수를 만들어서 recursive하게 해결 왼쪽에서부터 depth first search로 트리를 순회하며 view 리스트를 갱신1234567891011121314151617181920212223# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def rightSideView(self, root: TreeNode) -&gt; List[int]:    if not root:       return []    view = []    def getview(self, node: TreeNode, depth: int) :      if len(view) &lt; depth :        view. append(node. val)      else :        view[depth-1] = node. val      if node. left :        getview(self, node. left, depth+1)      if node. right :        getview(self, node. right, depth+1)    getview(self, root, 1)    return viewSolution 2Note:  queue를 사용하여 해결 각 레벨별로 tqueue 리스트를 두어 한 레벨이 끝날 때마다 queue와 결과 리스트를 갱신하는 방식 가장 마지막에 방문한 node가 right side view에 해당하므로, 마지막 노드를 결과 리스트에 append1234567891011121314151617181920212223# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def rightSideView(self, root: TreeNode) -&gt; List[int]:    if not root:       return []    view = []    queue, tqueue = [root], []    while queue:      node = queue. pop(0)      if node. left:        tqueue. append(node. left)      if node. right:        tqueue. append(node. right)      if not queue:        view. append(node. val)        queue, tqueue = tqueue, []    return view"
    }, {
    "id": 49,
    "url": "http://localhost:4000/sum-root-to-leaf-numbers/",
    "title": "[Leetcode] 129. Sum Root to Leaf Numbers",
    "body": "2019/10/24 - binary tree가 주어졌을 때, root-to-leaf path의 숫자를 모두 더한 값을 구하는 문제  트리 노드는 0부터 9까지의 숫자만 포함한다.  root-to-leaf path의 예로 1-&gt;2-&gt;3이 있다면, 123으로 계산한다.  leaf 노드란 자식이 없는 노드를 의미한다. Example 1:  Input : root = [1,2,3] Output : 25 1-&gt;2, 1-&gt;3 두 가지 path가 있으므로, 12 + 13 = 25Example 2:  Input : root = [4,9,0,5,1] Output : 1026Note:  stack을 사용하여 depth-first search 방식으로 구현 부모노드에서부터 십진법을 계산하는 방식으로 해당 노드의 val을 path의 값으로 갱신12345678910111213141516171819202122232425# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def sumNumbers(self, root: TreeNode) -&gt; int:    if not root :      return 0    res = 0    stack = [root]    while stack :      node = stack. pop()            if not node. right and not node. left :        res += node. val      temp = node. val * 10      if node. right :        node. right. val += temp        stack. append(node. right)      if node. left :        node. left. val += temp        stack. append(node. left)       return res"
    }, {
    "id": 50,
    "url": "http://localhost:4000/path-sum-ii/",
    "title": "[Leetcode] 113. Path Sum II",
    "body": "2019/10/24 - binary tree와 정수 sum이 주어졌을 때, root-to-leaf path의 합이 sum과 동일한 모든 path를 구하는 문제  leaf 노드란 자식이 없는 노드를 의미한다. Example 1:  Input : root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output : [[5,4,11,2],[5,8,4,5]]Example 2:  Input : root = [1,2,3], targetSum = 5 Output : []Example 3:  Input : root = [1,2], targetSum = 0 Output : []Note:  getpath() 함수를 생성하여 recursive하게 해결 만약 leaf 노드이면서 path의 값이 sum과 동일한 값을 가지는 경우 res에 전체를 append 얕은 복사의 문제로 path. append(node. val) 대신 path = path + [node. val] 사용 (참고) 중간 노드의 값이 targetSum보다 커지면 아래 노드는 확인하지 않도록 구현하려 했으나, 음수 값이 포함되는 테스트 케이스가 존재하여 해당 조건은 삭제12345678910111213141516171819202122# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def pathSum(self, root: TreeNode, sum: int) -&gt; List[List[int]]:    if not root :      return []    res = []    def getpath(self, node: TreeNode, temp: int, path: List[int]) :      path = path + [node. val]      if (not node. right and not node. left) and (temp + node. val == sum) :        res. append(path)      if node. left :        getpath(self, node. left, temp + node. val, path)            if node. right :        getpath(self, node. right, temp + node. val, path)    getpath(self, root, 0, [])    return res"
    }, {
    "id": 51,
    "url": "http://localhost:4000/min-stack/",
    "title": "[Leetcode] 155. Min Stack",
    "body": "2019/10/24 - 주어진 함수를 포함하는 stack을 만드는 문제  push(x), pop(), top(), geetMin() 네 가지 함수를 만들어야 한다. Example 1:  Input : [“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”] [[],[-2],[0],[-3],[],[],[],[]] Output : [null,null,null,null,-3,null,0,-2]Note:  getMin 함수에서 소요 시간이 오래 걸려 최소값을 저장하는 리스트를 따로 관리 stack의 특성 상 요소가 제거되더라도(pop) min 리스트를 업데이트 해 줄 필요가 없다. 123456789101112131415161718192021222324252627282930313233class MinStack:  def __init__(self):           initialize your data structure here.                self. stack = []    self. min = []  def push(self, x: int) -&gt; None:    self. stack. append(x)    if not self. min :      self. min. append(x)    else :      self. min. append(min(self. min[-1], x))      def pop(self) -&gt; None:    self. stack. pop()    self. min. pop()  def top(self) -&gt; int:    return self. stack[-1]  def getMin(self) -&gt; int:    return self. min[-1]# Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj. push(x)# obj. pop()# param_3 = obj. top()# param_4 = obj. getMin()"
    }, {
    "id": 52,
    "url": "http://localhost:4000/maximum-depth-of-binary-tree/",
    "title": "[Leetcode] 104. Maximum Depth of Binary Tree",
    "body": "2019/10/24 - binary tree가 주어졌을 때, 해당 트리의 최대 depth를 구하는 문제  depth는 root 노드에서부터 leaf 노드까지의 길이를 의미한다.  leaf 노드란 자식이 없는 노드를 의미한다. Example 1:  Input : root = [3,9,20,null,null,15,7] Output : 3Example 2:  Input : root = [1,null,2] Output : 2Solution 1Note: stack을 사용하여 depth first search 방식으로 트리 탐색 1234567891011121314151617181920212223# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def maxDepth(self, root: TreeNode) -&gt; int:    if not root :      return 0    stack = [[root, 1]]    res = 0    while stack :      temp = stack. pop()      node = temp[0]      if not node. right and not node. left :        res = max(res, temp[1])      if node. right :        stack. append([node. right, temp[1] + 1])      if node. left :        stack. append([node. left, temp[1] + 1])    return resSolution 2Note:  recursive하게 해결 한 단계씩 들어갈 때마다 depth 값을 1씩 증가시키는 방식1234567891011121314151617# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def maxDepth(self, root: TreeNode) -&gt; int:    if not root:      return 0    depth = 0    if root. left:      depth = self. maxDepth(root. left)    if root. right:      depth = max(depth, self. maxDepth(root. right))    return depth+1"
    }, {
    "id": 53,
    "url": "http://localhost:4000/two-sum-ii-input-array-is-sorted/",
    "title": "[Leetcode] 167. Two Sum II - Input Array is Sorted",
    "body": "2019/10/23 - 주어진 정수 배열에서 두 값의 합이 찾고자 하는 값(target)일 경우, 두 인덱스를 반환하는 문제  주어진 정수 배열은 이미 증가하는 방향으로 정렬되어 있다.  인덱스는 non zero-based로 리턴해야 한다. (1부터 시작) 정확히 하나의 솔루션이 존재한다.  동일한 값은 두 번 사용할 수 없다. Example 1:  Input : numbers = [2,7,11,15], target = 9 Output : [1,2]Example 2:  Input : numbers = [2,3,4], target = 6 Output : [1,3]Example 3:  Input : numbers = [-1,0], target = -1 Output : [1,2]Note: dict 사용 (key : 확인한 정수값 / value : 인덱스) 12345678class Solution:  def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:    temp = {}    for i, num in enumerate(numbers) :      if target - num in temp :        return [temp[target - num] + 1, i + 1]      else :        temp[num] = i"
    }, {
    "id": 54,
    "url": "http://localhost:4000/rotate-array/",
    "title": "[Leetcode] 189. Rotate Array",
    "body": "2019/10/23 - 배열(리스트)이 하나 주어졌을 때, 이 배열을 오른쪽으로 k번 회전한 결과를 구하는 문제  k는 음수가 아니다. Example 1:  Input : nums = [1,2,3,4,5,6,7], k = 3 Output : [5,6,7,1,2,3,4]Example 2:  Input : nums = [-1,-100,3,99], k = 2 Output : [3,99,-1,-100]Note: 리스트를 두 부분으로 나누어 합치는 방법 사용 123456789class Solution:  def rotate(self, nums: List[int], k: int) -&gt; None:           Do not return anything, modify nums in-place instead.            length = len(nums)    if k &gt; length :      k %= length    nums[:] = nums[length - k : length] + nums[:length - k]"
    }, {
    "id": 55,
    "url": "http://localhost:4000/excel-sheet-column-title/",
    "title": "[Leetcode] 168. Excel Sheet Column Title",
    "body": "2019/10/23 - 양의 정수가 하나 주어졌을 때, 이를 엑셀 시트에서 보이는 것과 같은 column title로 변경하는 문제  A -&gt; 1, B -&gt; 2, … , Z -&gt; 26, AA -&gt; 27, AB -&gt; 28 … 과 같은 순서로 진행된다. Example 1:  Input : columnNumber = 1 Output : “A”Example 2:  Input : columnNumber = 28 Output : “AB”Example 3:  Input : columnNumber = 701 Output : “ZY”Note:  26진법을 계산하듯이 역으로 계산 (26으로 나눈 나머지가 해당 자리의 값) ord(ch) : 문자를 아스키 코드로 변환 chr(num) : 아스키 코드를 문자로 변환 a //= b : a를 b로 나눈 몫을 a에 대입한다. (a /= b와 다름)123456789class Solution:  def convertToTitle(self, n: int) -&gt; str:    res =       while n :      n -= 1      mod = n % 26      res = chr(mod + ord('A')) + res      n //= 26    return res"
    }, {
    "id": 56,
    "url": "http://localhost:4000/excel-sheet-column-number/",
    "title": "[Leetcode] 171. Excel Sheet Column Number",
    "body": "2019/10/23 - 엑셀 시트에 나타나는 것과 동일한 column title이 주어졌을 때, 이를 숫자로 변경하는 문제  A -&gt; 1, B -&gt; 2, … , Z -&gt; 26, AA -&gt; 27, AB -&gt; 28 … 과 같은 순서로 진행된다. Example 1:  Input : columnTitle = “A” Output : 1Example 2:  Input : columnTitle = “AB” Output : 28Example 3:  Input : columnTitle = “ZY” Output : 701Note:  26진법을 계산하듯이 계산 ord(ch) : 문자를 아스키 코드로 변환 chr(num) : 아스키 코드를 문자로 변환1234567class Solution:  def titleToNumber(self, s: str) -&gt; int:    res = 0    for ch in s :      res *= 26      res += (ord(ch) - ord('A') + 1)    return res"
    }, {
    "id": 57,
    "url": "http://localhost:4000/binary-tree-preorder-traversal/",
    "title": "[Leetcode] 144. Binary Tree Preorder Traversal",
    "body": "2019/10/22 - binary tree가 하나 주어졌을 때, 해당 트리의 preorder traversal의 결과를 구하는 문제 Example 1:  Input : root = [1,null,2,3] Output : [1,2,3]Example 2:  Input : root = [] Output : []Example 3:  Input : root = [1] Output : [1]Note:  preorder() 함수를 만들어 Recursive하게 해결 (참고) inorder traversal (참고) postorder traversal123456789101112131415161718# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def preorderTraversal(self, root: TreeNode) -&gt; List[int]:    res = []    def preorder(self, node: TreeNode) -&gt; None:      if not node :        return            res. append(node. val)      preorder(self, node. left)      preorder(self, node. right)    preorder(self, root)    return res"
    }, {
    "id": 58,
    "url": "http://localhost:4000/binary-tree-postorder-traversal/",
    "title": "[Leetcode] 145. Binary Tree Postorder Traversal",
    "body": "2019/10/22 - binary tree가 하나 주어졌을 때, 해당 트리의 postorder traversal의 결과를 구하는 문제 Example 1:  Input : root = [1,null,2,3] Output : [3,2,1]Example 2:  Input : root = [] Output : []Example 3:  Input : root = [1] Output : [1]Note:  postorder() 함수를 만들어 Recursive하게 해결 (참고) inorder traversal (참고) preorder traversal123456789101112131415161718# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def postorderTraversal(self, root: TreeNode) -&gt; List[int]:    res = []    def postorder(self, node: TreeNode) -&gt; None:      if not node :        return           postorder(self, node. left)      postorder(self, node. right)      res. append(node. val)    postorder(self, root)    return res"
    }, {
    "id": 59,
    "url": "http://localhost:4000/binary-tree-inorder-traversal/",
    "title": "[Leetcode] 94. Binary Tree Inorder Traversal",
    "body": "2019/10/22 - binary tree가 하나 주어졌을 때, 해당 트리의 inorder traversal의 결과를 구하는 문제 Example 1:  Input : root = [1,null,2,3] Output : [1,3,2]Example 2:  Input : root = [] Output : []Example 3:  Input : root = [1] Output : [1]Note:  inorder() 함수를 만들어 Recursive하게 해결 (참고) preorder traversal (참고) postorder traversal123456789101112131415161718# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def inorderTraversal(self, root: TreeNode) -&gt; List[int]:    res = []    def inorder(self, node: TreeNode) -&gt; None:      if not node :        return      inorder(self, node. left)      res. append(node. val)      inorder(self, node. right)    inorder(self, root)    return res"
    }, {
    "id": 60,
    "url": "http://localhost:4000/same-tree/",
    "title": "[Leetcode] 100. Same Tree",
    "body": "2019/10/21 - binary tree가 두 개 주어졌을 때, 두 트리가 동일한 트리인지 확인하는 문제  동일한 트리의 조건 : 구조가 동일하고, 각 노드의 값이 동일하다. Example 1:  Input : p = [1,2,3], q = [1,2,3] Output : trueExample 2:  Input : p = [1,2], q = [1,null,2] Output : falseExample 3:  Input : p = [1,2,1], q = [1,1,2] Output : falseNote: isSameNode() 함수를 만들어서 각 노드를 비교  노드가 둘 다 None인 경우 : true(동일) 노드 중 하나만 None인 경우 : false (다름) 노드가 둘 다 None이 아니고, 값이 같은 경우 : left와 right를 비교 노드가 둘 다 None이 아니고, 값이 다른 경우 : false (다름)1234567891011121314151617181920# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool:    def isSameNode(self, p: TreeNode, q: TreeNode) -&gt; bool:      if not p and not q :        return True      elif (not p and q) or (p and not q) :        return False      else :        if p. val == q. val :          return isSameNode(self, p. left, q. left) and isSameNode(self, p. right, q. right)        else :          return False    return isSameNode(self, p, q)"
    }, {
    "id": 61,
    "url": "http://localhost:4000/minimum-path-sum/",
    "title": "[Leetcode] 64. Minimum Path Sum",
    "body": "2019/10/21 - m x n의 양수로 채워진 Grid가 주어졌을 때, 좌상단에서 우하단으로 이동하는 path의 합의 최솟값을 구하는 문제  한 번에 한 칸씩 오른쪽 혹은 아래로만 이동할 수 있다. Example 1:  Input : grid = [[1,3,1],[1,5,1],[4,2,1]] Output : 7 1 -&gt; 3 -&gt; 1 -&gt; 1 -&gt; 1Example 2:  Input : grid = [[1,2,3],[4,5,6]] Output : 12Note: 특정 칸으로 이동하는 방법의 최솟값은 위쪽 혹은 왼쪽 칸의 값 중에서 작은 값에서 이동하는 것 12345678910111213class Solution:  def minPathSum(self, grid: List[List[int]]) -&gt; int:    for i in range(len(grid)) :      for j in range(len(grid[0])) :        if i == 0 and j == 0 :          continue        if i == 0 :          grid[i][j] += grid[i][j-1]        elif j == 0 :          grid[i][j] += grid[i-1][j]        else :          grid[i][j] += min(grid[i][j-1], grid[i-1][j])    return grid[-1][-1]"
    }, {
    "id": 62,
    "url": "http://localhost:4000/maximum-subarray/",
    "title": "[Leetcode] 53. Maximum Subarray",
    "body": "2019/10/21 - 정수로 이루어진 수열에서 합이 최대가 되는 연속 부분 수열을 찾는 문제 Example 1:  Input : nums = [-2,1,-3,4,-1,2,1,-5,4] Output : 6 [4,-1,2,1] = 6Example 2:  Input : nums = [1] Output : 1Example 3:  Input : nums = [5,4,-1,7,8] Output : 23 [5,4,-1,7,8] = 23Note:  res는 전체 subarray의 합 중에서 가장 큰 값 temp는 현재의 subarray의 합 nums[i]를 더했는데 nums[i]보다 작은 경우 최대합의 부분수열이 될 수 없다. 123456789class Solution:  def maxSubArray(self, nums: List[int]) -&gt; int:    res, temp = nums[0], nums[0]    for i in range(1, len(nums)) :      temp += nums[i]      if temp &lt; nums[i] :        temp = nums[i]      res = max(res, temp)    return res"
    }, {
    "id": 63,
    "url": "http://localhost:4000/triangle/",
    "title": "[Leetcode] 120. Triangle",
    "body": "2019/10/20 - 삼각형 형태의 2차원 배열(리스트)이 주어졌을 때, top에서 bottom까지 가는 path의 최소합을 찾는 문제 Example 1:  Input : triangle = [[2],[3,4],[6,5,7],[4,1,8,3]] Output : 11 2 + 3 + 5 + 1 = 11Example 2:  Input : triangle = [[-10]] Output : -10Note:  top to bottom이지만 bottom에서 top으로 올라가는 방식으로 문제를 해결하는 것이 간단하다.  이동할 수 있는 아래의 두 칸 중에서 작은 값을 선택하여 더하는 방식으로 해결123456class Solution:  def minimumTotal(self, triangle: List[List[int]]) -&gt; int:    for i in range(len(triangle) - 2, -1, -1) :      for j in range(len(triangle[i])) :        triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])    return triangle[0][0]"
    }, {
    "id": 64,
    "url": "http://localhost:4000/path-sum/",
    "title": "[Leetcode] 112. Path Sum",
    "body": "2019/10/20 - binary tree와 정수 targetSum이 주어졌을 때, root-to-leaf path의 합이 sum과 동일한 path가 존재하는지를 찾는 문제  leaf 노드는 child가 존재하지 않는다. (left, right 모두 None)Example 1:  Input : root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output : trueExample 2:  Input : root = [1,2,3], targetSum = 5 Output : falseExample 3:  Input : root = [], targetSum = 0 Output : falseNote:  위에서부터 내려오면서 left와 right child의 val에 현재 노드의 val을 더한다.  특정 노드에서 left, right가 모두 None인 경우(leaf 노드인 경우) 값을 targetSum과 비교한다.  모든 노드를 다 확인했음에도 sum과 동일한 값이 없는 경우 false를 리턴한다.  (참고) 중간 노드의 값이 targetSum보다 커지면 아래 노드는 확인하지 않도록 구현하려 했으나, 음수 값이 포함되는 테스트 케이스가 존재하여 해당 조건은 삭제123456789101112131415161718192021222324# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool:    if not root :      return False    queue = [root]    while queue :      node = queue. pop(0)      if node. left is None and node. right is None :        if node. val == sum :          return True      if node. left is not None :        node. left. val += node. val        queue. append(node. left)      if node. right is not None :        node. right. val += node. val        queue. append(node. right)    return False"
    }, {
    "id": 65,
    "url": "http://localhost:4000/flatten-binary-tree-to-linked-list/",
    "title": "[Leetcode] 114. Flatten Binary Tree to Linked List",
    "body": "2019/10/20 - binary tree가 주어졌을 때, 이를 flatten하는 문제  우측으로 편향되도록 바꾼다.  순서는 depth-first in-place로 해결할 것Example 1:  Input : root = [1,2,5,3,4,null,6] Output : [1,null,2,null,3,null,4,null,5,null,6]Example 2:  Input : root = [] Output : []Example 3:  Input : root = [0] Output : [0]Note:  stack을 사용하여 depth-first로 노드 방문 (참고) [None, None] 같은 형태의 테스트 케이스가 존재123456789101112131415161718192021222324252627282930# Definition for a binary tree node. # class TreeNode:#   def __init__(self, x):#     self. val = x#     self. left = None#     self. right = Noneclass Solution:  def flatten(self, root: TreeNode) -&gt; None:           Do not return anything, modify root in-place instead.            if not root :      return    stack = [root. right, root. left]    root. left = root. right = None    point = root    while stack :      node = stack. pop()      if not node :        continue      if node. right is not None :        stack. append(node. right)        node. right = None      if node. left is not None :        stack. append(node. left)        node. left = None      point. right = node      point = point. right    return"
    }, {
    "id": 66,
    "url": "http://localhost:4000/single-number-ii/",
    "title": "[Leetcode] 137. Single Number II",
    "body": "2019/10/19 - 비어 있지 않은, 숫자로 이루어진 리스트가 주어졌을 때, 해당 리스트 안에 한 번만 등장하는 원소를 찾는 문제  단 하나의 원소를 제외하고는 모두 세 번씩 등장한다. Example 1:  Input : nums = [2,2,3,2] Output : 3Example 2:  Input : nums = [0,1,0,1,0,1,99] Output : 99Note:  set : 원소의 유일성을 보장하는 자료형 원소가 모두 세 번씩 등장한다고 가정했을 때의 총합은 3 * sum(set(nums))이고, 하나의 원소만 한 번 등장하므로 뺀 값을 2로 나누어 구할 수 있다. 123class Solution:  def singleNumber(self, nums: List[int]) -&gt; int:    return int((3 * sum(set(nums)) - sum(nums)) / 2)"
    }, {
    "id": 67,
    "url": "http://localhost:4000/single-number/",
    "title": "[Leetcode] 136. Single Number",
    "body": "2019/10/18 - 비어 있지 않은, 숫자로 이루어진 리스트가 주어졌을 때, 해당 리스트 안에 한 번만 등장하는 원소를 찾는 문제  단 하나의 원소를 제외하고는 모두 두 번씩 등장한다. Example 1:  Input : nums = [2,2,1] Output : 1Example 2:  Input : nums = [4,1,2,1,2] Output : 4Example 3:  Input : nums = [1] Output : 1Note:  set : 원소의 유일성을 보장하는 자료형 원소가 모두 두 번씩 등장한다고 가정했을 때의 총합은 2 * sum(set(nums))이고, 하나의 원소만 한 번 등장하므로 차를 구하여 원소를 구할 수 있다. 123class Solution:  def singleNumber(self, nums: List[int]) -&gt; int:    return 2 * sum(set(nums)) - sum(nums)"
    }, {
    "id": 68,
    "url": "http://localhost:4000/valid-palindrome/",
    "title": "[Leetcode] 125. Valid Palindrome",
    "body": "2019/10/17 - 주어진 문자열이 Palindrome인지 확인하는 문제  Palindrome : 회문. 거꾸로 읽었을 때도 제대로 읽었을 때와 동일한 경우 문자열 내에서 alphanumeric character를 제외한 나머지 경우는 무시한다. Example 1:  Input : s = “A man, a plan, a canal: Panama” Output : trueExample 2:  Input : s = “race a car” Output : falseExample 3:  Input : s = “ “ Output : trueNote:  re. sub를 사용하여 alphanumeric이 아닌 모든 경우는 ‘‘로 치환 대소문자를 구분하지 않으므로, 전부 lowercase로 변경 reverse 문자열 구하는 법 : [::-1]1234567class Solution:  def isPalindrome(self, s: str) -&gt; bool:    s = re. sub('\W', '', s). lower()    if s[::-1] == s :      return True    else :      return False"
    }, {
    "id": 69,
    "url": "http://localhost:4000/pascals-triangle-ii/",
    "title": "[Leetcode] 119. Pascal's Triangle II",
    "body": "2019/10/16 - 양의 정수인 rowIndex가 주어졌을 때, 파스칼의 삼각형(Pascal’s Triangle)에서 rowIndex번째를 구하는 문제  파스칼의 삼각형 : 각 숫자는 위의 두 숫자의 합으로 이루어진다. Example 1:  Input : rowIndex = 3 Output : [1,3,3,1]Example 2:  Input : rowIndex = 0 Output : [1]Example 3:  Input : rowIndex = 1 Output : [1,1]Note:  메모리 O(n)만큼 사용 해당 인덱스의 값은 이전 사이클의 해당 인덱스의 값 + 앞 인덱스의 값 앞에서부터 순서대로 계산하려면 여분의 공간이 필요하므로, 뒤에서부터 계산하는 방식 선택1234567class Solution:  def getRow(self, rowIndex: int) -&gt; List[int]:    row = [1] + [0 for _ in range(rowIndex)]    for i in range(rowIndex+1) :            for j in range(i-1, -1, -1) :        row[j+1] += row[j]    return row"
    }, {
    "id": 70,
    "url": "http://localhost:4000/pascals-triangle/",
    "title": "[Leetcode] 118. Pascal's Triangle",
    "body": "2019/10/15 - 양의 정수인 numRows가 주어졌을 때, 파스칼의 삼각형(Pascal’s Triangle)을 만드는 문제  파스칼의 삼각형 : 각 숫자는 위의 두 숫자의 합으로 이루어진다. Example 1:  Input : numRows = 5 Output : [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]Example 2:  Input : numRows = 1 Output : [[1]]Note:  한 줄씩 각 row를 계산한 뒤, 결과 리스트에 append하는 방식으로 구현123456789class Solution:  def generate(self, numRows: int) -&gt; List[List[int]]:    res = []    for i in range(numRows) :      row = [1 for _ in range(i+1)]      for j in range(1, i) :        row[j] = res[i-1][j-1] + res[i-1][j]      res. append(row)    return res"
    }, {
    "id": 71,
    "url": "http://localhost:4000/unique-paths-ii/",
    "title": "[Leetcode] 63. Unique Paths II",
    "body": "2019/10/14 - m x n 사이즈의 그리드가 주어졌을 때, 해당 그리드의 왼쪽 위에서 오른쪽 아래까지 도달하는 방법의 수를 구하는 문제  한 번에 한 칸만 아래 혹은 오른쪽으로 이동할 수 있다.  m과 n은 최대 100 이하의 정수이다.  장애물이 있는 칸은 1로, 비어있는 칸은 0으로 주어진다. Example 1:  Input : obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] Output : 2Example 2:  Input : obstacleGrid = [[0,1],[0,0]] Output : 1Note:  dp를 사용하여 해결 특정 칸에 도달하기 위한 방법의 수 : 위쪽 칸에 도달하기 위한 방법의 수 + 왼쪽 칸에 도달하기 위한 방법의 수 list를 특정 값(value)로 초기화 : lst = [value for i in range(size)] 가장 위쪽과 왼쪽의 칸들은 중간에 장애물이 있는 경우 도달할 수 있는 방법이 없다. 1234567891011121314151617181920class Solution:  def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:    n, m = len(obstacleGrid), len(obstacleGrid[0])    cal = [[0 for i in range(m)] for i in range(n)]    for i in range(n) :      if obstacleGrid[i][0] == 1 :        break      cal[i][0] = 1    for j in range(m) :      if obstacleGrid[0][j] == 1 :        break      cal[0][j] = 1    for i in range(1, n) :      for j in range(1, m) :        if obstacleGrid[i][j] == 1 :          cal[i][j] = 0          continue        else :          cal[i][j] = cal[i-1][j] + cal[i][j-1]    return cal[-1][-1]"
    }, {
    "id": 72,
    "url": "http://localhost:4000/remove-duplicates-from-sorted-array-ii/",
    "title": "[Leetcode] 80. Remove Duplicates from Sorted Array II",
    "body": "2019/10/14 - 정수로 이루어진 정렬된 리스트가 주어졌을 때, 하나의 숫자는 최대 2번만 등장하도록 겹치는 숫자들을 제외한 리스트를 만드는 문제  in-place : 다른 리스트를 할당하지 말고 주어진 리스트 내에서 해결할 것 각 원소는 최대 두 번씩만 나타나야 한다.  새롭게 만들어진 리스트의 길이를 리턴 리턴한 길이의 뒷부분에는 리스트에 어떤 값이 있건 상관하지 않는다. Example 1:  Input : nums = [1,1,1,2,2,3] Output : 5, nums = [1,1,2,2,3, …]Example 2:  Input : nums = [0,0,1,1,1,1,2,3,3] Output : 7, nums = [0,0,1,1,2,3,3, …]Note:  나타나는 원소가 이전과 동일한 경우 count를 하여 2번을 초과하여 나타나는 경우에 삭제하는 방법 리스트 내에서 순서를 바꾸는 방법도 가능123456789101112131415161718class Solution:  def removeDuplicates(self, nums: List[int]) -&gt; int:    if not nums :      return 0    now = nums[0]    count, i = 1, 1    while i &lt; len(nums) :      if nums[i] == now :        if count &lt; 2 :          count += 1          i += 1        else :          del nums[i]      else :        now = nums[i]        count = 1        i += 1    return len(nums)"
    }, {
    "id": 73,
    "url": "http://localhost:4000/partition-list/",
    "title": "[Leetcode] 83. Partition List",
    "body": "2019/10/14 - Linked List와 숫자 x가 주어졌을 때, x보다 작은 노드가 x보다 크거나 같은 노드보다 앞에 위치하는 Linked List로 바꾸는 문제  기존 노드의 상대적인 순서는 유지되어야 한다. Example 1:  Input : head = [1,4,3,2,5,2], x = 3 Output : [1,2,2,4,3,5]Example 2:  Input : head = [2,1], x = 2 Output : [1,2]Note:  x보다 작은 리스트(less)와 큰 리스트(greater)로 구분한 뒤, 큰 리스트를 작은 리스트의 뒤에 붙이는 방법으로 구현123456789101112131415161718192021# Definition for singly-linked list. # class ListNode:#   def __init__(self, x):#     self. val = x#     self. next = Noneclass Solution:  def partition(self, head: ListNode, x: int) -&gt; ListNode:    less, greater = ListNode(-1), ListNode(-1)    less_now, greater_now = less, greater    node = head    while node :      if node. val &lt; x :        less_now. next = ListNode(node. val)        less_now = less_now. next      else :        greater_now. next = ListNode(node. val)        greater_now = greater_now. next      node = node. next    less_now. next = greater. next    return less. next"
    }, {
    "id": 74,
    "url": "http://localhost:4000/unique-paths/",
    "title": "[Leetcode] 62. Unique Paths",
    "body": "2019/10/13 - 두 정수 m, n이 주어졌을 때, m x n 사이즈 그리드의 왼쪽 위에서 오른쪽 아래까지 도달하는 방법의 수를 구하는 문제  한 번에 한 칸만 아래 혹은 오른쪽으로 이동할 수 있다.  m과 n은 최대 100 이하의 정수이다. Example 1:  Input : m = 3, n = 7 Output : 28Example 2:  Input : m = 3, n = 2 Output : 3Note:  dp를 사용하여 해결 특정 칸에 도달하기 위한 방법의 수 : 위쪽 칸에 도달하기 위한 방법의 수 + 왼쪽 칸에 도달하기 위한 방법의 수 list를 특정 값(value)로 초기화 : lst = [value for i in range(size)]12345678910class Solution:  def uniquePaths(self, m: int, n: int) -&gt; int:    cal = [[0 for i in range(m)] for i in range(n)]    for i in range(n) :      for j in range(m) :        if i == 0 or j == 0 :          cal[i][j] = 1        else :          cal[i][j] = cal[i-1][j] + cal[i][j-1]    return cal[-1][-1]"
    }, {
    "id": 75,
    "url": "http://localhost:4000/search-a-2d-matrix/",
    "title": "[Leetcode] 74. Search a 2D Matrix",
    "body": "2019/10/12 - m x n 사이즈의 2차원 리스트가 주어졌을 때, targeet이 존재하는지 찾는 문제  각 row에 있는 숫자들은 증가하는 순서로 정렬되어 있다.  각 row의 첫 번째 숫자는 이전 row의 마지막 숫자보다 크다. Example 1:  Input : matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 Output : trueExample 2:  Input : matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 Output : falseNote:  해당 row가 target을 포함하는 범위인지 확인한 후, 해당 row에 target이 존재하는지 확인123456789101112131415161718# Definition for singly-linked list. # class ListNode:#   def __init__(self, x):#     self. val = x#     self. next = Noneclass Solution:  def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:    for row in matrix :      if not row :        return False      if row[0] &lt;= target and row[-1] &gt;= target :        c = row. count(target)        if c == 0 :          return False        else :          return True    return False"
    }, {
    "id": 76,
    "url": "http://localhost:4000/remove-duplicates-from-sorted-list/",
    "title": "[Leetcode] 83. Remove Duplicates from Sorted List",
    "body": "2019/10/11 - 정렬된 숫자로 이루어진 Linked List가 하나 주어졌을 때, 모든 숫자가 단 한 번만 등장하도록 중복을 제거한 리스트를 만드는 문제 Example 1:  Input : head = [1, 1, 2] Output : [1, 2]Example 2:  Input : head = [1, 1, 2, 3, 3] Output : [1, 2, 3]Note: 이전과 숫자가 동일한 노드라면, 앞 노드와 뒷 노드를 연결하여 해당 노드를 리스트에서 삭제 123456789101112131415161718192021# Definition for singly-linked list. # class ListNode:#   def __init__(self, x):#     self. val = x#     self. next = Noneclass Solution:  def deleteDuplicates(self, head: ListNode) -&gt; ListNode:    if not head :      return head    before, now = head, head    appear = head. val        while before. next :      now = before. next      if now. val == appear :        before. next = now. next        now = None      else :        appear = now. val        before = now    return head"
    }, {
    "id": 77,
    "url": "http://localhost:4000/jump-game/",
    "title": "[Leetcode] 55. Jump Game",
    "body": "2019/10/11 - 양의 정수로 이루어진 리스트가 주어졌을 때, 최대 각 칸의 값만큼 점프할 수 있다고 가정하면, 마지막 인덱스에 도달할 수 있는지 확인하는 문제  e. g. , 값이 3이라면 1칸, 2칸, 3칸 다음으로 이동할 수 있다. Example 1:  Input : nums = [2, 3, 1, 1, 4] Output : true 인덱스 0에서 1칸 이동 -&gt; 인덱스 1에서 3칸 이동Example 2:  Input : nums = [3, 2, 1, 0, 4] Output : false 어떤 경우에도 무조건 인덱스 3에 도달할 수밖에 없고, 인덱스 3의 값이 0이므로 마지막 인덱스에 도달할 수 없다. Note: 단순하게 생각하여, 최대로 이동할 수 있는 길이가 리스트의 전체 길이보다 긴지 확인 12345678910class Solution:  def canJump(self, nums: List[int]) -&gt; bool:    length = len(nums)    far, i = 0, 0    while i &lt;= far :      far = max(far, i + nums[i])      if far &gt;= length - 1 :        return True      i += 1    return False"
    }, {
    "id": 78,
    "url": "http://localhost:4000/climbing-stairs/",
    "title": "[Leetcode] 70. Climbing Stairs",
    "body": "2019/10/10 - 정수 n이 주어졌을 때, n번째 계단까지 도달하는 방법의 개수를 구하는 문제  한 번에 1계단 혹은 2계단씩만 올라갈 수 있다.  n은 양의 정수로 주어진다. Example 1:  Input : n = 2 Output : 2 [1, 1], [2] 두 가지 방법이 존재한다. Example 2:  Input : n = 3 Output : 3 [1, 1, 1], [1, 2], [2, 1] 세 가지 방법이 존재한다. Note:  1계단 아래 혹은 2계단 아래에 도달하면 해당 계단에 도달할 수 있으므로, dp를 사용하여 해결123456class Solution:  def climbStairs(self, n: int) -&gt; int:    steps = [0, 1, 2]    for i in range(3, n + 1) :      steps. append(steps[i-2] + steps[i-1])    return steps[n]"
    }, {
    "id": 79,
    "url": "http://localhost:4000/plus-one/",
    "title": "[Leetcode] 66. Plus One",
    "body": "2019/10/09 - 비어 있지 않은, 숫자로 이루어진 리스트가 하나 주어졌을 때, 리스트의 값이 나타내는 정수에 1을 더한 값을 리스트로 리턴하는 문제  숫자는 음수가 아니며, 0으로 시작하지 않는다.  리스트 내의 각각의 원소들은 single digit을 나타낸다.  most significant digit가 리스트의 가장 앞에 저장된다. Example 1:  Input : digits = [1, 2, 3] Output : [1, 2, 4]Example 2:  Input : digits = [4, 3, 2, 1] Output : [4, 3, 2, 2]Example 3:  Input : digits = [9] Output : [1, 0]Note:  reversed : 리스트의 순서를 거꾸로 뒤집는다.  insert(0, value)를 이용하여 리스트의 가장 앞에 계산한 값이 포함되도록 한다.  자릿수가 바뀌는 경우(e. g. , 99 -&gt; 100)를 대비하여 마지막에 up이 남아있는지 확인한다. 1234567891011121314class Solution:  def plusOne(self, digits: List[int]) -&gt; List[int]:    res = []    up = 1    for i in reversed(digits) :      if i + up &gt;= 10 :        res. insert(0, 0)        up = 1      else :        res. insert(0, i + up)        up = 0    if up == 1 :      res. insert(0, 1)    return res"
    }, {
    "id": 80,
    "url": "http://localhost:4000/length-of-last-word/",
    "title": "[Leetcode] 58. Length of Last Word",
    "body": "2019/10/08 - 하나의 문자열이 주어졌을 때, 마지막 단어의 길이를 구하는 문제  주어진 문자열은 upper/lower-case 알파벳과 공백으로 이루어진다.  단어란 공백을 포함하지 않는 charater의 sequence이다.  마지막 단어가 없는 경우, 0을 리턴한다. Example 1:  Input : s = “Hello World” Output : 5Example 2:  Input : s = “  fly me  to  the moon “ Output : 4Example 3:  Input : s = “luffy is still joyboy” Output : 6Note:  strip : 양쪽 공백 지우기 / rstrip : 오른쪽 공백 지우기 / lstrip : 왼쪽 공백 지우기 마지막 단어를 찾기 위함이므로, 왼쪽에 위치한 공백은 고려하지 않는다.  공백을 기준으로 split 하여 마지막 단어의 길이를 구한다. 123456class Solution:  def lengthOfLastWord(self, s: str) -&gt; int:    words = s. rstrip(). split()    if not words :      return 0    return len(words[-1])"
    }, {
    "id": 81,
    "url": "http://localhost:4000/search-in-rotated-sorted-array/",
    "title": "[Leetcode] 33. Search in Rotated Sorted Array",
    "body": "2019/10/07 - 정렬된 리스트와 정수 하나가 주어졌을 때, 주어진 정수(target)의 인덱스를 찾는 문제  리스트는 증가하는 방향으로 정렬되어 있지만, rotate 되어 있다.  e. g. , [0, 1, 2, 4, 5, 6, 7]은 [4, 5, 6, 7, 0, 1, 2]가 될 수 있다.  리스트 내에 정수가 존재하지 않는 경우 -1을 리턴한다. Example 1:  Input : nums = [4, 5, 6, 7, 0, 1, 2], target = 0 Output : 4Example 2:  Input : nums = [4, 5, 6, 7, 0, 1, 2], target = 3 Output : -1Example 3:  Input : nums = [1], target = 0 Output : -1Solution 1Note: python 내장 함수 사용 12345class Solution:  def search(self, nums: List[int], target: int) -&gt; int:    if nums. count(target) == 0 :      return -1    return nums. index(target)Solution 2Note:  target과 동일한 값이 있는 경우, 해당 인덱스를 리턴한다.  리스트가 정렬되어 있기 때문에 이전 값이 target보다 작은데 다음 값이 target보다 큰 경우 target은 존재하지 않는다. 1234567891011class Solution:  def search(self, nums: List[int], target: int) -&gt; int:    issmall = False    for i in range(len(nums)) :      if nums[i] == target :        return i      elif nums[i] &lt; target :        issmall = True      elif nums[i] &gt; target and issmall :        return -1    return -1"
    }, {
    "id": 82,
    "url": "http://localhost:4000/count-and-say/",
    "title": "[Leetcode] 38. Count and Say",
    "body": "2019/10/07 - 특정한 규칙에 따라 sequence가 생성될 때, n번째 sequence를 구하는 문제  ‘1’은 “one 1”로 읽기 때문에 ‘11’이 된다.  ‘11’은 “two 1s”로 읽기 때문에 ‘21’이 된다.  ‘21’은 “one 2, one 1”으로 읽기 때문에 ‘1211’이 된다.  n은 1 이상 30 이하로 주어진다.  첫 5개의 sequence는 다음과 같다.      1   11   21   1211   111221   Example 1:  Input : n = 4 Output : “1211”Example 2:  Input : n = 1 Output : “1”Note: 동일한 숫자가 반복되는 경우를 count하여 temp 문자열에 추가 123456789101112131415class Solution:  def countAndSay(self, n: int) -&gt; str:    res = '1'    for i in range(1, n) :      count, temp, num = 0, '', res[0]            for j in res :        if j == num :          count += 1        else :          temp += str(count) + num          num = j          count = 1      temp += str(count) + num      res = temp    return res"
    }, {
    "id": 83,
    "url": "http://localhost:4000/search-insert-position/",
    "title": "[Leetcode] 35. Search Insert Position",
    "body": "2019/10/06 - 정렬된 리스트와 정수 하나가 주어졌을 때, 주어진 정수(target)가 삽입될 위치의 인덱스를 찾는 문제  target이 삽입되더라도 리스트는 정렬되어 있어야 한다. Example 1:  Input : nums = [1, 3, 5, 6], target = 5 Output : 2Example 2:  Input : nums = [1, 3, 5, 6], target = 2 Output : 1Example 3:  Input : nums = [1,3,5,6], target = 7 Output : 4Note:  target이 리스트의 마지막 값보다 큰 경우 : 리스트의 제일 마지막에 위치한다.  리스트를 돌면서 target보다 크거나 같은 값이 나오면 해당 인덱스를 리턴한다. 1234567class Solution:  def searchInsert(self, nums: List[int], target: int) -&gt; int:    if target &gt; nums[-1] :      return len(nums)    for i in range(len(nums)) :      if nums[i] &gt;= target :        return i"
    }, {
    "id": 84,
    "url": "http://localhost:4000/find-first-and-last-position-of-element-in-sorted-array/",
    "title": "[Leetcode] 34. Find First and Last Position of Element in Sorted Array",
    "body": "2019/10/06 - 하나의 정렬된 리스트와 정수가 주어졌을 때, 주어진 정수(target)가 등장하는 처음과 끝의 인덱스를 찾는 문제  리스트 내에 target이 없는 경우, [-1, -1]을 리턴한다. Example 1:  Input : nums = [5, 7, 7, 8, 8, 10], target = 8 Output : [3, 4]Example 2:  Input : nums = [5, 7, 7, 8, 8, 10], target = 6 Output : [-1, -1]Example 3:  Input : nums = [], target = 0 Output : [-1, -1]Note:  count를 통해 리스트 내에 target의 존재 여부를 확인하고, index를 통해 리스트 내에서 처음 등장하는 인덱스를 찾는다.  정렬되어 있으므로, 첫 인덱스 + count - 1까지 등장한다. 12345678class Solution:  def searchRange(self, nums: List[int], target: int) -&gt; List[int]:    c = nums. count(target)    if c == 0 :      return [-1, -1]    i = nums. index(target)    res = [i, i + c - 1]    return res"
    }, {
    "id": 85,
    "url": "http://localhost:4000/remove-duplicates-from-sorted-array/",
    "title": "[Leetcode] 26. Remove Duplicates from Sorted Array",
    "body": "2019/10/05 - 정수로 이루어진 정렬된 리스트가 주어졌을 때, 주어진 리스트에서 겹치는 숫자들을 제외한 리스트를 만드는 문제  in-place : 다른 리스트를 할당하지 말고 주어진 리스트 내에서 해결할 것 각 원소는 단 한 번씩만 나타나야 한다.  새롭게 만들어진 리스트의 길이를 리턴 리턴한 길이의 뒷부분에는 리스트에 어떤 값이 있건 상관하지 않는다. Example 1:  Input : nums = [1, 1, 2] Output : length = 2, nums = [1, 2, …]Example 2:  Input : nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] Output : length = 5, nums = [0, 1, 2, 3, 4, …]Solution 1Note:  리스트가 정렬되어 있으므로, 다음에 나타나는 원소가 이전과 동일하다면 삭제하는 방법으로 구현 리스트 내에서 순서를 바꾸는 방법도 가능123456789101112131415class Solution:  def removeDuplicates(self, nums: List[int]) -&gt; int:        if not nums :      return 0    length = len(nums)    now = nums[0]    i = 1    while (i &lt; length) :      if now == nums[i] :        del nums[i]        length -= 1      else :        now = nums[i]        i += 1    return i  Solution 2Note:  원소의 중복을 허용하지 않는 set을 이용 (참고) memory 사용량은 동일하다. 12345class Solution:  def removeDuplicates(self, nums: List[int]) -&gt; int:    nums[:] = list(set(nums))    nums. sort()    return len(nums)"
    }, {
    "id": 86,
    "url": "http://localhost:4000/implement-strstr/",
    "title": "[Leetcode] 28. Implement strStr()",
    "body": "2019/10/05 - 두 개의 문자열(haystack, needle)이 주어졌을 때, haystack 내에서 needle이 처음 등장하는 인덱스를 리턴하는 문제  needle이 haystack 내에 존재하지 않는다면 -1을 리턴한다. Example 1:  Input : haystack = “sadbutsad”, needle = “sad” Output : 0Example 2:  Input : haystack = “leetcode”, needle = “leeto” Output : -1Note:  find : 찾는 문자나 문자열이 없다면 -1을 리턴 index : 찾는 문자나 문자열이 없다면 오류 발생123class Solution:  def strStr(self, haystack: str, needle: str) -&gt; int:    return haystack. find(needle)"
    }, {
    "id": 87,
    "url": "http://localhost:4000/remove-element/",
    "title": "[Leetcode] 27. Remove Element",
    "body": "2019/10/04 - 정수로 이루어진 리스트와 정수가 하나 주어졌을 때, 주어진 리스트에서 주어진 정수를 제외한 리스트를 만드는 문제  in-place : 다른 리스트를 할당하지 말고 주어진 리스트 내에서 해결할 것 주어진 정수를 제외한 리스트의 길이를 리턴 새로운 리스트의 원소 순서는 변경될 수 있다.  리턴한 길이의 뒷부분에는 리스트에 어떤 값이 있건 상관하지 않는다. Example 1:  Input : nums = [3, 2, 2, 3], val = 3 Output : length = 2, nums = [2, 2, …]Example 2:  Input : nums = [0, 1, 2, 2, 3, 0, 4, 2], val = 2 Output : length = 5, nums = [0, 1, 3, 0, 4, …] nums의 첫 5개의 원소에 0, 0, 1, 3, 4가 포함되어 있으면 정답 처리Note:  val과 동일한 원소가 있으면 리스트에서 삭제하는 방법으로 구현 리스트 내에서 순서를 바꾸는 방법도 가능1234567891011class Solution:  def removeElement(self, nums: List[int], val: int) -&gt; int:    i = 0    length = len(nums)    while i &lt; length :      if nums[i] == val :        nums. remove(nums[i])        length -= 1        continue      i += 1    return len(nums)"
    }, {
    "id": 88,
    "url": "http://localhost:4000/merge-two-sorted-lists/",
    "title": "[Leetcode] 21. Merge Two Sorted Lists",
    "body": "2019/10/03 - 두 개의 정렬된 Linked List가 주어졌을 때, 이를 정렬된 하나의 Linked List로 만드는 문제  각 list의 노드 개수는 [0, 50]이다.  list1과 list2는 모두 non-decreasing 순으로 정렬되어 있다. Example 1:  Input : list1 = [1, 2, 4], list2 = [1, 3, 4] Output : [1, 1, 2, 3, 4, 4]Example 2:  Input : list1 = [], list2 = [] Output : []Example 3:  Input : list1 = [], list2 = [0] Output : [0]Note:  next가 None이 아닐 때까지 값을 하나씩 비교 하나의 리스트가 끝나면 다른 리스트의 남은 부분을 결과 리스트의 뒤에 붙인다. 123456789101112131415161718192021222324# Definition for singly-linked list. # class ListNode:#   def __init__(self, x):#     self. val = x#     self. next = Noneclass Solution:  def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:    res = ListNode(-1)    head = res    while l1 and l2 :      if l1. val &lt; l2. val :        head. next = ListNode(l1. val)        head = head. next        l1 = l1. next      else :        head. next = ListNode(l2. val)        head = head. next        l2 = l2. next    if l1 :      head. next = l1    if l2 :      head. next = l2    return res. next"
    }, {
    "id": 89,
    "url": "http://localhost:4000/valid-parentheses/",
    "title": "[Leetcode] 20. Valid Parentheses",
    "body": "2019/10/02 - 주어진 문자열의 괄호가 유효한지 확인하는 문제  문자열은 6가지 종류의 문자를 포함한다 : ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[’, ‘]’ 열리는 괄호는 반드시 같은 종류의 닫히는 괄호로 닫혀야 한다.  열린 괄호는 반드시 정확한 순서대로 닫혀야 한다. Example 1:  Input : s = “()” Output : trueExample 2:  Input : s = “()[]{}” Output : trueExample 3:  Input : s = “(]” Output : falseNote:  dict 사용 (key : 열리는 괄호 / value : 닫히는 괄호) 비어있는 sequence는 false 값을 가진다.  if (not) len(seq) 대신 if (not) seq 사용을 권장한다. 123456789101112class Solution:  def isValid(self, s: str) -&gt; bool:    p_map = {'(' : ')', '{' : '}', '[' : ']'}    stack = []    for i in s :      if i in ['(', '{', '['] :        stack. append(i)      elif stack and i == p_map[stack[-1]] :        stack. pop()      else :        return False    return not stack"
    }, {
    "id": 90,
    "url": "http://localhost:4000/3sum/",
    "title": "[Leetcode] 15. 3Sum",
    "body": "2019/06/25 - 주어진 정수 배열에서 세 개의 합이 0이 되는 모든 unique triplet을 찾는 문제  동일한 triplet이 포함되어서는 안 된다. (중복을 허용하지 않는다. ) 세 값의 합이 0이 되는 triplet이 존재하지 않을 경우, 빈 리스트([])를 리턴한다. Example 1:  Input : nums = [-1, 0, 1, 2, -1, -4] Output : [[-1, 0, 1], [-1, -1, 2]]Example 2:  Input : nums = [0, 1, 1] Output : []Example 3:  Input : nums = [0, 0, 0] Output : [0, 0, 0]Note: set을 사용하여 중복되는 값을 처리한다. 1234567891011121314151617181920212223class Solution:  def threeSum(self, nums: List[int]) -&gt; List[List[int]]:    if len(nums) &lt; 3 :      return []    nums. sort()    res = set()    l = len(nums)    for i in range(l) :            if nums[i] &gt; 0 :        break      target = -nums[i]      j, k = i + 1, l - 1      while j &lt; k :        temp = nums[j] + nums[k]        if temp &lt; target :          j += 1        elif temp &gt; target :           k -= 1        else :          res. add((nums[i], nums[j], nums[k]))          j += 1          k -= 1    return list(res)"
    }, {
    "id": 91,
    "url": "http://localhost:4000/longest-common-prefix/",
    "title": "[Leetcode] 14. Longest Common Prefix",
    "body": "2019/06/24 - 여러 문자열이 포함된 array(list)가 주어졌을 때, 가장 긴 common prefix(모든 문자열에서 등장하는 prefix)를 찾는 문제  common prefix가 없는 경우, 빈 문자열(““)을 리턴한다.  모든 입력은 소문자 알파벳으로만 주어진다. Example 1:  Input : [“flower”, “flow”, “flight”] Output : “fl”Example 2:  Input : [“dog”, “racecar”, “car”] Output : “”Note:  zip(*iterabble) : 동일한 개수로 이루어진 자료형을 묶어준다.      e. g. , list(zip([1, 2, 3], [4, 5, 6])) -&gt; [(1, 4), (2, 5), (3, 6)]    문자열 리스트를 정렬한 경우, 첫 번째 문자열과 마지막 문자열만 비교하면 가장 긴 common prefix를 구할 수 있다. 1234567891011121314class Solution:  def longestCommonPrefix(self, strs: List[str]) -&gt; str:    if len(strs) == 0 :      return       elif len(strs) == 1 :      return strs[0]    strs. sort()    res =       for x, y in zip(strs[0], strs[-1]) :      if x == y :        res += x      else :        break    return res"
    }, {
    "id": 92,
    "url": "http://localhost:4000/roman-to-integer/",
    "title": "[Leetcode] 13. Roman to Integer",
    "body": "2019/06/23 - 로마 숫자가 주어졌을 때, 정수로 변환하는 문제  각 문자(symbol)별 해당하는 값은 아래와 같다.      I : 1 / V : 5 / X : 10 / L : 50 / C : 100 / D : 500 / M : 1000    왼쪽에서 오른쪽으로 읽으며, 큰 숫자에서 작은 숫자의 순서로 작성된다.  작은 값에 해당하는 문자가 큰 값에 해당하는 문자의 왼쪽에 위치할 경우, 그 값만큼을 뺀다. (e. g. , IV : 4)Example 1:  Input : s = “III” Output : 3Example 2:  Input : s = “LVIII” Output : 58Example 3:  Input : s = “MCMXCIV” Output : 1994Note:  dict 사용 (key : 로마 숫자(문자) / value : 문자에 해당하는 값) 이전에 나타난 문자가 현재 문자보다 작은 값일 경우 : 현재 문자의 값 - 이전 문자의 값 동일한 문자가 반복되는 경우 : 해당 문자보다 크거나 작은 값을 지닌 문자가 나올 때까지 더한다.  이전에 나타난 문자가 현재 문자보다 큰 값일 경우 : 이전까지의 값을 전부 더한다. (큰 숫자에서 작은 숫자로 작성되므로)1234567891011121314151617181920class Solution:  def romanToInt(self, s: str) -&gt; int:    dict = {'I' : 1, 'V' : 5, 'X' : 10, 'L' : 50, 'C' : 100, 'D' : 500, 'M' : 1000}        res = 0    temp = 0    before = 1000    for i, ch in enumerate(s) :      if before &lt; dict[ch] :        temp = dict[ch] - temp        res += temp        temp = 0      elif before == dict[ch] :        temp += dict[ch]      else :        res += temp        temp = dict[ch]      before = dict[ch]    res += temp    return res"
    }, {
    "id": 93,
    "url": "http://localhost:4000/palindrome-number/",
    "title": "[Leetcode] 9. Palindrome Number",
    "body": "2019/06/22 - 하나의 정수가 주어졌을 때, 해당 정수가 palindrome인지 확인하는 문제  Palindrome이란 : 회문. 거꾸로 읽었을 때도 제대로 읽었을 때와 동일한 경우Example 1:  Input : x = 121 Output : trueExample 2:  Input : x = -121 Output : false 거꾸로 읽으면 121-가 되므로 palindrome이 아니다. Example 3:  Input : x = 10 Output : falseNote: reverse 문자열 구하는 방법 : [::-1] 1234567class Solution:  def isPalindrome(self, x: int) -&gt; bool:    x = str(x)    if x == x[::-1] :      return True    else :       return False"
    }, {
    "id": 94,
    "url": "http://localhost:4000/string-to-integer-atoi/",
    "title": "[Leetcode] 8. String to Integer (atoi)",
    "body": "2019/06/21 - 문자열이 주어졌을 때, 해당 문자열을 정수로 변환하는 문제  문자열은 whitespace character, 숫자 및 문자로 구성된다.  스페이스(‘ ‘)만이 whitespace character로 간주되며, 시작 부분을 포함하여 문자열 내에 많이 존재할 수 있다.  minus(‘-‘) 및 plus(‘+’) 기호로 숫자가 시작될 수 있다.  첫 non-whitespace character가 숫자 및 ‘+’, ‘-‘가 아닐 경우, 0을 리턴 32-bit signed integer(-2^31 ~ 2^31 - 1)를 기준으로 하여, 해당 범위를 넘는 경우 INT_MAX 혹은 INT_MIN을 리턴Example 1:  Input : s = “42” Output : 42Example 2:  Input : s = “ -042” Output : -42Example 3:  Input : s = “1337c0d3” Output : 1337Example 4:  Input : s = “0-1” Output : 0Example 5:  Input : s = “words and 987” Output : 0Solution 1Note:  strip() : 문자열 양쪽으로 한 칸 이상의 연속된 공백을 모두 지우는 함수 split() : 공백을 기준으로 문자열을 나누어 리스트로 반환123456789101112131415161718192021222324class Solution:  def myAtoi(self, str: str) -&gt; int:    idx = 0    s = str. strip(). split()    if len(s) == 0 :       return 0        s = s[0]    if s[0] == '+' or s[0] == '-' :      idx = 1    for ch in s[idx:] :      if ch. isdigit() :        idx += 1      else :        break        res = s[:idx]    res = int(res) if (res != '+' and res != '-' and res) else 0    if res &lt; -2 ** 31 :      return -2 ** 31    elif res &gt; 2 ** 31 - 1 :       return 2 ** 31 - 1    else :      return resSolution 2Note: str을 한 문자씩 확인하면서 숫자를 찾는 방식으로 구현 1234567891011121314151617181920212223class Solution:  def myAtoi(self, str: str) -&gt; int:    res, idx, isminus = 0, 0, False    intmax, intmin = 2 ** 31 - 1, -2 ** 31    if not str :      return 0    for i in range(len(str)) :      if str[i] != ' ' :        idx = i        break    if str[idx] == '-' or str[idx] == '+' :      isminus = True if str[idx] == '-' else False      idx += 1    for i in range(idx, len(str)) :      if str[i]. isdigit() :        res = res * 10 + int(str[i])      else :        break    if isminus :      res *= -1      return intmin if res &lt; intmin else res    else :      return intmax if res &gt; intmax else res"
    }, {
    "id": 95,
    "url": "http://localhost:4000/reverse-integer/",
    "title": "[Leetcode] 7. Reverse Integer",
    "body": "2019/06/20 - 주어진 32-bit 정수를 뒤집는 문제  32-bit signed integer 기준 (범위 : -2^31 ~ 2^31 - 1) 해당 범위를 넘는 경우, 0을 출력Example 1:  Input : x = 123 Output : 321Example 2:  Input : x = -123 Output : -321Example 3:  Input : x = 120 Output : 21Note: reverse 문자열 구하는 방법 : [::-1] 1234567891011class Solution:  def reverse(self, x: int) -&gt; int:    if x &gt; 0 :      res = int(str(x)[::-1])    else :      res = -1 * int(str(x * -1)[::-1])        if -2**31 &lt;= res &lt;= 2**31 - 1 :      return res    else :      return 0"
    }, {
    "id": 96,
    "url": "http://localhost:4000/longest-substring-without-repeating-characters/",
    "title": "[Leetcode] 2. Longest Substring Without Repeating Characters",
    "body": "2019/06/13 - 주어진 문자열에서 문자가 반복되지 않는 최대 길이의 substring의 길이를 구하는 문제  subsequence가 아닌 substring이어야 한다. (e. g. , pwwkew에서 pwke는 subsequence)Example 1:  Input : s = “abcabcbb” Output : 3 “abc” -&gt; 3Example 2:  Input : s = “bbbbb” Output : 1 “b” -&gt; 1Example 3:  Input : s = “pwwkew” Output : 3 “wke” -&gt; 3 (not “pwke”)Note: dict 사용 (key : 출현한 문자 / value : 해당 문자의 index)sliding window 방식반복된 문자가 나타났을 경우, 지금의 substring에의 포함 여부 확인 후 업데이트 1234567891011121314class Solution:  def lengthOfLongestSubstring(self, s: str) -&gt; int:    seen = {}    res = temp = start = 0        for i, ch in enumerate(s) :      if ch in seen and seen[ch] &gt;= start :        res = max(res, temp)        temp = i - seen[ch]        start = seen[ch] + 1      else :        temp += 1      seen[ch] = i    return max(res, temp)"
    }, {
    "id": 97,
    "url": "http://localhost:4000/add-two-numbers/",
    "title": "[Leetcode] 2. Add Two Numbers",
    "body": "2019/06/12 - 두 개의 Linked List가 주어졌을 때, 두 Linked List의 합을 구하는 문제  각 노드에는 정확히 1자리의 숫자가 포함되어 있다.  숫자는 역순으로 저장되어 있다. (e. g. , 342 : 2 -&gt; 4 -&gt; 3) 숫자 0이 아닌 경우, 0으로 시작하는 숫자는 없다. (e. g. , 043은 없다)Example 1:  Input : l1= [2, 4, 3], l2 = [5, 6, 4] Output : [7, 0, 8] 342 + 465 = 807Example 2:  Input : l1 = [0], l2 = [0] Output : [0]Example 3:  Input : l1 = [9, 9, 9, 9, 9, 9, 9], l2 = [9, 9, 9, 9] Output : [8, 9, 9, 9, 0, 0, 0, 1]Note: divmod : python 내장함수 (a/b, a%b 값을 리턴) 123456789101112131415161718192021222324# Definition for singly-linked list. # class ListNode:#   def __init__(self, x):#     self. val = x#     self. next = Noneclass Solution:  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:    up = 0    res = ListNode(-1)    tail = res        while l1 or l2 or up :      val1 = (l1. val if l1 else 0)      val2 = (l2. val if l2 else 0)      up, num = divmod(val1 + val2 + up, 10)            tail. next = ListNode(num)      tail = tail. next            l1 = (l1. next if l1 else None)      l2 = (l2. next if l2 else None)        return res. next"
    }, {
    "id": 98,
    "url": "http://localhost:4000/two-sum/",
    "title": "[Leetcode] 1. Two Sum",
    "body": "2019/06/11 - 주어진 정수 배열에서 두 값의 합이 찾고자 하는 값(target)일 경우, 두 인덱스를 반환하는 문제  정확히 하나의 솔루션이 존재한다.  동일한 값은 두 번 사용할 수 없다. Example 1:  Input : nums = [2, 7, 11, 15], target = 9 Output : [0, 1] nums[0] + nums[1] = 2 + 7 = 9Example 2:  Input : nums = [3, 2, 4], target = 6 Output : [1, 2]Example 3:  Input : nums = [3, 3], target = 6 Output : [0, 1]Note: dict를 사용하여 해결 (key : 확인한 정수값, value : 해당 값의 인덱스) 1234567891011class Solution:  def twoSum(self, nums: List[int], target: int) -&gt; List[int]:    seen = {}    for i, num in enumerate(nums) :      temp = target - num      if temp in seen :        return [seen[temp], i]      else :        seen[num] = i    return []"
    }, {
    "id": 99,
    "url": "http://localhost:4000/cudaEvent/",
    "title": "[CUDA 7] GPU 실행시간 측정 - cudaEvent",
    "body": "2016/01/15 - GPU에서 실행 시간을 측정할 수 있는 방법은 StopWatchInterface를 사용하는 등 여러 가지가 있지만, NVIDIA에서 공식적으로 제공하는 Programming Guide에서 확인할 수 있는 내용인 cudaEvent를 소개하고자 합니다. 사용하는 방법은 다음과 같습니다. 123456789101112131415161718192021// cudaEvent createcudaEvent_t start, stop;cudaEventCreate(&amp;start);cudaEventCreate(&amp;stop);. . . cudaEventRecord(start, 0);// 실행 시간을 측정할 GPU 코드cudaEventRecord(stop, 0);cudaEventSynchronize(stop);float elapsedTime;cudaEventElapsedTime(&amp;elapsedTime, start, stop);. . . // cudaEvent destroycudaEventDestroy(start);cudaEventDestroy(stop);우선 두 개의 cudaEvent 변수를 생성해주어야 합니다. cudaEvent는 record하는 순간의 timestamp를 저장하는 형식이기 때문에 2개가 필요합니다. 이후 cudaEventRecord() 함수를 이용하여 시작하는 순간과 끝나는 순간의 timestamp를 저장하면 됩니다. 시간은 cudaEventElapsedTime() 함수를 이용하여 받아오는데, 기본적으로 float 형을 사용합니다. 마지막으로 cudaEventDestroy() 함수를 이용하여 cudaEvent를 destroy 해주면 마무리됩니다. "
    }, {
    "id": 100,
    "url": "http://localhost:4000/cpp-cuda-function/",
    "title": "[CUDA 5.5] cpp에서 CUDA 함수 사용하기",
    "body": "2015/04/07 - 이번 포스팅에서는 cpp에서 CUDA 함수를 사용하는 방법에 대하여 이야기해보겠습니다. 지금껏 . cu 파일만으로 프로젝트를 구성하게 되면 다음과 같은 구조로 나타납니다.  main 함수에서는 kernel 함수로 __global__ 함수를 호출하고, __global__ 함수는 sub 함수로 __device__ 함수를 호출하면서 프로그램이 진행됩니다. 즉, . cu 파일 내에서 main 함수가 있고, __global__ 함수와 __device__ 함수가 존재해 서로를 호출하는 데에 문제가 없었을 것입니다. 하지만 일반적인 프로그램의 경우 cpp(혹은 c)와 CUDA를 혼재해서 사용하게 되고, 그렇게 되면 . cu 파일에 있는 CUDA 함수들을 호출하는 데에 문제가 생깁니다. main 함수는 . cpp 파일에 있고, CUDA 함수는 . cu 파일에 있는 구조가 되기 때문에 그것을 정의해주지 않으면 인식하지 못하기 때문입니다. cpp에서 CUDA 함수를 사용하게 되는 과정을 간단히 구조화하면 다음과 같습니다.  main 함수는 . cpp 파일에 있고, 다른 cpp 함수들도 호출하면서 프로그램이 진행됩니다. 그러다 CUDA 함수를 사용할 경우가 생기면 . cu 파일 내에 정의된 __host__ function을 호출하는 방식으로 CUDA 함수를 사용합니다. __host__ 함수는 필요한 CUDA 함수를 진행하여 결과를 얻어 main 함수, 혹은 cpp 함수로 전달해주는 역할을 합니다. 여기서 중요한 점은 __host__ function과 main 함수는 다르다는 점입니다. main 함수는 __host__ 함수라고 할 수 있지만, 모든 __host__ 함수가 main 함수는 아닙니다. __host__ 함수에 extern  C 라고 표시가 되어 있는데, 이것이 바로 cpp에서 CUDA 함수를 호출할 수 있게 해 주는 문법입니다. 사용하는 방법은 다음과 같습니다. 우선 cpp 파일에 이러이러한 CUDA 함수를 사용할 것이라고 정의하여 줍니다. 일반적으로 header file에 정의하게 되지만, 프로젝트의 사이즈가 크지 않다면 CUDA 함수를 호출하는 부분이 있는 파일에 정의해주면 됩니다. 1extern  C  void cuda_function(int a, int b, . . . );일반적으로 함수를 정의할 때처럼 정의해주면 되지만, 중요한 점은 앞에 extern  C  를 붙여야 한다는 것입니다. 이렇게 정의한 함수를 . cu 파일에서 __host__ 함수로 작성하면 됩니다. 12345678910__global__ void global_function(int a, int b, . . . ) {  . . . }extern  C  void cuda_function(int a, int b, . . . ) {  . . .   global_function&lt;&lt;&lt;blockDim, threadDim&gt;&gt;(a, b, . . . );  checkCudaErrors(cudaThreadSynchronize());  . . . }위 코드는 . cu 파일에 작성되는 코드입니다. extern  C 를 붙인 __host__ 함수는 결국 cpp와 CUDA 함수들을 연결해주는 연결다리 역할을 한다고 볼 수 있습니다. 실제로 사용하는 예는 다음과 같습니다. 제 프로젝트에서 작성한 코드 일부입니다. 12345678910111213141516//kernel Functions//glInputOutput_kernel. cuextern  C  void setupTexture(int iv, int ih, Pixel *data, int bpp, int num);extern  C  void deleteTexture(int num);extern  C  void deleteAllTextures();extern  C  void displayMod(Pixel *data, Pixel *bgData, Pixel *curData, Pixel *diffData, int v, int h, enum showBoxMode mode);// diffImage. cuextern  C  double diffImage(Pixel *bgData, Pixel *curData, Pixel *diffData, unsigned int width, unsigned int height, unsigned int size);// bilateralFilter. cuextern  C  void initTexture(int width, int height, Pixel *image);extern  C  void freeTexture();extern  C  void updateGaussian(float delta, int radius);extern  C  double initBilateralFilterCUDA(float delta, int radius, int width, int height, Pixel *pixels);extern  C  double bilateralFilter(Pixel *pixels, int width, int height, float e_d, int radius, int iterations);123456789__global__ void imageSubtractionGlobal(Pixel *bgData, Pixel *curData, Pixel *diffData, int x) {  int i = blockDim. x * blockIdx. x + threadIdx. x;  diffData[i] = MIN(MAX((bgData[i] - curData[i]), 0. f), 255. f);}extern  C  void diffImage(Pixel *bgData, Pixel *curData, Pixel *diffData, unsigned int width, unsigned int height, unsigned int size) {  imageSubtractionGlobal&lt;&lt;&lt;512, 512&gt;&gt;&gt;(bgData, curData, diffData, width);  checkCudaErrors(cudaThreadSynchronize());}"
    }, {
    "id": 101,
    "url": "http://localhost:4000/cuda-memory-optimization/",
    "title": "[CUDA 5.5] CUDA 메모리 성능 최적화",
    "body": "2015/04/04 - ※ 이 글은 2014년도에 작성된 글입니다. 사진이나 세부적인 내용은 지금과 다를 수 있습니다. CUDA 메모리는 CPU와 비교하면 무척이나 빠른 메모리 액세스 속도를 제공하지만, 최적화된 성능을 발휘하기 위해서는 여러 조건들을 충족시켜야 합니다. CUDA는 수백, 수천 개의 코어에서 DRAM이나 캐시에 있는 데이터를 동시에 읽고, 쓰기 때문에 데이터 병목 현상(bottleneck)이 발생하게 됩니다. 이러한 제약 조건들도 새로운 그래픽 카드가 출시되면서 점차 개선되고 있지만, CUDA 어플리케이션의 성능을 향상시키기 위해서는 이러한 병목 현상을 피하고 이상적인 병렬화를 구현할 필요가 있습니다. 글로벌 메모리 액세스 결합 (Coalescing)CUDA 프로그램에서 구현하는 솔루션과 데이터의 형식에 따라 다양한 글로벌 메모리 액세스 패턴이 나타나게 됩니다. NVIDIA 그래픽 카드의 메모리 전송은 한 번에 512bit를 읽어올 때 최대의 성능을 발휘한다고 알려져 있습니다. 글로벌 메모리를 읽어올 때 최대 bandwidth를 사용할 수 있는 조건이 있는데, 이것을 메모리 결합(Coalescing) 조건이라고 합니다. CUDA에서 결합 조건을 충족할 때와 하지 못했을 때 그래픽 카드의 종류에 따라 최대 10배의 성능 차이가 발생합니다. GeForce 200 시리즈 이후로 글로벌 메모리 액세스 결합 전송 조건이 많이 완화되고, 자동화됨에 따라 이전 시리즈의 그래픽 카드보다 쉽게 개선된 성능을 보입니다. 하지만 가끔 비결합 전송 상태로 동작하여 낮은 성능을 나타낼 때도 있기 때문에 프로그램을 실행하면서 성능을 확인하여 결합 전송이 자동으로 이루어지는지를 확인할 필요가 있습니다. 공유 메모리 뱅크 충돌 (Bank Conflict)공유 메모리는 GPU 프로세서 내부에 장착되어 있어 제대로 사용하면 빠른 속도로 데이터를 처리할 수 있는 CUDA의 큰 장점 중 하나입니다. 공유 메모리의 속도를 저하하는 요인으로는 공유 메모리를 구성하는 메모리 뱅크의 액세스 충돌(Bank Conflic)이 있습니다. 메모리 뱅크(Memory Bank)는 각 뱅크마다 한 번의 GPU 사이클에 한 번 액세스 할 수 있으며, 뱅크의 개수만큼의 스레드가 병렬로 모든 뱅크에 동시에 액세스 할 때 가장 큰 효율을 얻을 수 있습니다. 간단한 섬영르 위해 16KB 공유 메모리와 4개의 뱅크가 있고, 각각의 뱅크는 1KB의 메모리로 이루어져 있다고 가정합시다. 또, 뱅크 0번부터 4byte씩 메모리가 배치되어 16byte 블록이 하나의 열을 이루는 형식이라고 가정하겠습니다. 뱅크 충돌이 없는 공유 메모리 액세스: 위 그림은 뱅크 충돌이 없는 공유 메모리 액세스를 나타냅니다. 공유 메모리에는 글로벌 메모리와 같은 시작 address나 결합 전송 조건은 없지만, 한 스레드 당 하나의 뱅크에 액세스 할 수 있다는 제약이 있습니다. 그림에서는 4개의 스레드가 각각 하나의 뱅크에 액세스하여 뱅크 충돌이 없는 이상적인 패턴을 나타내고 있습니다. 공유 메모리는 글로벌 메모리와 같은 액세스 시작 위치 또는 오름차순 정렬 조건이 없기 때문에 랜덤 액세스에 대해서도 같은 뱅크 액세스만 없으면 효괒거으로 동작하게 됩니다.  즉, 위 그림과 같이 스레드가 어지럽게 공유 메모리에 액세스하더라도 같은 뱅크끼리 겹치는 스레드가 없다면 공유 메모리는 효과적으로 동작합니다. 2-way 뱅크 충돌: 만일 모든 스레드가 한 번에 공유 메모리를 읽거나 쓸 때, 2개의 스레드가 하나의 뱅크에 액세스하려고 하면 뱅크 충돌이 발생하게 됩니다. 2번의 뱅크 충돌이 발생하는 것을 2-way 뱅크 충돌이라고 하는데, 2-way 뱅크 충돌이 발생하면 GPU가 2번의 사이클에 나누어 공유 메모리를 차례로 가져오게 되고, 결국 효율이 절반으로 떨어지게 됩니다.  위 그림은 모든 스레드가 2개씩 하나의 뱅크에 액세스하고 있는 2-way 뱅크 충돌을 나타냅니다. 비슷한 예로 4-way 뱅크 충돌 또한 존재하는데, 4-way 뱅크 충돌이 일어나게 되면 효율은 1/4로 떨어지게 됩니다. CUDA에서 항상 모든 스레드가 2개씩 하나의 뱅크에 액세스해야만이 2-way 뱅크 충돌이 되는 것은 아닙니다. 모든 스레드 중에서 2개의 스레드만 같은 뱅크에 액세스하더라도 결국 GPU는 2번의 사이클에 나누어 공유 메모리에 접근해야 하기 때문에 효율이 절반으로 떨어지는 것은 똑같습니다.  위 그림처럼 모든 스레드가 정렬되어 공유 메모리에 액세스하고 있지만, 스레드 0과 스레드 1이 뱅크 1에 동시에 액세스하고 있는 경우 또한 2-way 뱅크 충돌입니다. 이렇게 프로그램이 구현되어 있으면 아무리 다른 스레드들이 정렬되어 있다고 하여도 전체 효율은 절반으로 떨어집니다. 이것은 워프 단위로 실행하고 워프의 절반 단위로 메모리에 액세스하는 CUDA thread의 특징 때문입니다. 16-way 뱅크 충돌: 16-way 뱅크 충돌은 1차원으로 구성된 스레드-블록(thread-block) 구조에서는 잘 발생하지 않습니다. 하지만 2차원 스레드-블록 구조로 작업을 분할할 때 스레드 인덱스 처리가 제대로 되지 않으면 발생할 수 있습니다. 16-way 뱅크 충돌이 일어나면 2-way 뱅크 충돌이나 4-way 뱅크 충돌과 마찬가지로 각 스레드가 하나의 뱅크에 차례로 액세스하기 때문에 효율이 1/16으로 떨어지게 됩니다. 16-way 뱅크 충돌이 주로 2차원 스레드-블록 구조에서 발생하는 이유는 1차원의 경우 일반적으로 행 방향으로 인덱스를 진행하여 액세스하지만, 2차원에서는 열 방향으로도 인덱스를 진행하는 경우가 생기기 때문입니다.  위 그림과 같이 행 방향으로만 인덱스를 진행할 경우 뱅크 충돌이 발생하지 않고 정상적으로 동작하게 됩니다. 하지만 열 방향으로 인덱스를 진행하면 아래와 같이 뱅크 충돌이 발생할 수 있습니다.  위 그림은 공유 메모리의 뱅크 0에 16개의 스레드가 모두 액세스하여 16-way 뱅크 충돌이 발생하게 되는 상황을 나타냅니다. 이와 같은 뱅크 충돌을 피하기 위해서는 알고리즘을 수정하기 보다는 메모리 할당 공간을 수정하는 것이 좋은 방법입니다.  위 그림은 공유 메모리에 16x17의 배열이 물리적으로 할당된 형태를 나타냅니다. 이와 같은 방법을 메모리 패딩(Memory Padding)이라고 합니다. 위와 같이 공유 메모리를 16x17로 하면 행 방향과 열 방향의 메모리가 동일한 뱅크에 할당되지 않습니다. 약간의 공간을 더 소비함으로써 16-way 뱅크 충돌을 피하고, 뱅크 충돌이 발생했을 때보다 16배의 액세스 속도를 얻을 수 있습니다. 고정 메모리 (Pinned Memory)페이지 락 메모리(Page Lock Memory) 또는 고정 메모리(Pinned Memory)라 불리는 시스템 메모리는 가상 메모리(Virtual Memory) 기술과 관련이 있습니다. 가상 메모리는 컴퓨터에 장착된 RAM의 용량에 한계가 있어 충분하지 않기 때문에 발생하는 메모리 부족 문제를 해결하기 위한 방법으로 개발된 것입니다. 가상 메모리는 컴퓨터와 운영체제에 의해 제어되며 RAM의 부족한 용량을 HDD의 도움을 받아 해결합니다. 운영체제 시스템에 RAM과 HDD의 공간을 이용하여 가상으로 큰 메모리 공간을 페이지 단위로 분할하여 제공하는 것입니다. CUDA 프로그램의 약점 중 하나는 GPU로 계산하기 전에 입력 데이터를 host에서 device로 복사하고, 또 계산된 결과를 device에서 host로 복사하는 과정이 추가되는 것입ㄴ디ㅏ. 이 시간은 기존의 프로그램과 비교했을 때 추가적인 부하로 작용하며, 병목 현상(bottleneck)이 발생할 가능성이 높습니다. 때문에 이 시간을 줄이고자 CUDA 프로그램을 구현할 때 여러 가지 방법을 사용하게 됩니다. 그 중 하나가 바로 가상 메모리 기술의 일부를 제한하고 물리적인 RAM 공간만을 사용하는 것입니다. 가상 메모리를 이용하면 메모리를 사용하기 위해 HDD와 RAM 공간의 페이지 치환이 일어나게 되는데, 이 시간을 줄이고 물리적인 RAM에서 device로 복사하는 것입니다. 이렇게 페이지 치환이 되지 않는 메모리를 페이지 락 메모리(Page Lock Memory) 또는 고정 메모리(Pinned Memory)라고 부르는데, 이는 RAM 공간에만 상주하는 메모리를 의미합니다. 고정 메모리를 사용하면 일반적인 힙(Heap) 메모리 할당 방법보다 약 10~50%의 전송 속도가 향상됩니다. 또 CUDA에서 스트림(Stream, 비동기 함수)를 사용하기 위해서는 고정 메모리를 이용해야만 합니다. 고정 메모리는 CUDA API 함수 호출을 통해 사용할 수 있습니다. 하지만 고정 메모리는 항상 물리적 RAM 공간에 상주하기 때문에 고정 메모리를 너무 많이 사용할 경우 컴퓨터의 가상 메모리가 원활하게 작동하기 어려워 메모리 성능과 전체 시스템의 성능 저하를 가져올 수 있다는 단점이 있습니다. 제로 복사 (Zero-copy)제로 복사(Zero-copy 혹은 MApped Memory) 기능은 단어 뜻 그대로 복사를 하지 않는다는 의미입니다. 대부분의 CUDA 프로그램은 GPU를 사용하기 위해 입력 데이터를 host에서 device로 복사하고, 그 데이터를 처리하여 출력 데이터를 device에서 host로 복사합니다. 이는 데이터 읽기와 계산, 쓰기의 과정이 차례로 실행되며 데이터 전송 시 사용되는 PCI 버스를 한 방향만 사용하게 합니다. 제로 복사는 GPU가 host에 할당된 고정 메모리 영역에 바로 액세스하여 데이터를 읽고 쓰는 작업을 말합니다. PCI 버스를 이용하여 데이터를 전송하는 것은 동일하기 때문에 전송 속도가 빨라지는 것은 아니지만, 메모리에서 읽어들인 데이터를 계산하고 결과값을 메모리에 쓰면 비동기로 양방향 PCI 전송이 진행되기 때문에 그만큼의 성능 향상을 얻을 수 있습니다. 이 방법은 통상적으로 1. 5배에서 2배 가량의 성능 향상 효과가 있다고 알려져 있습니다. 하지만 이런 성능 향상 효과를 얻으려고 맵드 메모리(Mapped Memory)를 사용할 때 글로벌 메모리의 결합 전송(Coalescing)과 동일한 조건을 커널에서 충족시켜야 한다는 제약이 있습니다. 만일 커널에서 작은 크기의 데이터를 많은 횟수로 맵드 메모리에 액세스하게 되면 통상적인 데이터 전송보다 오히려 성능이 떨어지는 효과가 나타납니다. 제로 복사 기능은 GeForce 200 시리즈 이후 계열 GPU부터 지원하며, host 측의 고정 메모리(Pinned System Memory)에 직접 읽고 쓰게 됩니다. CUDA API 함수를 이용하여 맵드 메모리를 할당하는 방법으로 제로 복사를 사용할 수 있습니다. host에 메모리를 할당하고, device 메모리 영역에서 host 측 메모리로 바로 사용할 포인터를 지정해주는 방법으로 사용합니다. 포터블 고정 메모리 (Portable Pinned Memory)고정된 메모리를 이용한 제로 복사는 싱글 스레드 영역에서 유효합니다. 하나의 GPU로 구성된 PC에서는 큰 불편함 없이 고정 메모리를 사용할 수 있지만, 복수의 GPU로 수정된 PC에서는 문제가 생길 수 있습니다. 동시에 2개 이상의 GPU를 구동시키려면 두 개 이상의 host thread를 생성하여 처리하게 되는데, 이 때 하나의 스레드에서 생성한 고정 메모리는 다른 스레드에서 사용할 수 없게 됩니다. 이러면 한정된 시스템 자원인 고정 메모리를 각각의 스레드에서 생성하여 자원을 낭비하는 결과를 낳게 됩니다. 이러한 자원 낭비를 피하고자 사용하는 방법이 바로 포터블 고정 메모리(Portable Pinned Memory)입니다. 포터블 고정 메모리를 사용하기 위해서는 CUDA API 함수에서 옵션을 바꾸어 주는 방법으로 사용할 수 있습니다. 이것으로 CUDA 메모리 성능 최적화 기법에 대한 소개가 끝났습니다. 메모리 성능은 CUDA 프로그램의 성능과 직결된 문제인만큼 다양한 관점에서 최적화 방법을 모색해야 할 것입니다. "
    }, {
    "id": 102,
    "url": "http://localhost:4000/cuda-c-extension-2/",
    "title": "[CUDA 5.0] CUDA C 확장 키워드 (CUDA C Extension) - 변수의 수식어",
    "body": "2015/04/03 - ※ 이 글은 2013년도에 작성된 글입니다. 사진이나 세부적인 내용은 지금과 다를 수 있습니다. 저번 포스팅에 이어 CUDA C extension에 관한 설명을 마무리 짓도록 하겠습니다. 변수의 수식어변수의 수식어들은 메모리 영역에 따라서 구분되어 집니다. 즉, 변수가 위치하는 메모리의 위치가 어디냐에 따라 __device__, __constant__, __shared__ 세 가지로 나뉘어집니다. 메모리에 대해서는 이후 포스팅에서 따로 자세히 설명하도록 하고, 이번 포스팅에서는 간단하게만 언급하도록 하겠습니다. __device__: 함수의 수식어인 __device__와는 다르므로 꼭 구분해 주셔야 합니다. __device__ 변수는 글로벌 메모리 영역에 할당되어 프로그램이 종료될 때까지 유효하게 됩니다. __device__ 변수에는 모든 thread가 접근할 수 있고, host에서는 API 함수를 통해 읽기와 쓰기가 가능합니다. 1234567891011121314151617181920212223#include  cuda_runtime. h #include  device_launch_parameters. h #include &lt;stdio. h&gt;__device__ int d_sum;__global__ void add(int a, int b) {  d_sum = a + b;}__host__ int main() {  int h_sum = 0;  cudaMemset(&amp;d_sum, 0, sizeof(int));  add&lt;&lt;&lt;1, 1&gt;&gt;&gt;(2, 7);  cudaMemcpyFromSymbol(&amp;h_sum, d_sum, sizeof(int), 0, cudaMemcpyDeviceToHost);  printf( 2 + 7 = %d\n , h_sum);  return 0;}__device__ 변수는 위와 같이 cudaMemcpyFromSymbol이라는 함수를 통해 host 메모리에 불러올 수 있습니다. 여기서 주의하실 점은 CUDA 5. 0부터 바뀐 점으로, 이전 버전들과는 symbol을 다른 방식으로 사용하여야 한다는 점입니다. 1  cudaMemcpyFromSymbol(&amp;h_sum,  d_sum , sizeof(int), 0, cudaMemcpyDeviceToHost);이전 방식으로 cudaMemcpyFromSymbol 함수를 호출하면 위와 같이 호출하여야 합니다. 즉, 이전 버전들에서는 symbol을 character string으로 사용하였다면, CUDA 5. 0부터는 symbol을 direct로 사용할 수 있도록 바뀌었습니다. 대신 이전 버전들과 같은 방법으로는 사용할 수 없습니다. 하지만 CUDA 5. 0에서도 symbol을 direct로 사용하였을 때, 빨간 밑줄이 그어지며 다음과 같은 error가 발생합니다만, 실제로 실행시켰을 때는 아무런 문제가 없습니다. 추후에 업데이트 되면서 사라질 문제가 될 것 같습니다.  __constant__: __constant__ 변수는 그 이름에서도 알 수 있듯이 상수 메모리, 즉 constant memory 영역에 할당되어 프로그램이 종료될 때까지 유효한 변수입니다. 모든 thread에서 접근이 가능하지만, __device__ 변수와는 다르게 __constant__ 변수는 읽기만 가능합니다. 대신 host에서 cudaMemcpyToSymbol 함수를 통해 값을 쓸 수 있도록 되어 있습니다. 1234567891011121314151617#include  cuda_runtime. h #include  device_launch_parameters. h #include &lt;stdio. h&gt;__constant__ int d_sum = 0;int main() {  int h_sum1 = 9;  int h_sum2 = 0;  cudaMemcpyToSymbol(d_sum, &amp;h_sum1, sizeof(int), 0, cudaMemcpyHostToDevice);  cudaMemcpyFromSymbol(&amp;h_sum2, d_sum, sizeof(int), 0, cudaMemcpyDeviceToHost);  printf( h_sum2 = %d\n , h_sum2);  return 0;}여기서도 주의하셔야 할 점은 CUDA 5. 0부터 cudaMemcpyToSymbol의 쓰임 역시 바뀌었다는 점입니다. 위에서 __device__ 변수를 설명하면서 언급하였던 cudaMemcpyFromSymbol 함수와 마찬가지로 symbol을 direct로 사용하도록 바뀌었습니다. 이전 버전들에서는 다음과 같이 사용하였지만, CUDA 5. 0부터는 아래 방식을 사용할 수 없습니다. 1  cudaMemcpyToSymbol( d_sum , &amp;h_sum1, sizeof(int), 0, cudaMemcpyHostToDevice);즉, 위와 같이 symbol을 character string으로 사용할 수 없습니다. __shared__: __shared__ 변수 역시 그 이름에서 알 수 잇듯 공유 메모리 영역에 할당됩니다. 다만 다른 변수들과는 달리 실행 중인 thread block 상에서만 유효하다는 것이 특징입니다. __device__ 변수나 __constant__ 변수가 프로그램이 종료될 때까지 유효한 것과는 다릅니다. 또, __shared__ 변수는 block 내의 thread는 접근하여 읽고 쓰는 것이 가능하도록 되어 있습니다. 12345678910111213141516171819202122232425#include  cuda_runtime. h #include  device_launch_parameters. h #include &lt;stdio. h&gt;__global__ void add(int a, int b, int *c) {  __shared__ int sum;  sum = a + b;  *c = sum;}int main() {  int c;  int *dev_c;  cudaMalloc((void**)&amp;dev_c, sizeof(int));  add&lt;&lt;&lt;1, 1&gt;&gt;&gt;(2, 7, dev_c);  cudaMemcpy(&amp;c, dev_c, sizeof(int), cudaMemcpyDeviceToHost);  printf( 2 + 7 = %d\n , c);  cudaFree(dev_c);  return 0;}위는 __shared__ 변수를 사용한 예시입니다. 예시에서는 단순하게 하나의 block에 하나의 thread만이 실행되는 코드이지만, 많은 thread가 실행되는 코드라면 __shared__ 변수를 유용하게 사용할 수 있을 것입니다. 이것으로 CUDA C Extension에 대한 설명을 끝내도록 하겠습니다. 메모리에 대한 상세한 설명이나 CUDA의 다른 부분에 대해서는 이후 포스팅에서 더욱 자세히 다뤄보겠습니다. "
    }, {
    "id": 103,
    "url": "http://localhost:4000/cuda-c-extension-1/",
    "title": "[CUDA 5.0] CUDA C 확장 키워드 (CUDA C Extension) - 함수의 수식어",
    "body": "2015/04/03 - ※ 이 글은 2013년도에 작성된 글입니다. 사진이나 세부적인 내용은 지금과 다를 수 있습니다. 이번 포스팅에서는 CUDA C Extension, 즉 CUDA에서 확장된 키워드들에 대하여 소개하고자 합니다. 예제 코드를 보면 __global__과 같은 키워드들을 쉽게 발견할 수 있을 것입니다. 이러한 키워드들이 어떤 의미이며 무슨 역할을 하는지 알아야 보다 효율적인 프로그래밍이 가능할 것입니다. 함수의 수식어함수의 수식어들은 어디서 호출할 수 있느냐와 어디서 실행되느냐에 따라 나뉩니다. __global__, __device__, __host__, __device__ __host__ 이렇게 총 4가지의 경우가 가능합니다. __global__: 디바이스에서 실행되는 함수를 뜻합니다. 여기서 device란 이전 포스팅에서도 언급 했듯이 GPU를 뜻합니다. __global__로 수식된 함수는 host에서 호출할 수는 있어도 device에서 호출할 수는 없습니다. 대신 device로 실행하는 커널 함수 지정에 사용할 수 있습니다. 다음은 __global__로 수식한 함수의 간단한 예입니다. 1234567891011121314151617181920212223#include  cuda_runtime. h #include  device_launch_parameters. h #include &lt;stdio . h&gt;;__global__ void add(int a, int b, int *c) {  *c = a + b;}int main() {  int c;  int *dev_c;  cudaMalloc((void**)&amp;dev_c, sizeof(int));  add&lt;&lt;&lt;1, 1&gt;&gt;&gt;(2, 7, dev_c);  cudaMemcpy(&amp;c, dev_c, sizeof(int), cudaMemcpyDeviceToHost);  printf( 2 + 7 = %d\n , c);  cudaFree(dev_c);  return 0;}위와 같이 return type은 항상 void 형이어야 하며, 다른 return type은 가질 수 없습니다. 이것은 조금만 생각해보면 쉽게 그 이유를 알 수 있습니다. 지금의 예에서는 하나의 커널 함수만이 실행되었지만, 실제로는 수천, 수만 개의 커널 함수가 한꺼번에 실행될 것입니다. 만약 __global__ 함수의 리턴 타입이 void가 아니라면 수천, 수만 개의 커널 함수에서 제각각 return 값을 host로 넘겨주게 될 것입니다. 그러한 문제를 막기 위해 아예 void 형이 아닌 다른 return type을 가질 수 없도록 한 것입니다. 또, 함수의 호출 시에 &lt;&lt;&lt; block의 개수, thread의 개수 &gt;&gt;&gt;의 형식으로 block과 thread의 개수를 지정해 줄 수 있습니다. __global__ 함수는 device에서 실행되는 함수이지만 device에서는 호출할 수 없습니다. 즉, 재귀호출이 불가능합니다. 이것 또한 이 함수가 수만 개가 한꺼번에 실행되는 커널 함수라는 것을 생각해보면 그 이유를 쉽게 알 수 있습니다. 또한 함수 내에 static 변수를 가질 수 없으며, 가변형 인수를 가질 수 없는 등의 제약 사항이 존재합니다. 가변형 인수를 가질 수 없다는 것은 다음과 같은 식으로 함수를 호출하는 코드는 불가능하다는 것을 뜻합니다. 1  add&lt;&lt;&lt;1, 1&gt;&gt;&gt;(int a, int b, dev_c);또한 __global__ __host__와 같은 용법으로 쓰일 수 없고, 공유 메모리를 이용하며 256 바이트까지의 인수를 사용할 수 있습니다. __device__: 위의 __global__과 마찬가지로 device에서 실행되는 함수를 뜻합니다. 하지만 __global__과는 다르게 host에서 호출이 불가능하고, device에서만 호출이 가능합니다. 즉, __global__ 함수가 실행되었을 때 device 내에서 실행되는 서브 함수로 사용됩니다. device에서 실행되고 device에서 호출되기 때문에 재귀 호출이 가능하지 않느냐고 생각할 수도 있지만 마찬가지로 재귀호출은 할 수 없습니다. 1234567__device__ int subAdd(int a, int b) {  return a + b;}__global__ void add(int a, int b, int *c) {  *c = subAdd(a, b);}__global__에서 예시로 들었던 add 함수의 코드를 조금만 바꾼 __device__ 함수의 예시입니다. 실행시켜 보면 똑같은 결과값이 나오는 것을 알 수 있습니다. __global__ 함수는 device 내에서 실행되는 함수이기 때문에 __device__ 함수를 호출할 수 있습니다. 하지만 host에서는 호출할 수 없기 때문에 다음과 같은 호출은 불가능합니다. 12345678910111213141516#include  cuda_runtime. h #include  device_launch_parameters. h #include &lt;stdio. h&gt;__device__ int subAdd(int a, int b) {  return a + b;}int main() {  int c;  c = subAdd(2, 7);  print( 2 + 7 = %d\n , c);  return 0;}위 코드를 실행시키면 다음과 같은 에러가 발생합니다. 1error : calling a __device__ function( subAdd ) from a __host__ function( main ) is not allowed즉, __host__ 함수인 main 함수에서 __device__ 함수인 subAdd 함수를 호출할 수 없다는 것입니다. 추가적으로, __device__ 함수 역시 __global__ 함수와 마찬가지로 static 변수를 함수 내에 가질 수 없고, 가변형 인수를 가질 수 없습니다. __host__: __host__ 함수는 위에서 언급했던 __global__이나 __device__ 함수와는 실행되는 위치부터가 다릅니다. host에서 실행되며, host에서만 호출할 수 있고, device에서는 호출할 수 없습니다. main 함수가 그 대표적인 예입니다. main 함수를 통해서 알 수 있드시, __global__, __device__, __host__ 등의 키워드가 지정되지 않은 경우에는 __host__를 지정한 것과 동일한 효과를 지닙니다. 123456789101112131415161718192021222324252627#include  cuda_runtime. h #include  device_launch_parameters. h #include &lt;stdio. h&gt;;__device__ int subAdd(int a, int b) {  return a + b;}__global__ void add(int a, int b, int *c) {  *c = subAdd(a, b);}__host__ int main() {  int c;  int *dev_c;  cudaMalloc((void**)&amp;dev_c, sizeof(int));  add&lt;&lt;&lt;1, 1&gt;&gt;&gt;(2, 7, dev_c);  cudaMemcpy(&amp;c, dev_c, sizeof(int), cudaMemcpyDeviceToHost);  printf( 2 + 7 = %d\n , c);  cudaFree(dev_c);  return 0;}위의 코드처럼 main 함수를 __host__로 지정해주어도 아무런 문제 없이 잘 실행이 됩니다. 이는 main 함수가 __host__ 함수이기 때문이며, 어떤 함수인지 지정해주지 않았을 때는 default로 __host__로 지정되기 때문입니다. __host__ 수식어는 __global__ 수식어와 동시에 사용할 수는 없지만, __device__ 수식어와는 함께 사용할 수 있습니다. 바로 __device__ __host__와 같은 방법으로 사용하는 것인데요. 이에 대해서는 아래에서 따로 설명하도록 하겠습니다. __device__ __host__: __host__ 수식어와 __device__ 수식어를 동시에 사용한 경우입니다. 이 경우 host와 device 양쪽에서 모두 사용할 수 있는 함수로 작성할 수 있습니다. 1234567891011121314151617#include  cuda_runtime. h #include  device_launch_parameters. h #include &lt;stdio. h&gt;;__device__ __host__ int subAdd(int a, int b) {  return a + b;}int main() {  int c;  c = subAdd(2, 7);  printf( 2 + 7 = %d\n , c);  return 0;}위 코드를 실행시키면 역시나 아무런 문제 없이 잘 동작합니다. 이는 subAdd 함수가 host와 device 모두에서 사용할 수 있는 함수이기 때문입니다. 이러한 수식어를 사용하는 것이 무척이나 편리한 경우가 가끔 생기는데, host와 device 모두에서 호출하는 간단한 계산 같은 것을 __device__ __host__ 함수로 지정하여 사용하는 경우가 있습니다. 같은 내용의 함수를 device 용, host 용으로 두 개나 만들지 않고, 하나의 함수로 해결하는 것입니다. 그 때문에 device와 host 모두에서 사용가능한 함수가 필요했고, 이 함수는 host와 device 각각 호출이 가능하며, 호출된 곳(host라면 host, device라면 device)에서 실행될 필요가 있었습니다. 따라서 __global__ 키워드는 제외되고, __device__ __host__와 같은 형식으로 device와 host 모두에서 사용 가능하도록 만들어진 것입니다. 포스팅의 내용이 길어서 CUDA C 확장 키워드에 대해서 다음 포스팅에서 이어서 설명하도록 하겠습니다. 다음 포스팅에서는 변수의 수식어에 대해 이야기하도록 하겠습니다. "
    }, {
    "id": 104,
    "url": "http://localhost:4000/cuda-syntax-device/",
    "title": "[CUDA 5.0] CUDA syntax를 이용하여 device 정보 불러오기",
    "body": "2015/04/02 - ※ 이 글은 2013년도에 작성된 글입니다. 사진이나 세부적인 내용은 지금과 다를 수 있습니다. 본격적인 CUDA 코딩에 앞서 CUDA syntax를 이용하여 device의 정보를 불러오는 방법에 대해 소개하려고 합니다. 여기서 말하는 device란 CUDA acceleration(CUDA 가속)을 지원하는 GPU를 뜻합니다. 아래의 코드는 CUDA syntax를 이용하여 device의 정보를 불러와 출력하는 내용입니다. 123456789101112131415161718192021222324252627#include  cuda_runtime. h #include  device_launch_parameters. h #include &lt;stdio. h&gt;int main() {  int i;  cudaDeviceProp prop;  int count;  cudaGetDeviceCount(&amp;count);  for (i = 0 ; i &lt; count ; i++) {    cudaGetDeviceProperties(&amp;prop, i);    printf( -- %d번째 디바이스 --\n , i+1);    printf(  (1) 장치 이름 : %s\n , prop. name);    printf(  (2) Clock Rate : %d\n , prop. clockRate);    printf(  (3) 전역 메모리 용량 : %ld\n , prop. totalGlobalMem);    printf(  (4) 상수 메모리 용량 : %ld\n , prop. totalConstMem);    printf(  (5) Register per block : %d\n , prop. regsPerBlock);    printf(  (6) Max Grid Size : %d\n , prop. maxGridSize);    printf(  (7) Max Thread Dimension : %d\n , prop. maxThreadsDim);    printf(  (8) Max Thread per block : %d\n , prop. maxThreadsPerBlock);  }  return 0;}CUDA는 cudaDeviceProp이라는 구조체 형식에 device들의 정보를 저장하게 됩니다. 이를 이용하면 device의 다양한 정보를 불러올 수 있습니다. 아래는 위 코드를 실행시킨 결과입니다.  출력된 결과를 살펴보면, GeForce GT 750M이라는 하나의 device를 사용 중이며, clock rate나 메모리 용량이 얼마인지 알 수 있습니다. cudaDeviceProp은 이외에도 다양한 정보를 제공합니다. 이러한 데이터를 잘 활용하면 효과적인 CUDA 코딩을 할 수 있을 것입니다. 그러면 위 코드를 자세히 살펴봅시다. 1  cudaDeviceProp prop;Device property의 출력을 위해 구조체를 생성한 것입니다. 위에서 잠깐 언급했듯이 CUDA는 device의 정보를 구조체 형식에 저장합니다. cudaDeviceProp 구조체는 driver_types. h 파일에 선언되어 있으며, 이러한 header file들은 CUDA project를 생성하면 외부 종속성 폴더에 추가되도록 되어 있습니다. 아래는 cudaDeviceProp 구조체의 선언 부분입니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * CUDA device properties */struct __device_builtin__ cudaDeviceProp{  char  name[256];         /**&lt; ASCII string identifying device */  size_t totalGlobalMem;       /**&lt; Global memory available on device in bytes */  size_t sharedMemPerBlock;     /**&lt; Shared memory available per block in bytes */  int  regsPerBlock;        /**&lt; 32-bit registers available per block */  int  warpSize;          /**&lt; Warp size in threads */  size_t memPitch;          /**&lt; Maximum pitch in bytes allowed by memory copies */  int  maxThreadsPerBlock;     /**&lt; Maximum number of threads per block */  int  maxThreadsDim[3];      /**&lt; Maximum size of each dimension of a block */  int  maxGridSize[3];       /**&lt; Maximum size of each dimension of a grid */  int  clockRate;         /**&lt; Clock frequency in kilohertz */  size_t totalConstMem;       /**&lt; Constant memory available on device in bytes */  int  major;           /**&lt; Major compute capability */  int  minor;           /**&lt; Minor compute capability */  size_t textureAlignment;      /**&lt; Alignment requirement for textures */  size_t texturePitchAlignment;   /**&lt; Pitch alignment requirement for texture references bound to pitched memory */  int  deviceOverlap;       /**&lt; Device can concurrently copy memory and execute a kernel. Deprecated. Use instead asyncEngineCount. */  int  multiProcessorCount;    /**&lt; Number of multiprocessors on device */  int  kernelExecTimeoutEnabled;  /**&lt; Specified whether there is a run time limit on kernels */  int  integrated;         /**&lt; Device is integrated as opposed to discrete */  int  canMapHostMemory;      /**&lt; Device can map host memory with cudaHostAlloc/cudaHostGetDevicePointer */  int  computeMode;        /**&lt; Compute mode (See ::cudaComputeMode) */  int  maxTexture1D;        /**&lt; Maximum 1D texture size */  int  maxTexture1DMipmap;     /**&lt; Maximum 1D mipmapped texture size */  int  maxTexture1DLinear;     /**&lt; Maximum size for 1D textures bound to linear memory */  int  maxTexture2D[2];      /**&lt; Maximum 2D texture dimensions */  int  maxTexture2DMipmap[2];   /**&lt; Maximum 2D mipmapped texture dimensions */  int  maxTexture2DLinear[3];   /**&lt; Maximum dimensions (width, height, pitch) for 2D textures bound to pitched memory */  int  maxTexture2DGather[2];   /**&lt; Maximum 2D texture dimensions if texture gather operations have to be performed */  int  maxTexture3D[3];      /**&lt; Maximum 3D texture dimensions */  int  maxTextureCubemap;     /**&lt; Maximum Cubemap texture dimensions */  int  maxTexture1DLayered[2];   /**&lt; Maximum 1D layered texture dimensions */  int  maxTexture2DLayered[3];   /**&lt; Maximum 2D layered texture dimensions */  int  maxTextureCubemapLayered[2];/**&lt; Maximum Cubemap layered texture dimensions */  int  maxSurface1D;        /**&lt; Maximum 1D surface size */  int  maxSurface2D[2];      /**&lt; Maximum 2D surface dimensions */  int  maxSurface3D[3];      /**&lt; Maximum 3D surface dimensions */  int  maxSurface1DLayered[2];   /**&lt; Maximum 1D layered surface dimensions */  int  maxSurface2DLayered[3];   /**&lt; Maximum 2D layered surface dimensions */  int  maxSurfaceCubemap;     /**&lt; Maximum Cubemap surface dimensions */  int  maxSurfaceCubemapLayered[2];/**&lt; Maximum Cubemap layered surface dimensions */  size_t surfaceAlignment;      /**&lt; Alignment requirements for surfaces */  int  concurrentKernels;     /**&lt; Device can possibly execute multiple kernels concurrently */  int  ECCEnabled;         /**&lt; Device has ECC support enabled */  int  pciBusID;          /**&lt; PCI bus ID of the device */  int  pciDeviceID;        /**&lt; PCI device ID of the device */  int  pciDomainID;        /**&lt; PCI domain ID of the device */  int  tccDriver;         /**&lt; 1 if device is a Tesla device using TCC driver, 0 otherwise */  int  asyncEngineCount;      /**&lt; Number of asynchronous engines */  int  unifiedAddressing;     /**&lt; Device shares a unified address space with the host */  int  memoryClockRate;      /**&lt; Peak memory clock frequency in kilohertz */  int  memoryBusWidth;       /**&lt; Global memory bus width in bits */  int  l2CacheSize;        /**&lt; Size of L2 cache in bytes */  int  maxThreadsPerMultiProcessor;/**&lt; Maximum resident threads per multiprocessor */};위와 같이 선언되어 있는데, 각각 어떤 것을 의미하는지는 각 항목마다 설명이 주석처리 되어 있으므로 자세한 설명은 하지 않겠습니다. 앞서 출력해 보았던 내용 이외에도 엄청나게 많은 정보들을 저장하고 있지만, 가장 많이 쓰이게 될 몇 가지 정보들만 출력해 보았습니다. 12  int count;  cudaGetDeviceCount(&amp;count);device 장치의 개수를 획득하는 함수입니다. int 형 변수인 count를 만들고, 그것의 주소값을 argument로 넘겨주게 됩니다. cudaGetDeviceCount 함수는 cuda_runtime_api. h에 다음과 같이 정의되어 있습니다. 1extern __host__ __cudart_builtin__ cudaError_t CUDARTAPI cudaGetDeviceCount(int *count);parameter로 count의 포인터를 넘겨 받기 때문에 호출 시 argument의 사용에 주의해 주셔야 합니다. 함수의 이름에서 알 수 있다시피 count 변수에는 device의 개수 값이 들어갑니다. CUDA 뿐만이 아니라 다른 언어나 tool을 공부할 때에도 마찬가지로, 어떤 함수를 사용할 때 그것이 어떻게 정의되어 있는지 내부를 공부하는 것은 무척이나 많은 도움이 됩니다. 특히나 CUDA는 C 기반으로 짜여져 있는데다 주석도 잘 달려 있어 공부하기 편리합니다. 이렇게 CUDA syntax를 이용하여 device의 정보를 출력하는 방법에 대해 알아보았습니다. 이후 포스팅에서 CUDA 병렬 프로그래밍에 대해 더 자세히 알아보도록 하겠습니다. "
    }, {
    "id": 105,
    "url": "http://localhost:4000/cuda-syntax-highlighting/",
    "title": "[CUDA 5.0] CUDA Syntax Highlighting 설정하기",
    "body": "2015/04/01 - ※ 이 글은 2013년도에 작성된 글입니다. 사진이나 세부적인 내용은 지금과 다를 수 있습니다. VS에서 CUDA 코드를 작성하면 CUDA Syntax Highlighting은 물론이고 기본적인 C/C++ 문법마저도 Syntax Highlighting이 되지 않아 코드를 작성하기 무척이나 번거롭고 힘들었을 것입니다. 따라서, 이번 포스팅에서는 CUDA Syntax Highlighting 방법에 대해 소개하려 합니다. 이전 버전들과는 방법이 다르기 때문에, 다른 버전을 사용 중이라면 적용되지 않을 수도 있다는 점을 염두에 두시길 바랍니다. 우선 VS를 켜고, 상단 메뉴 바에서 도구 -&gt; 옵션으로 들어갑니다. 창이 하나 나타나는데, 여기서 프로젝트 및 솔루션 -&gt; VC++ 프로젝트 설정으로 들어가면 아래의 창 같은 화면이 뜹니다. 이 중 포함할 확장명에 . cu; cuh;를 추가합니다. 확장자명끼리의 구분은 ;로 구분하게 됩니다. . cu 파일은 CUDA source file이고, . cuh 파일은 CUDA header file입니다.  확장명에 추가했으면 이제 . cu와 . cuh를 C++ 편집 환경으로 설정해 줄 차례입니다. 옵션 창에서 텍스트 편집기 -&gt; 파일 확장명으로 들어가면, 아래와 같은 창이 나타납니다. 여기에 확장명 . cu, 편집기 Microsoft Visual C++을 선택하고 적용하면 됩니다. . cuh도 마찬가지 방법으로 적용해 줍니다.  이제 C:\ProgramData\NVIDIA Corporation\CUDA Samples\v5. 0\doc\syntax_highlighting\visual_studio_8 폴더로 들어가보면 usertype. dat 파일이 있을 것입니다. 이 파일을 C:\Program Files\Microsoft Visual Studio 10. 0\Common7\IDE 폴더에 복사해 넣으면 됩니다. 주소는 32bit 기준이므로, 64bit라면 Program Files (x86) 폴더에서 찾아 복사해 넣도록 합니다.  이것으로 CUDA Syntax Highlighting 준비가 모두 끝났습니다. VS를 다시 시작하거나 아니면 프로젝트를 다시 열면 문법에 맞는 색깔로 설정된 C/C++ 코드를 볼 수 있을 것입니다. 참고로, CUDA Syntax Highlighting을 위해서는 아래의 두 줄을 추가로 입력해 주어야지만 정상적으로 표현이 됩니다. 12#include  cuda_runtime. h #include  device_launch_parameters. h 이 두 줄은 모두 CUDA Project를 생성하면 만들어지는 kernel. cu에 포함되어 있습니다.  위는 정상적으로 CUDA Syntax Highlighting이 적용된 코드입니다. __global__이나 threadIdx와 같은 CUDA 문법들에도 highlighting이 적용된 것을 확인할 수 있습니다. 참고로 위 화면에서는 다른 테마가 적용되어 있으므로, 실제로 highlighting을 적용했을 때 다르게 보일 수 있습니다. "
    }, {
    "id": 106,
    "url": "http://localhost:4000/cuda-samples/",
    "title": "[CUDA 5.0] CUDA 예제 실행하기",
    "body": "2015/03/31 - ※ 이 글은 2013년도에 작성된 글입니다. 사진이나 세부적인 내용은 지금과 다를 수 있습니다. CUDA 5. 0을 설치하고, 리부팅을 하고 나면 NVIDIA CUDA Samples Browser v5. 0 아이콘이 생겼을 것입니다. 이름만으로도 어떤 프로그램인지 감이 오시나요? CUDA 5. 0부터는 Installer에 samples 또한 포함이 되어 있다고 저번 포스팅에서 언급하였습니다. 이 프로그램이 바로 설치와 같이 다운 받은 예제 파일들을 찾아보고, 실행해 볼 수 있는 프로그램입니다. 한 번 실행해 봅시다.  실행하면 보이는 바와 같이 다양한 샘플들을 찾아볼 수 있고, 실행시켜 볼 수도 있습니다. 이 샘플들을 실행시켰을 때, 아무 무리 없이 잘 돌아가면 설치가 제대로 되었다는 뜻입니다. 만약 실행이 되지 않는다면, 컴퓨터에 설치되어 있는 GPU가 CUDA 가속을 지원하는지를 확인하고, 또 NVIDIA 그래픽 드라이버가 최신 버전인지를 확인해 주세요. 이 중 CUDA N-Body Simulation을 실행시켜 봅시다. N-Body가 무엇인지 몰라도 어떤 프로그램인지는 그래픽으로 시뮬레이션해주기 때문에 알아보기 쉽습니다. 실행하는 방법은 오른쪽 편에 작은 글씨로 된 Run을 누르면 됩니다. 실행하면 다음과 같은 창 하나가 뜹니다. 이 창에서는 프로그램에 대한 간단한 설명 등과 함께 맨 아래쪽에 보면 어떤 device를 사용하고 있는지에 대한 정보도 같이 볼 수 있습니다. simulation을 위해 하나의 device를 사용하였고, 그 device는 GeForce 310M이라는 정보가 뜹니다. 이 정보는 각자 사용하는 GPU에 따라 다르게 나타날 것입니다.  그리고 하나 더 뜨는 창에서는 다음과 같이 N-Body Simulation이 이루어집니다. 현재 시뮬레이션 되고 있는 상태에 대해서는 화면 위쪽에 나타나게 되고, 화면 전체에 N-Body Simulation이 약간의 끊김이 있기는 하지만 빠르고 매끄럽게 진행되는 것을 확인할 수 있습니다. 심지어 310M이라는 낮은 사양의 GPU에서도 말이죠.  NVIDA CUDA Samples Browser에서는 이러한 N-Body Simulation 이외에도 다양한 예제들을 실행시켜 볼 수 있습니다. 그리고 이러한 예제들의 코드 역시 같이 다운받아져 있는데, 이 코드들은 C:\ProgramData\NVIDIA Corporation\CUDA Samples\v5. 0 폴더에 잘 정리되어 있습니다. ProgramData 폴더는 숨겨져 있는 폴더이므로 C 드라이브에 들어갔는데 폴더가 없다고 당황하지 않으셔도 됩니다. 위 주소로 들어가보면 다음과 같이 잘 정리된 CUDA 예제들의 코드를 확인하고, 직접 실행시켜 볼 수 있습니다.  아까 위에서 실행시켜 보았던 N-Body Simulation은 5_Simulation 폴더에 nbody라는 이름으로 들어가 있습니다. VS에서 실행시켜 보면 앞서 실행시켰던 것과 같은 결과가 나오는 것을 확인할 수 있습니다. 예제 파일들은 간단한 것부터 복잡하고 어려운 계산이나 그래픽을 요하는 것까지 다양하게 제공되므로, 예제 파일을 분석하며 공부하는 것도 많은 도움이 될 것입니다. CUDA를 공부하면 C/C++로 이미 만들어져 있는 프로그램을 포팅하는 것을 주로 하게 되고, 어떻게 최적화를 하느냐에 따라 같은 내용을 실행시키더라도 성능이 확연하게 달라질 수 있습니다. 따라서 이미 잘 짜여져 있는 성능 좋은 코드를 많이 보는 것이 공부에 도움이 될 것입니다. CUDA Project는 C/C++ Project를 그대로 이용해도 상관 없으나, VS에서는 CUDA를 설치하면 다음과 같이 CUDA 5. 0 Runtime Project를 바로 생성할 수 있도록 해 줍니다.  CUDA 5. 0 Rumtime Project를 생성하면 따로 무언가를 설정할 필요 없이 바로 컴파일이나 빌드를 할 수 있도록 되어 있습니다. 생성하면 kernel. cu라는 소스 파일 하나가 공통적으로 들어가 있는데요. 여기에는 1차원 array를 더하는 내용의 코드가 포함되어 있습니다. 무척 간단한 코드로 실행시켜 보면 다음과 같은 결과가 출력됩니다.  이것으로 CUDA 예제를 가능한 모든 방법을 동원하여 실행하여 보았습니다. CUDA는 아직 한글로 번역된 책이 많이 없기 때문에 이미 만들어져 있는 예제들을 보면서 실행시켜 보고, 스스로 분석하고, 다른 코드를 CUDA로 포팅해보는 연습을 하다 보면 실력이 많이 느는 것을 확인할 수 있을 것입니다. 자, 이렇게 CUDA 5. 0을 사용하여 코딩할 준비가 모두 끝났습니다. 다음 포스팅에서는 위 화면에 보이는 바와 같이 CUDA Syntax Highlighting 하는 방법에 대해서 이야기하도록 하겠습니다. "
    }, {
    "id": 107,
    "url": "http://localhost:4000/cuda-install/",
    "title": "[CUDA 5.0] CUDA 설치하기",
    "body": "2015/03/30 - ※ 이 글은 2013년도에 작성된 글입니다. 사진이나 세부적인 내용은 지금과 다를 수 있습니다. CUDA 5. 0은 이전 버전들과는 달리 설치가 매우 간편해진 것이 특징입니다. NVIDIA 사이트에서 CUDA ZONE을 들어가면 영어로 된 developer zone이 나오는데, 여기서 CUDA Download를 클릭해 들어가면 다음과 같은 페이지가 뜹니다. 참고로, NVIDIA Korea 사이트에서는 한글 번역을 지원해주지만 developer zone은 한글 번역을 지원해주지 않습니다. 또, 한국 사이트에서는 낮은 버전의 CUDA를 다운받게 되므로 꼭 원래 사이트에 들어가서 다운 받아 주세요.  여기서 Desktop/Notebook의 OS 등에 맞는 파일을 클릭하여 다운 받을 수 있습니다. CUDA 5. 0부터는 CUDA Toolkit과 SDK code samples, developer driver를 모두 한꺼번에 다운 받아 설치할 수 있어 무척이나 간편하게 설치할 수 있게 되어 있습니다. 다운 받은 installer를 실행하면 설치가 끝납니다. 설치가 끝나면 컴퓨터를 리부팅해야 CUDA를 사용할 수 있습니다. 자신의 GPU가 CUDA 가속을 지원하는 지에 대해서는 CUDA ZONE에서 CUDA GPUs를 들어가면 확인할 수 있습니다. Tesla, Quadro, NVS, GeForce 순으로 나와 있습니다. 현재는 대부분의 GPU들이 CUDA 가속을 지원합니다.  한 가지 더. CUDA를 사용하기 위해서는 그래픽 드라이버가 최신 버전이어야 합니다. NVIDIA 사이트에서 다운 받을 수 있으니 최신 버전인지를 확인하고 업데이트 하도록 합시다. 혹시 이후에 실행을 시켰는데 되지 않는다면 그래픽 드라이버가 최신 버전이 아니기 때문일 수도 있습니다. 자, 이렇게 CUDA 5. 0을 설치하여 사용할 준비가 끝났습니다. CUDA 5. 0에서는 다양한 예제 파일들을 같이 다운 받았기 때문에 그것들을 실행시켜 볼 수 있습니다. 예제 파일의 실행에 대해서는 다음 포스팅 때 이야기하도록 하겠습니다. "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-danger btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});